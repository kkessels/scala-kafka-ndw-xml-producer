// Generated by <a href="http://scalaxb.org/">scalaxb</a>.
package nu.ndw

import com.fasterxml.jackson.annotation.{JsonIgnore, JsonIgnoreProperties}



case class _AreaExtensionType(areaExtended: Option[nu.ndw.AreaExtended] = None,
  openlrExtendedArea: Option[nu.ndw.OpenlrExtendedArea] = None,
  any: Seq[scalaxb.DataRecord[Any]] = Nil)
      



case class _ChargeBandVersionedReference(attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) extends VersionedReferencable {
  @JsonIgnore lazy val id = attributes("@id").as[String]
  @JsonIgnore lazy val version = attributes("@version").as[String]
  @JsonIgnore lazy val targetClass = attributes("@targetClass").as[String]
}

      



case class _ContactDetailsVersionedReference(attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) extends VersionedReferencable {
  @JsonIgnore lazy val id = attributes("@id").as[String]
  @JsonIgnore lazy val version = attributes("@version").as[String]
  @JsonIgnore lazy val targetClass = attributes("@targetClass").as[String]
}

      


@JsonIgnoreProperties(Array("any"))
case class _ExtensionType(any: Seq[scalaxb.DataRecord[Any]] = Nil)
      



case class _GenericPublicationExtensionType(parkingTablePublication: Option[nu.ndw.ParkingTablePublication] = None,
  parkingVehiclesPublication: Option[nu.ndw.ParkingVehiclesPublication] = None,
  parkingStatusPublication: Option[nu.ndw.ParkingStatusPublication] = None,
  any: Seq[scalaxb.DataRecord[Any]] = Nil)
      



case class _GroupOfParkingSpaces(parkingSpaceBasics: nu.ndw.ParkingSpaceBasics, attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  @JsonIgnore lazy val groupIndex = attributes("@groupIndex").as[Int]
}

      



case class _GroupOfParkingSpacesParkingSpaceIndexParkingSpace(parkingSpace: nu.ndw.ParkingSpace, attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  @JsonIgnore lazy val parkingSpaceIndex = attributes("@parkingSpaceIndex").as[Int]
}

      



case class _IntermediatePointOnLinearElement(referent: nu.ndw.Referent, attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  @JsonIgnore lazy val index = attributes("@index").as[Int]
}

      



case class _LinearExtensionType(openlrExtendedLinear: Option[nu.ndw.OpenlrExtendedLinear] = None,
  any: Seq[scalaxb.DataRecord[Any]] = Nil)
      



case class _LocationContainedInItinerary(location: nu.ndw.Location, attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  @JsonIgnore lazy val index = attributes("@index").as[Int]
}

      



case class _MeasurementSiteRecordIndexMeasurementSpecificCharacteristics(measurementSpecificCharacteristics: nu.ndw.MeasurementSpecificCharacteristics, attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  @JsonIgnore lazy val index = attributes("@index").as[Int]
}

      



case class _MeasurementSiteRecordVersionedReference(attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) extends VersionedReferencable {
  @JsonIgnore lazy val id = attributes("@id").as[String]
  @JsonIgnore lazy val version = attributes("@version").as[String]
  @JsonIgnore lazy val targetClass = attributes("@targetClass").as[String]
}

      



case class _MeasurementSiteTableVersionedReference(attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) extends VersionedReferencable {
  @JsonIgnore lazy val id = attributes("@id").as[String]
  @JsonIgnore lazy val version = attributes("@version").as[String]
  @JsonIgnore lazy val targetClass = attributes("@targetClass").as[String]
}

      



case class _ParkingAccessReference(attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) extends Referencable {
  @JsonIgnore lazy val id = attributes("@id").as[String]
  @JsonIgnore lazy val targetClass = attributes("@targetClass").as[String]
}

      



case class _ParkingRecordEquipmentOrServiceFacilityIndexParkingEquipmentOrServiceFacility(parkingEquipmentOrServiceFacility: nu.ndw.ParkingEquipmentOrServiceFacility, attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  @JsonIgnore lazy val equipmentOrServiceFacilityIndex = attributes("@equipmentOrServiceFacilityIndex").as[Int]
}

      



case class _ParkingRecordStatusEquipmentOrServiceFacilityIndexParkingEquipmentOrServiceFacilityStatus(parkingEquipmentOrServiceFacilityStatus: nu.ndw.ParkingEquipmentOrServiceFacilityStatus, attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  @JsonIgnore lazy val equipmentOrServiceFacilityIndex = attributes("@equipmentOrServiceFacilityIndex").as[Int]
}

      



case class _ParkingRecordStatusGroupIndexGroupOfParkingSpacesStatus(groupOfParkingSpacesStatus: nu.ndw.GroupOfParkingSpacesStatus, attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  @JsonIgnore lazy val groupIndex = attributes("@groupIndex").as[Int]
}

      



case class _ParkingRecordStatusParkingSpaceIndexParkingSpaceStatus(parkingSpaceStatus: nu.ndw.ParkingSpaceStatus, attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  @JsonIgnore lazy val parkingSpaceIndex = attributes("@parkingSpaceIndex").as[Int]
}

      



case class _ParkingRecordStatusScenarioIndexParkingUsageScenarioStatus(parkingUsageScenarioStatus: nu.ndw.ParkingUsageScenarioStatus, attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  @JsonIgnore lazy val scenarioIndex = attributes("@scenarioIndex").as[Int]
}

      



case class _ParkingRecordVersionedReference(attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) extends VersionedReferencable {
  @JsonIgnore lazy val id = attributes("@id").as[String]
  @JsonIgnore lazy val version = attributes("@version").as[String]
  @JsonIgnore lazy val targetClass = attributes("@targetClass").as[String]
}

      



case class _ParkingRouteDetailsVersionedReference(attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) extends VersionedReferencable {
  @JsonIgnore lazy val id = attributes("@id").as[String]
  @JsonIgnore lazy val version = attributes("@version").as[String]
  @JsonIgnore lazy val targetClass = attributes("@targetClass").as[String]
}

      



case class _ParkingSiteScenarioIndexParkingUsageScenario(parkingUsageScenario: nu.ndw.ParkingUsageScenario, attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  @JsonIgnore lazy val scenarioIndex = attributes("@scenarioIndex").as[Int]
}

      



case class _ParkingSpace(parkingSpaceBasics: nu.ndw.ParkingSpaceBasics, attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  @JsonIgnore lazy val parkingSpaceIndex = attributes("@parkingSpaceIndex").as[Int]
}

      



case class _ParkingSpaceBasicsEquipmentOrServiceFacilityIndexParkingEquipmentOrServiceFacility(parkingEquipmentOrServiceFacility: nu.ndw.ParkingEquipmentOrServiceFacility, attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  @JsonIgnore lazy val equipmentOrServiceFacilityIndex = attributes("@equipmentOrServiceFacilityIndex").as[Int]
}

      



case class _ParkingSpaceBasicsScenarioIndexParkingUsageScenario(parkingUsageScenario: nu.ndw.ParkingUsageScenario, attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  @JsonIgnore lazy val scenarioIndex = attributes("@scenarioIndex").as[Int]
}

      



case class _ParkingTableVersionedReference(attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) extends VersionedReferencable {
  @JsonIgnore lazy val id = attributes("@id").as[String]
  @JsonIgnore lazy val version = attributes("@version").as[String]
  @JsonIgnore lazy val targetClass = attributes("@targetClass").as[String]
}

      



case class _PeriodExtensionType(periodExtended: Option[nu.ndw.PeriodExtended] = None,
  any: Seq[scalaxb.DataRecord[Any]] = Nil)
      



case class _PointExtensionType(pointExtended: Option[nu.ndw.PointExtended] = None,
  openlrExtendedPoint: Option[nu.ndw.OpenlrExtendedPoint] = None,
  any: Seq[scalaxb.DataRecord[Any]] = Nil)
      



case class _PolygonAreaIndexPointCoordinates(pointCoordinates: nu.ndw.PointCoordinates, attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  @JsonIgnore lazy val index = attributes("@index").as[Int]
}

      



case class _PredefinedItineraryIndexPredefinedLocation(predefinedLocation: nu.ndw.PredefinedLocation, attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  @JsonIgnore lazy val index = attributes("@index").as[Int]
}

      



case class _PredefinedItineraryVersionedReference(attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) extends VersionedReferencable {
  @JsonIgnore lazy val id = attributes("@id").as[String]
  @JsonIgnore lazy val version = attributes("@version").as[String]
  @JsonIgnore lazy val targetClass = attributes("@targetClass").as[String]
}

      



case class _PredefinedLocationVersionedReference(attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) extends VersionedReferencable {
  @JsonIgnore lazy val id = attributes("@id").as[String]
  @JsonIgnore lazy val version = attributes("@version").as[String]
  @JsonIgnore lazy val targetClass = attributes("@targetClass").as[String]
}

      



case class _PredefinedNonOrderedLocationGroupVersionedReference(attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) extends VersionedReferencable {
  @JsonIgnore lazy val id = attributes("@id").as[String]
  @JsonIgnore lazy val version = attributes("@version").as[String]
  @JsonIgnore lazy val targetClass = attributes("@targetClass").as[String]
}

      



case class _SiteMeasurementsIndexMeasuredValue(measuredValue: nu.ndw.MeasuredValue, attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  @JsonIgnore lazy val index = attributes("@index").as[Int]
}

      



case class _SituationRecordExtensionType(situationRecordExtendedApproved: Option[nu.ndw.SituationRecordExtendedApproved] = None,
  any: Seq[scalaxb.DataRecord[Any]] = Nil)
      



case class _SituationRecordVersionedReference(attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) extends VersionedReferencable {
  @JsonIgnore lazy val id = attributes("@id").as[String]
  @JsonIgnore lazy val version = attributes("@version").as[String]
  @JsonIgnore lazy val targetClass = attributes("@targetClass").as[String]
}

      



case class _SituationVersionedReference(attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) extends VersionedReferencable {
  @JsonIgnore lazy val id = attributes("@id").as[String]
  @JsonIgnore lazy val version = attributes("@version").as[String]
  @JsonIgnore lazy val targetClass = attributes("@targetClass").as[String]
}

      



case class _TextPage(vmsText: nu.ndw.VmsText, attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  @JsonIgnore lazy val pageNumber = attributes("@pageNumber").as[Int]
}

      



case class _VehicleCharacteristicsExtensionType(vehicleCharacteristicsExtended: Option[nu.ndw.VehicleCharacteristicsExtended] = None,
  any: Seq[scalaxb.DataRecord[Any]] = Nil)
      



case class _VmsDynamicCharacteristicsPictogramDisplayAreaIndexVmsPictogramDisplayCharacteristics(vmsPictogramDisplayCharacteristics: nu.ndw.VmsPictogramDisplayCharacteristics, attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  @JsonIgnore lazy val pictogramDisplayAreaIndex = attributes("@pictogramDisplayAreaIndex").as[Int]
}

      



case class _VmsMessageIndexVmsMessage(vmsMessage: nu.ndw.VmsMessage, attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  @JsonIgnore lazy val messageIndex = attributes("@messageIndex").as[Int]
}

      



case class _VmsMessagePictogramDisplayAreaIndexVmsPictogramDisplayArea(vmsPictogramDisplayArea: nu.ndw.VmsPictogramDisplayArea, attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  @JsonIgnore lazy val pictogramDisplayAreaIndex = attributes("@pictogramDisplayAreaIndex").as[Int]
}

      



case class _VmsPictogramDisplayAreaIndexPictogramDisplayAreaSettings(pictogramDisplayAreaSettings: nu.ndw.PictogramDisplayAreaSettings, attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  @JsonIgnore lazy val pictogramDisplayAreaIndex = attributes("@pictogramDisplayAreaIndex").as[Int]
}

      



case class _VmsPictogramDisplayAreaPictogramSequencingIndexVmsPictogram(vmsPictogram: nu.ndw.VmsPictogram, attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  @JsonIgnore lazy val pictogramSequencingIndex = attributes("@pictogramSequencingIndex").as[Int]
}

      



case class _VmsRecordPictogramDisplayAreaIndexVmsPictogramDisplayCharacteristics(vmsPictogramDisplayCharacteristics: nu.ndw.VmsPictogramDisplayCharacteristics, attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  @JsonIgnore lazy val pictogramDisplayAreaIndex = attributes("@pictogramDisplayAreaIndex").as[Int]
}

      



case class _VmsTextLineIndexVmsTextLine(vmsTextLine: nu.ndw.VmsTextLine, attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  @JsonIgnore lazy val lineIndex = attributes("@lineIndex").as[Int]
}

      



case class _VmsUnitRecordVersionedReference(attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) extends VersionedReferencable {
  @JsonIgnore lazy val id = attributes("@id").as[String]
  @JsonIgnore lazy val version = attributes("@version").as[String]
  @JsonIgnore lazy val targetClass = attributes("@targetClass").as[String]
}

      



case class _VmsUnitRecordVmsIndexVmsRecord(vmsRecord: nu.ndw.VmsRecord, attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  @JsonIgnore lazy val vmsIndex = attributes("@vmsIndex").as[Int]
}

      



case class _VmsUnitTableVersionedReference(attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) extends VersionedReferencable {
  @JsonIgnore lazy val id = attributes("@id").as[String]
  @JsonIgnore lazy val version = attributes("@version").as[String]
  @JsonIgnore lazy val targetClass = attributes("@targetClass").as[String]
}

      



case class _VmsUnitVmsIndexVms(vms: nu.ndw.Vms, attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  @JsonIgnore lazy val vmsIndex = attributes("@vmsIndex").as[Int]
}

      



case class AbnormalTraffic(situationRecordCreationReference: Option[String] = None,
  situationRecordCreationTime: javax.xml.datatype.XMLGregorianCalendar,
  situationRecordObservationTime: Option[javax.xml.datatype.XMLGregorianCalendar] = None,
  situationRecordVersionTime: javax.xml.datatype.XMLGregorianCalendar,
  situationRecordFirstSupplierVersionTime: Option[javax.xml.datatype.XMLGregorianCalendar] = None,
  confidentialityOverride: Option[nu.ndw.ConfidentialityValueEnum] = None,
  probabilityOfOccurrence: nu.ndw.ProbabilityOfOccurrenceEnum,
  severity: Option[nu.ndw.SeverityEnum] = None,
  source: Option[nu.ndw.Source] = None,
  validity: nu.ndw.Validity,
  impact: Option[nu.ndw.Impact] = None,
  cause: Option[nu.ndw.Cause] = None,
  generalPublicComment: Seq[nu.ndw.Comment] = Nil,
  nonGeneralPublicComment: Seq[nu.ndw.Comment] = Nil,
  urlLink: Seq[nu.ndw.UrlLink] = Nil,
  groupOfLocations: nu.ndw.GroupOfLocations,
  management: Option[nu.ndw.Management] = None,
  situationRecordExtension: Option[nu.ndw._SituationRecordExtensionType] = None,
  trafficElementExtension: Option[nu.ndw._ExtensionType] = None,
  abnormalTrafficType: Option[nu.ndw.AbnormalTrafficTypeEnum] = None,
  numberOfVehiclesWaiting: Option[Int] = None,
  queueLength: Option[Int] = None,
  relativeTrafficFlow: Option[nu.ndw.RelativeTrafficFlowEnum] = None,
  trafficFlowCharacteristics: Option[nu.ndw.TrafficFlowCharacteristicsEnum] = None,
  trafficTrendType: Option[nu.ndw.TrafficTrendTypeEnum] = None,
  abnormalTrafficExtension: Option[nu.ndw._ExtensionType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) extends TrafficElement {
  @JsonIgnore lazy val id = attributes("@id").as[String]
  @JsonIgnore lazy val version = attributes("@version").as[String]
}

      

sealed trait AbnormalTrafficTypeEnum

object AbnormalTrafficTypeEnum {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[nu.ndw.AbnormalTrafficTypeEnum]): AbnormalTrafficTypeEnum = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: AbnormalTrafficTypeEnum) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
}

case object StationaryTraffic extends AbnormalTrafficTypeEnum { override def toString = "stationaryTraffic" }
case object QueuingTraffic extends AbnormalTrafficTypeEnum { override def toString = "queuingTraffic" }
case object SlowTraffic extends AbnormalTrafficTypeEnum { override def toString = "slowTraffic" }
case object HeavyTraffic extends AbnormalTrafficTypeEnum { override def toString = "heavyTraffic" }
case object UnspecifiedAbnormalTraffic extends AbnormalTrafficTypeEnum { override def toString = "unspecifiedAbnormalTraffic" }
case object OtherValue50 extends AbnormalTrafficTypeEnum { override def toString = "other" }



case class AcceptedPaymentCards(paymentCards: Seq[nu.ndw.PaymentCardTypesEnum] = Nil,
  otherPaymentCards: Seq[String] = Nil,
  paymentCardBrands: Seq[nu.ndw.PaymentCardBrandsEnum] = Nil,
  otherPaymentCardBrands: Seq[String] = Nil,
  acceptedPaymentCardsExtension: Option[nu.ndw._ExtensionType] = None)
      

sealed trait AccessCategoryEnum

object AccessCategoryEnum {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[nu.ndw.AccessCategoryEnum]): AccessCategoryEnum = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: AccessCategoryEnum) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
}

case object VehicleEntranceAndExit extends AccessCategoryEnum { override def toString = "vehicleEntranceAndExit" }
case object VehicleEntrance extends AccessCategoryEnum { override def toString = "vehicleEntrance" }
case object VehicleExit extends AccessCategoryEnum { override def toString = "vehicleExit" }
case object PedestrianEntranceAndExit extends AccessCategoryEnum { override def toString = "pedestrianEntranceAndExit" }
case object PedestrianEntrance extends AccessCategoryEnum { override def toString = "pedestrianEntrance" }
case object PedestrianExit extends AccessCategoryEnum { override def toString = "pedestrianExit" }
case object RentalCarReturn extends AccessCategoryEnum { override def toString = "rentalCarReturn" }
case object Bicycles extends AccessCategoryEnum { override def toString = "bicycles" }
case object EmergencyExit extends AccessCategoryEnum { override def toString = "emergencyExit" }
case object UnspecifiedValue3 extends AccessCategoryEnum { override def toString = "unspecified" }
case object UnknownValue29 extends AccessCategoryEnum { override def toString = "unknown" }
case object OtherValue49 extends AccessCategoryEnum { override def toString = "other" }

sealed trait AccessEquipmentEnum

object AccessEquipmentEnum {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[nu.ndw.AccessEquipmentEnum]): AccessEquipmentEnum = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: AccessEquipmentEnum) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
}

case object Barrier extends AccessEquipmentEnum { override def toString = "barrier" }
case object TrafficSignal extends AccessEquipmentEnum { override def toString = "trafficSignal" }
case object TicketButtonMachine extends AccessEquipmentEnum { override def toString = "ticketButtonMachine" }
case object TicketCardMachine extends AccessEquipmentEnum { override def toString = "ticketCardMachine" }
case object PayAndExitMachine extends AccessEquipmentEnum { override def toString = "payAndExitMachine" }
case object OtherValue51 extends AccessEquipmentEnum { override def toString = "other" }

sealed trait AccessibilityEnum

object AccessibilityEnum {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[nu.ndw.AccessibilityEnum]): AccessibilityEnum = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: AccessibilityEnum) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
}

case object BarrierFreeAccessible extends AccessibilityEnum { override def toString = "barrierFreeAccessible" }
case object HandicappedAccessible extends AccessibilityEnum { override def toString = "handicappedAccessible" }
case object WheelChairAccessible extends AccessibilityEnum { override def toString = "wheelChairAccessible" }
case object HandicappedEasements extends AccessibilityEnum { override def toString = "handicappedEasements" }
case object OrientationSystemForBlindPeople extends AccessibilityEnum { override def toString = "orientationSystemForBlindPeople" }
case object HandicappedMarked extends AccessibilityEnum { override def toString = "handicappedMarked" }
case object NoneTypeValue4 extends AccessibilityEnum { override def toString = "none" }
case object UnknownValue28 extends AccessibilityEnum { override def toString = "unknown" }
case object OtherValue48 extends AccessibilityEnum { override def toString = "other" }



case class AccidentType(situationRecordCreationReference: Option[String] = None,
  situationRecordCreationTime: javax.xml.datatype.XMLGregorianCalendar,
  situationRecordObservationTime: Option[javax.xml.datatype.XMLGregorianCalendar] = None,
  situationRecordVersionTime: javax.xml.datatype.XMLGregorianCalendar,
  situationRecordFirstSupplierVersionTime: Option[javax.xml.datatype.XMLGregorianCalendar] = None,
  confidentialityOverride: Option[nu.ndw.ConfidentialityValueEnum] = None,
  probabilityOfOccurrence: nu.ndw.ProbabilityOfOccurrenceEnum,
  severity: Option[nu.ndw.SeverityEnum] = None,
  source: Option[nu.ndw.Source] = None,
  validity: nu.ndw.Validity,
  impact: Option[nu.ndw.Impact] = None,
  cause: Option[nu.ndw.Cause] = None,
  generalPublicComment: Seq[nu.ndw.Comment] = Nil,
  nonGeneralPublicComment: Seq[nu.ndw.Comment] = Nil,
  urlLink: Seq[nu.ndw.UrlLink] = Nil,
  groupOfLocations: nu.ndw.GroupOfLocations,
  management: Option[nu.ndw.Management] = None,
  situationRecordExtension: Option[nu.ndw._SituationRecordExtensionType] = None,
  trafficElementExtension: Option[nu.ndw._ExtensionType] = None,
  accidentCause: Option[nu.ndw.AccidentCauseEnum] = None,
  accidentType: Seq[nu.ndw.AccidentTypeEnum] = Nil,
  totalNumberOfPeopleInvolved: Option[Int] = None,
  totalNumberOfVehiclesInvolved: Option[Int] = None,
  vehicleInvolved: Seq[nu.ndw.Vehicle] = Nil,
  groupOfVehiclesInvolved: Seq[nu.ndw.GroupOfVehiclesInvolved] = Nil,
  groupOfPeopleInvolved: Seq[nu.ndw.GroupOfPeopleInvolved] = Nil,
  accidentExtension: Option[nu.ndw._ExtensionType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) extends TrafficElement {
  @JsonIgnore lazy val id = attributes("@id").as[String]
  @JsonIgnore lazy val version = attributes("@version").as[String]
}

      

sealed trait AccidentCauseEnum

object AccidentCauseEnum {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[nu.ndw.AccidentCauseEnum]): AccidentCauseEnum = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: AccidentCauseEnum) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
}

case object AvoidanceOfObstacles extends AccidentCauseEnum { override def toString = "avoidanceOfObstacles" }
case object DriverDistraction extends AccidentCauseEnum { override def toString = "driverDistraction" }
case object DriverDrugAbuse extends AccidentCauseEnum { override def toString = "driverDrugAbuse" }
case object DriverIllness extends AccidentCauseEnum { override def toString = "driverIllness" }
case object ExceedingSpeedsLimits extends AccidentCauseEnum { override def toString = "exceedingSpeedsLimits" }
case object ExcessAlcohol extends AccidentCauseEnum { override def toString = "excessAlcohol" }
case object ExcessiveDriverTiredness extends AccidentCauseEnum { override def toString = "excessiveDriverTiredness" }
case object ImpermissibleManoeuvre extends AccidentCauseEnum { override def toString = "impermissibleManoeuvre" }
case object LimitedVisibility extends AccidentCauseEnum { override def toString = "limitedVisibility" }
case object NotKeepingASafeDistance extends AccidentCauseEnum { override def toString = "notKeepingASafeDistance" }
case object OnTheWrongSideOfTheRoad extends AccidentCauseEnum { override def toString = "onTheWrongSideOfTheRoad" }
case object PedestrianInRoad extends AccidentCauseEnum { override def toString = "pedestrianInRoad" }
case object PoorLaneAdherence extends AccidentCauseEnum { override def toString = "poorLaneAdherence" }
case object PoorMergeEntryOrExitJudgement extends AccidentCauseEnum { override def toString = "poorMergeEntryOrExitJudgement" }
case object PoorRoadSurfaceCondition extends AccidentCauseEnum { override def toString = "poorRoadSurfaceCondition" }
case object PoorSurfaceAdherence extends AccidentCauseEnum { override def toString = "poorSurfaceAdherence" }
case object Undisclosed extends AccidentCauseEnum { override def toString = "undisclosed" }
case object UnknownValue27 extends AccidentCauseEnum { override def toString = "unknown" }
case object VehicleFailure extends AccidentCauseEnum { override def toString = "vehicleFailure" }
case object OtherValue47 extends AccidentCauseEnum { override def toString = "other" }

sealed trait AccidentTypeEnum

object AccidentTypeEnum {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[nu.ndw.AccidentTypeEnum]): AccidentTypeEnum = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: AccidentTypeEnum) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
}

case object AccidentValue extends AccidentTypeEnum { override def toString = "accident" }
case object AccidentInvolvingBicycles extends AccidentTypeEnum { override def toString = "accidentInvolvingBicycles" }
case object AccidentInvolvingBuses extends AccidentTypeEnum { override def toString = "accidentInvolvingBuses" }
case object AccidentInvolvingHazardousMaterials extends AccidentTypeEnum { override def toString = "accidentInvolvingHazardousMaterials" }
case object AccidentInvolvingHeavyLorries extends AccidentTypeEnum { override def toString = "accidentInvolvingHeavyLorries" }
case object AccidentInvolvingMassTransitVehicle extends AccidentTypeEnum { override def toString = "accidentInvolvingMassTransitVehicle" }
case object AccidentInvolvingMopeds extends AccidentTypeEnum { override def toString = "accidentInvolvingMopeds" }
case object AccidentInvolvingMotorcycles extends AccidentTypeEnum { override def toString = "accidentInvolvingMotorcycles" }
case object AccidentInvolvingRadioactiveMaterial extends AccidentTypeEnum { override def toString = "accidentInvolvingRadioactiveMaterial" }
case object AccidentInvolvingTrain extends AccidentTypeEnum { override def toString = "accidentInvolvingTrain" }
case object ChemicalSpillageAccident extends AccidentTypeEnum { override def toString = "chemicalSpillageAccident" }
case object Collision extends AccidentTypeEnum { override def toString = "collision" }
case object CollisionWithAnimal extends AccidentTypeEnum { override def toString = "collisionWithAnimal" }
case object CollisionWithObstruction extends AccidentTypeEnum { override def toString = "collisionWithObstruction" }
case object CollisionWithPerson extends AccidentTypeEnum { override def toString = "collisionWithPerson" }
case object EarlierAccident extends AccidentTypeEnum { override def toString = "earlierAccident" }
case object FuelSpillageAccident extends AccidentTypeEnum { override def toString = "fuelSpillageAccident" }
case object HeadOnCollision extends AccidentTypeEnum { override def toString = "headOnCollision" }
case object HeadOnOrSideCollision extends AccidentTypeEnum { override def toString = "headOnOrSideCollision" }
case object JackknifedArticulatedLorry extends AccidentTypeEnum { override def toString = "jackknifedArticulatedLorry" }
case object JackknifedCaravan extends AccidentTypeEnum { override def toString = "jackknifedCaravan" }
case object JackknifedTrailer extends AccidentTypeEnum { override def toString = "jackknifedTrailer" }
case object MultipleVehicleCollision extends AccidentTypeEnum { override def toString = "multipleVehicleCollision" }
case object MultivehicleAccident extends AccidentTypeEnum { override def toString = "multivehicleAccident" }
case object OilSpillageAccident extends AccidentTypeEnum { override def toString = "oilSpillageAccident" }
case object OverturnedHeavyLorry extends AccidentTypeEnum { override def toString = "overturnedHeavyLorry" }
case object OverturnedTrailer extends AccidentTypeEnum { override def toString = "overturnedTrailer" }
case object OverturnedVehicle extends AccidentTypeEnum { override def toString = "overturnedVehicle" }
case object RearCollision extends AccidentTypeEnum { override def toString = "rearCollision" }
case object SecondaryAccident extends AccidentTypeEnum { override def toString = "secondaryAccident" }
case object SeriousAccident extends AccidentTypeEnum { override def toString = "seriousAccident" }
case object SideCollision extends AccidentTypeEnum { override def toString = "sideCollision" }
case object VehicleOffRoad extends AccidentTypeEnum { override def toString = "vehicleOffRoad" }
case object VehicleSpunAround extends AccidentTypeEnum { override def toString = "vehicleSpunAround" }
case object OtherValue52 extends AccidentTypeEnum { override def toString = "other" }


sealed trait Activity extends TrafficElement {
  def situationRecordCreationReference: Option[String]
  def situationRecordCreationTime: javax.xml.datatype.XMLGregorianCalendar
  def situationRecordObservationTime: Option[javax.xml.datatype.XMLGregorianCalendar]
  def situationRecordVersionTime: javax.xml.datatype.XMLGregorianCalendar
  def situationRecordFirstSupplierVersionTime: Option[javax.xml.datatype.XMLGregorianCalendar]
  def confidentialityOverride: Option[nu.ndw.ConfidentialityValueEnum]
  def probabilityOfOccurrence: nu.ndw.ProbabilityOfOccurrenceEnum
  def severity: Option[nu.ndw.SeverityEnum]
  def source: Option[nu.ndw.Source]
  def validity: nu.ndw.Validity
  def impact: Option[nu.ndw.Impact]
  def cause: Option[nu.ndw.Cause]
  def generalPublicComment: Seq[nu.ndw.Comment]
  def nonGeneralPublicComment: Seq[nu.ndw.Comment]
  def urlLink: Seq[nu.ndw.UrlLink]
  def groupOfLocations: nu.ndw.GroupOfLocations
  def management: Option[nu.ndw.Management]
  def situationRecordExtension: Option[nu.ndw._SituationRecordExtensionType]
  def trafficElementExtension: Option[nu.ndw._ExtensionType]
  def mobilityOfActivity: Option[nu.ndw.Mobility]
  def activityExtension: Option[nu.ndw._ExtensionType]
  def id: String
  def version: String
}



case class AffectedCarriagewayAndLanes(carriageway: nu.ndw.CarriagewayEnum,
  lane: Seq[nu.ndw.LaneEnum] = Nil,
  footpath: Option[Boolean] = None,
  lengthAffected: Option[Float] = None,
  affectedCarriagewayAndLanesExtension: Option[nu.ndw._ExtensionType] = None)
      



case class AlertCArea(alertCLocationCountryCode: String,
  alertCLocationTableNumber: String,
  alertCLocationTableVersion: String,
  areaLocation: nu.ndw.AlertCLocation,
  alertCAreaExtension: Option[nu.ndw._ExtensionType] = None)
      



case class AlertCDirection(alertCDirectionCoded: nu.ndw.AlertCDirectionEnum,
  alertCDirectionNamed: Option[nu.ndw.MultilingualString] = None,
  alertCDirectionSense: Option[Boolean] = None,
  alertCDirectionExtension: Option[nu.ndw._ExtensionType] = None)
      

sealed trait AlertCDirectionEnum

object AlertCDirectionEnum {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[nu.ndw.AlertCDirectionEnum]): AlertCDirectionEnum = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: AlertCDirectionEnum) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
}

case object BothValue2 extends AlertCDirectionEnum { override def toString = "both" }
case object Negative extends AlertCDirectionEnum { override def toString = "negative" }
case object Positive extends AlertCDirectionEnum { override def toString = "positive" }
case object UnknownValue26 extends AlertCDirectionEnum { override def toString = "unknown" }


sealed trait AlertCLinear {
  def alertCLocationCountryCode: String
  def alertCLocationTableNumber: String
  def alertCLocationTableVersion: String
  def alertCLinearExtension: Option[nu.ndw._ExtensionType]
}



case class AlertCLinearByCode(alertCLocationCountryCode: String,
  alertCLocationTableNumber: String,
  alertCLocationTableVersion: String,
  alertCLinearExtension: Option[nu.ndw._ExtensionType] = None,
  alertCDirection: nu.ndw.AlertCDirection,
  locationCodeForLinearLocation: nu.ndw.AlertCLocation,
  alertCLinearByCodeExtension: Option[nu.ndw._ExtensionType] = None) extends AlertCLinear
      



case class AlertCLocation(alertCLocationName: Option[nu.ndw.MultilingualString] = None,
  specificLocation: Int,
  alertCLocationExtension: Option[nu.ndw._ExtensionType] = None)
      



case class AlertCMethod2Linear(alertCLocationCountryCode: String,
  alertCLocationTableNumber: String,
  alertCLocationTableVersion: String,
  alertCLinearExtension: Option[nu.ndw._ExtensionType] = None,
  alertCDirection: nu.ndw.AlertCDirection,
  alertCMethod2PrimaryPointLocation: nu.ndw.AlertCMethod2PrimaryPointLocation,
  alertCMethod2SecondaryPointLocation: nu.ndw.AlertCMethod2SecondaryPointLocation,
  alertCMethod2LinearExtension: Option[nu.ndw._ExtensionType] = None) extends AlertCLinear
      



case class AlertCMethod2Point(alertCLocationCountryCode: String,
  alertCLocationTableNumber: String,
  alertCLocationTableVersion: String,
  alertCPointExtension: Option[nu.ndw._ExtensionType] = None,
  alertCDirection: nu.ndw.AlertCDirection,
  alertCMethod2PrimaryPointLocation: nu.ndw.AlertCMethod2PrimaryPointLocation,
  alertCMethod2PointExtension: Option[nu.ndw._ExtensionType] = None) extends AlertCPoint
      



case class AlertCMethod2PrimaryPointLocation(alertCLocation: nu.ndw.AlertCLocation,
  alertCMethod2PrimaryPointLocationExtension: Option[nu.ndw._ExtensionType] = None)
      



case class AlertCMethod2SecondaryPointLocation(alertCLocation: nu.ndw.AlertCLocation,
  alertCMethod2SecondaryPointLocationExtension: Option[nu.ndw._ExtensionType] = None)
      



case class AlertCMethod4Linear(alertCLocationCountryCode: String,
  alertCLocationTableNumber: String,
  alertCLocationTableVersion: String,
  alertCLinearExtension: Option[nu.ndw._ExtensionType] = None,
  alertCDirection: nu.ndw.AlertCDirection,
  alertCMethod4PrimaryPointLocation: nu.ndw.AlertCMethod4PrimaryPointLocation,
  alertCMethod4SecondaryPointLocation: nu.ndw.AlertCMethod4SecondaryPointLocation,
  alertCMethod4LinearExtension: Option[nu.ndw._ExtensionType] = None) extends AlertCLinear
      



case class AlertCMethod4Point(alertCLocationCountryCode: String,
  alertCLocationTableNumber: String,
  alertCLocationTableVersion: String,
  alertCPointExtension: Option[nu.ndw._ExtensionType] = None,
  alertCDirection: nu.ndw.AlertCDirection,
  alertCMethod4PrimaryPointLocation: nu.ndw.AlertCMethod4PrimaryPointLocation,
  alertCMethod4PointExtension: Option[nu.ndw._ExtensionType] = None) extends AlertCPoint
      



case class AlertCMethod4PrimaryPointLocation(alertCLocation: nu.ndw.AlertCLocation,
  offsetDistance: nu.ndw.OffsetDistance,
  alertCMethod4PrimaryPointLocationExtension: Option[nu.ndw._ExtensionType] = None)
      



case class AlertCMethod4SecondaryPointLocation(alertCLocation: nu.ndw.AlertCLocation,
  offsetDistance: nu.ndw.OffsetDistance,
  alertCMethod4SecondaryPointLocationExtension: Option[nu.ndw._ExtensionType] = None)
      


sealed trait AlertCPoint {
  def alertCLocationCountryCode: String
  def alertCLocationTableNumber: String
  def alertCLocationTableVersion: String
  def alertCPointExtension: Option[nu.ndw._ExtensionType]
}



case class AnimalPresenceObstruction(situationRecordCreationReference: Option[String] = None,
  situationRecordCreationTime: javax.xml.datatype.XMLGregorianCalendar,
  situationRecordObservationTime: Option[javax.xml.datatype.XMLGregorianCalendar] = None,
  situationRecordVersionTime: javax.xml.datatype.XMLGregorianCalendar,
  situationRecordFirstSupplierVersionTime: Option[javax.xml.datatype.XMLGregorianCalendar] = None,
  confidentialityOverride: Option[nu.ndw.ConfidentialityValueEnum] = None,
  probabilityOfOccurrence: nu.ndw.ProbabilityOfOccurrenceEnum,
  severity: Option[nu.ndw.SeverityEnum] = None,
  source: Option[nu.ndw.Source] = None,
  validity: nu.ndw.Validity,
  impact: Option[nu.ndw.Impact] = None,
  cause: Option[nu.ndw.Cause] = None,
  generalPublicComment: Seq[nu.ndw.Comment] = Nil,
  nonGeneralPublicComment: Seq[nu.ndw.Comment] = Nil,
  urlLink: Seq[nu.ndw.UrlLink] = Nil,
  groupOfLocations: nu.ndw.GroupOfLocations,
  management: Option[nu.ndw.Management] = None,
  situationRecordExtension: Option[nu.ndw._SituationRecordExtensionType] = None,
  trafficElementExtension: Option[nu.ndw._ExtensionType] = None,
  numberOfObstructions: Option[Int] = None,
  mobilityOfObstruction: Option[nu.ndw.Mobility] = None,
  obstructionExtension: Option[nu.ndw._ExtensionType] = None,
  alive: Option[Boolean] = None,
  animalPresenceType: nu.ndw.AnimalPresenceTypeEnum,
  animalPresenceObstructionExtension: Option[nu.ndw._ExtensionType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) extends ObstructionType {
  @JsonIgnore lazy val id = attributes("@id").as[String]
  @JsonIgnore lazy val version = attributes("@version").as[String]
}

      

sealed trait AnimalPresenceTypeEnum

object AnimalPresenceTypeEnum {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[nu.ndw.AnimalPresenceTypeEnum]): AnimalPresenceTypeEnum = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: AnimalPresenceTypeEnum) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
}

case object AnimalsOnTheRoad extends AnimalPresenceTypeEnum { override def toString = "animalsOnTheRoad" }
case object HerdOfAnimalsOnTheRoad extends AnimalPresenceTypeEnum { override def toString = "herdOfAnimalsOnTheRoad" }
case object LargeAnimalsOnTheRoad extends AnimalPresenceTypeEnum { override def toString = "largeAnimalsOnTheRoad" }



case class ApplicationRateValue(dataError: Option[Boolean] = None,
  reasonForDataError: Option[nu.ndw.MultilingualString] = None,
  dataValueExtension: Option[nu.ndw._ExtensionType] = None,
  applicationRate: Float,
  applicationRateValueExtension: Option[nu.ndw._ExtensionType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) extends DataValue {
  @JsonIgnore lazy val accuracy = attributes.get("@accuracy") map { _.as[Float]}
  @JsonIgnore lazy val computationalMethod = attributes.get("@computationalMethod") map { _.as[ComputationMethodEnum]}
  @JsonIgnore lazy val numberOfIncompleteInputs = attributes.get("@numberOfIncompleteInputs") map { _.as[Int]}
  @JsonIgnore lazy val numberOfInputValuesUsed = attributes.get("@numberOfInputValuesUsed") map { _.as[Int]}
  @JsonIgnore lazy val smoothingFactor = attributes.get("@smoothingFactor") map { _.as[Float]}
  @JsonIgnore lazy val standardDeviation = attributes.get("@standardDeviation") map { _.as[Float]}
  @JsonIgnore lazy val supplierCalculatedDataQuality = attributes.get("@supplierCalculatedDataQuality") map { _.as[Float]}
}

      



case class Area(groupOfLocationsExtension: Option[nu.ndw._ExtensionType] = None,
  externalReferencing: Seq[nu.ndw.ExternalReferencing] = Nil,
  locationForDisplay: Option[nu.ndw.PointCoordinates] = None,
  locationExtension: Option[nu.ndw._ExtensionType] = None,
  alertCArea: Option[nu.ndw.AlertCArea] = None,
  tpegAreaLocation: Option[nu.ndw.TpegAreaLocation] = None,
  areaExtension: Option[nu.ndw._AreaExtensionType] = None) extends Location
      



case class AreaDestination(destinationExtension: Option[nu.ndw._ExtensionType] = None,
  area: nu.ndw.Area,
  areaDestinationExtension: Option[nu.ndw._ExtensionType] = None) extends Destination
      



case class AreaExtended(namedArea: Option[nu.ndw.NamedArea] = None,
  polygonArea: Seq[nu.ndw.PolygonArea] = Nil)
      

sealed trait AreaOfInterestEnum

object AreaOfInterestEnum {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[nu.ndw.AreaOfInterestEnum]): AreaOfInterestEnum = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: AreaOfInterestEnum) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
}

case object ContinentWide extends AreaOfInterestEnum { override def toString = "continentWide" }
case object National extends AreaOfInterestEnum { override def toString = "national" }
case object NeighbouringCountries extends AreaOfInterestEnum { override def toString = "neighbouringCountries" }
case object NotSpecified extends AreaOfInterestEnum { override def toString = "notSpecified" }
case object Regional extends AreaOfInterestEnum { override def toString = "regional" }



case class AuthorityOperation(situationRecordCreationReference: Option[String] = None,
  situationRecordCreationTime: javax.xml.datatype.XMLGregorianCalendar,
  situationRecordObservationTime: Option[javax.xml.datatype.XMLGregorianCalendar] = None,
  situationRecordVersionTime: javax.xml.datatype.XMLGregorianCalendar,
  situationRecordFirstSupplierVersionTime: Option[javax.xml.datatype.XMLGregorianCalendar] = None,
  confidentialityOverride: Option[nu.ndw.ConfidentialityValueEnum] = None,
  probabilityOfOccurrence: nu.ndw.ProbabilityOfOccurrenceEnum,
  severity: Option[nu.ndw.SeverityEnum] = None,
  source: Option[nu.ndw.Source] = None,
  validity: nu.ndw.Validity,
  impact: Option[nu.ndw.Impact] = None,
  cause: Option[nu.ndw.Cause] = None,
  generalPublicComment: Seq[nu.ndw.Comment] = Nil,
  nonGeneralPublicComment: Seq[nu.ndw.Comment] = Nil,
  urlLink: Seq[nu.ndw.UrlLink] = Nil,
  groupOfLocations: nu.ndw.GroupOfLocations,
  management: Option[nu.ndw.Management] = None,
  situationRecordExtension: Option[nu.ndw._SituationRecordExtensionType] = None,
  trafficElementExtension: Option[nu.ndw._ExtensionType] = None,
  mobilityOfActivity: Option[nu.ndw.Mobility] = None,
  activityExtension: Option[nu.ndw._ExtensionType] = None,
  authorityOperationType: nu.ndw.AuthorityOperationTypeEnum,
  authorityOperationExtension: Option[nu.ndw._ExtensionType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) extends Activity {
  @JsonIgnore lazy val id = attributes("@id").as[String]
  @JsonIgnore lazy val version = attributes("@version").as[String]
}

      

sealed trait AuthorityOperationTypeEnum

object AuthorityOperationTypeEnum {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[nu.ndw.AuthorityOperationTypeEnum]): AuthorityOperationTypeEnum = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: AuthorityOperationTypeEnum) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
}

case object AccidentInvestigationWork extends AuthorityOperationTypeEnum { override def toString = "accidentInvestigationWork" }
case object BombSquadInAction extends AuthorityOperationTypeEnum { override def toString = "bombSquadInAction" }
case object CivilEmergency extends AuthorityOperationTypeEnum { override def toString = "civilEmergency" }
case object CustomsOperation extends AuthorityOperationTypeEnum { override def toString = "customsOperation" }
case object JuridicalReconstruction extends AuthorityOperationTypeEnum { override def toString = "juridicalReconstruction" }
case object PoliceCheckPoint extends AuthorityOperationTypeEnum { override def toString = "policeCheckPoint" }
case object PoliceInvestigation extends AuthorityOperationTypeEnum { override def toString = "policeInvestigation" }
case object RoadOperatorCheckPoint extends AuthorityOperationTypeEnum { override def toString = "roadOperatorCheckPoint" }
case object Survey extends AuthorityOperationTypeEnum { override def toString = "survey" }
case object TransportOfVip extends AuthorityOperationTypeEnum { override def toString = "transportOfVip" }
case object UndefinedAuthorityActivity extends AuthorityOperationTypeEnum { override def toString = "undefinedAuthorityActivity" }
case object VehicleInspectionCheckPoint extends AuthorityOperationTypeEnum { override def toString = "vehicleInspectionCheckPoint" }
case object VehicleWeighing extends AuthorityOperationTypeEnum { override def toString = "vehicleWeighing" }
case object WeighInMotion extends AuthorityOperationTypeEnum { override def toString = "weighInMotion" }
case object OtherValue53 extends AuthorityOperationTypeEnum { override def toString = "other" }

sealed trait AvailabilityEnum

object AvailabilityEnum {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[nu.ndw.AvailabilityEnum]): AvailabilityEnum = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: AvailabilityEnum) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
}

case object Available extends AvailabilityEnum { override def toString = "available" }
case object NotAvailable extends AvailabilityEnum { override def toString = "notAvailable" }
case object UnknownValue25 extends AvailabilityEnum { override def toString = "unknown" }



case class AxleFlowValue(dataError: Option[Boolean] = None,
  reasonForDataError: Option[nu.ndw.MultilingualString] = None,
  dataValueExtension: Option[nu.ndw._ExtensionType] = None,
  axleFlowRate: Int,
  axleFlowValueExtension: Option[nu.ndw._ExtensionType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) extends DataValue {
  @JsonIgnore lazy val accuracy = attributes.get("@accuracy") map { _.as[Float]}
  @JsonIgnore lazy val computationalMethod = attributes.get("@computationalMethod") map { _.as[ComputationMethodEnum]}
  @JsonIgnore lazy val numberOfIncompleteInputs = attributes.get("@numberOfIncompleteInputs") map { _.as[Int]}
  @JsonIgnore lazy val numberOfInputValuesUsed = attributes.get("@numberOfInputValuesUsed") map { _.as[Int]}
  @JsonIgnore lazy val smoothingFactor = attributes.get("@smoothingFactor") map { _.as[Float]}
  @JsonIgnore lazy val standardDeviation = attributes.get("@standardDeviation") map { _.as[Float]}
  @JsonIgnore lazy val supplierCalculatedDataQuality = attributes.get("@supplierCalculatedDataQuality") map { _.as[Float]}
}

      



case class AxleSpacing(axleSpacing: Float,
  axleSpacingSequenceIdentifier: Int,
  axleSpacingExtension: Option[nu.ndw._ExtensionType] = None)
      



case class AxleWeight(axlePositionIdentifier: Int,
  axleWeight: Option[Float] = None,
  maximumPermittedAxleWeight: Option[Float] = None,
  axleWeightExtension: Option[nu.ndw._ExtensionType] = None)
      


sealed trait BasicData {
  def measurementOrCalculationPeriod: Option[Float]
  def measurementOrCalculationTime: Option[javax.xml.datatype.XMLGregorianCalendar]
  def pertinentLocation: Option[nu.ndw.GroupOfLocations]
  def basicDataExtension: Option[nu.ndw._ExtensionType]
  def measurementOrCalculatedTimePrecision: Option[nu.ndw.TimePrecisionEnum]
}

sealed trait CarParkConfigurationEnum

object CarParkConfigurationEnum {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[nu.ndw.CarParkConfigurationEnum]): CarParkConfigurationEnum = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: CarParkConfigurationEnum) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
}

case object MultiStorey extends CarParkConfigurationEnum { override def toString = "multiStorey" }
case object ParkAndRide extends CarParkConfigurationEnum { override def toString = "parkAndRide" }
case object SingleLevel extends CarParkConfigurationEnum { override def toString = "singleLevel" }
case object Underground extends CarParkConfigurationEnum { override def toString = "underground" }



case class CarParks(situationRecordCreationReference: Option[String] = None,
  situationRecordCreationTime: javax.xml.datatype.XMLGregorianCalendar,
  situationRecordObservationTime: Option[javax.xml.datatype.XMLGregorianCalendar] = None,
  situationRecordVersionTime: javax.xml.datatype.XMLGregorianCalendar,
  situationRecordFirstSupplierVersionTime: Option[javax.xml.datatype.XMLGregorianCalendar] = None,
  confidentialityOverride: Option[nu.ndw.ConfidentialityValueEnum] = None,
  probabilityOfOccurrence: nu.ndw.ProbabilityOfOccurrenceEnum,
  severity: Option[nu.ndw.SeverityEnum] = None,
  source: Option[nu.ndw.Source] = None,
  validity: nu.ndw.Validity,
  impact: Option[nu.ndw.Impact] = None,
  cause: Option[nu.ndw.Cause] = None,
  generalPublicComment: Seq[nu.ndw.Comment] = Nil,
  nonGeneralPublicComment: Seq[nu.ndw.Comment] = Nil,
  urlLink: Seq[nu.ndw.UrlLink] = Nil,
  groupOfLocations: nu.ndw.GroupOfLocations,
  management: Option[nu.ndw.Management] = None,
  situationRecordExtension: Option[nu.ndw._SituationRecordExtensionType] = None,
  nonRoadEventInformationExtension: Option[nu.ndw._ExtensionType] = None,
  carParkConfiguration: Option[nu.ndw.CarParkConfigurationEnum] = None,
  carParkIdentity: String,
  carParkOccupancy: Option[Float] = None,
  carParkStatus: Option[nu.ndw.CarParkStatusEnum] = None,
  exitRate: Option[Int] = None,
  fillRate: Option[Int] = None,
  numberOfVacantParkingSpaces: Option[Int] = None,
  occupiedSpaces: Option[Int] = None,
  queuingTime: Option[Float] = None,
  totalCapacity: Option[Int] = None,
  carParksExtension: Option[nu.ndw._ExtensionType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) extends NonRoadEventInformation {
  @JsonIgnore lazy val id = attributes("@id").as[String]
  @JsonIgnore lazy val version = attributes("@version").as[String]
}

      

sealed trait CarParkStatusEnum

object CarParkStatusEnum {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[nu.ndw.CarParkStatusEnum]): CarParkStatusEnum = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: CarParkStatusEnum) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
}

case object CarParkClosed extends CarParkStatusEnum { override def toString = "carParkClosed" }
case object AllCarParksFull extends CarParkStatusEnum { override def toString = "allCarParksFull" }
case object CarParkFacilityFaulty extends CarParkStatusEnum { override def toString = "carParkFacilityFaulty" }
case object CarParkFullValue extends CarParkStatusEnum { override def toString = "carParkFull" }
case object CarParkStatusUnknown extends CarParkStatusEnum { override def toString = "carParkStatusUnknown" }
case object EnoughSpacesAvailable extends CarParkStatusEnum { override def toString = "enoughSpacesAvailable" }
case object MultiStoryCarParksFull extends CarParkStatusEnum { override def toString = "multiStoryCarParksFull" }
case object NoMoreParkingSpacesAvailable extends CarParkStatusEnum { override def toString = "noMoreParkingSpacesAvailable" }
case object NoParkAndRideInformation extends CarParkStatusEnum { override def toString = "noParkAndRideInformation" }
case object NoParkingAllowed extends CarParkStatusEnum { override def toString = "noParkingAllowed" }
case object NoParkingInformationAvailableValue extends CarParkStatusEnum { override def toString = "noParkingInformationAvailable" }
case object NormalParkingRestrictionsLifted extends CarParkStatusEnum { override def toString = "normalParkingRestrictionsLifted" }
case object OnlyAFewSpacesAvailable extends CarParkStatusEnum { override def toString = "onlyAFewSpacesAvailable" }
case object ParkAndRideServiceNotOperating extends CarParkStatusEnum { override def toString = "parkAndRideServiceNotOperating" }
case object ParkAndRideServiceOperating extends CarParkStatusEnum { override def toString = "parkAndRideServiceOperating" }
case object SpecialParkingRestrictionsInForce extends CarParkStatusEnum { override def toString = "specialParkingRestrictionsInForce" }

sealed trait CarriagewayEnum

object CarriagewayEnum {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[nu.ndw.CarriagewayEnum]): CarriagewayEnum = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: CarriagewayEnum) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
}

case object ConnectingCarriageway extends CarriagewayEnum { override def toString = "connectingCarriageway" }
case object EntrySlipRoad extends CarriagewayEnum { override def toString = "entrySlipRoad" }
case object ExitSlipRoad extends CarriagewayEnum { override def toString = "exitSlipRoad" }
case object Flyover extends CarriagewayEnum { override def toString = "flyover" }
case object LeftHandFeederRoad extends CarriagewayEnum { override def toString = "leftHandFeederRoad" }
case object LeftHandParallelCarriageway extends CarriagewayEnum { override def toString = "leftHandParallelCarriageway" }
case object MainCarriageway extends CarriagewayEnum { override def toString = "mainCarriageway" }
case object OppositeCarriageway extends CarriagewayEnum { override def toString = "oppositeCarriageway" }
case object ParallelCarriageway extends CarriagewayEnum { override def toString = "parallelCarriageway" }
case object RightHandFeederRoad extends CarriagewayEnum { override def toString = "rightHandFeederRoad" }
case object RightHandParallelCarriageway extends CarriagewayEnum { override def toString = "rightHandParallelCarriageway" }
case object RoundaboutValue extends CarriagewayEnum { override def toString = "roundabout" }
case object ServiceRoad extends CarriagewayEnum { override def toString = "serviceRoad" }
case object SlipRoads extends CarriagewayEnum { override def toString = "slipRoads" }
case object Underpass extends CarriagewayEnum { override def toString = "underpass" }



case class CatalogueReference(keyCatalogueReference: String,
  catalogueReferenceExtension: Option[nu.ndw._ExtensionType] = None)
      


sealed trait Cause {
  def causeExtension: Option[nu.ndw._ExtensionType]
}

sealed trait CauseTypeEnum

object CauseTypeEnum {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[nu.ndw.CauseTypeEnum]): CauseTypeEnum = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: CauseTypeEnum) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
}

case object AccidentValue2 extends CauseTypeEnum { override def toString = "accident" }
case object Congestion extends CauseTypeEnum { override def toString = "congestion" }
case object EarlierAccidentValue extends CauseTypeEnum { override def toString = "earlierAccident" }
case object EarlierEvent extends CauseTypeEnum { override def toString = "earlierEvent" }
case object EarlierIncident extends CauseTypeEnum { override def toString = "earlierIncident" }
case object EquipmentFailure extends CauseTypeEnum { override def toString = "equipmentFailure" }
case object ExcessiveHeat extends CauseTypeEnum { override def toString = "excessiveHeat" }
case object FrostValue extends CauseTypeEnum { override def toString = "frost" }
case object HolidayTraffic extends CauseTypeEnum { override def toString = "holidayTraffic" }
case object InfrastructureFailure extends CauseTypeEnum { override def toString = "infrastructureFailure" }
case object LargeNumbersOfVisitors extends CauseTypeEnum { override def toString = "largeNumbersOfVisitors" }
case object Obstruction extends CauseTypeEnum { override def toString = "obstruction" }
case object PollutionAlert extends CauseTypeEnum { override def toString = "pollutionAlert" }
case object PoorWeather extends CauseTypeEnum { override def toString = "poorWeather" }
case object ProblemsAtBorderPost extends CauseTypeEnum { override def toString = "problemsAtBorderPost" }
case object ProblemsAtCustomPost extends CauseTypeEnum { override def toString = "problemsAtCustomPost" }
case object ProblemsOnLocalRoads extends CauseTypeEnum { override def toString = "problemsOnLocalRoads" }
case object RadioactiveLeakAlert extends CauseTypeEnum { override def toString = "radioactiveLeakAlert" }
case object RoadsideEvent extends CauseTypeEnum { override def toString = "roadsideEvent" }
case object RubberNecking extends CauseTypeEnum { override def toString = "rubberNecking" }
case object SecurityIncident extends CauseTypeEnum { override def toString = "securityIncident" }
case object ShearWeightOfTraffic extends CauseTypeEnum { override def toString = "shearWeightOfTraffic" }
case object TechnicalProblems extends CauseTypeEnum { override def toString = "technicalProblems" }
case object Terrorism extends CauseTypeEnum { override def toString = "terrorism" }
case object ToxicCloudAlert extends CauseTypeEnum { override def toString = "toxicCloudAlert" }
case object Vandalism extends CauseTypeEnum { override def toString = "vandalism" }
case object OtherValue54 extends CauseTypeEnum { override def toString = "other" }

sealed trait ChangedFlagEnum

object ChangedFlagEnum {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[nu.ndw.ChangedFlagEnum]): ChangedFlagEnum = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: ChangedFlagEnum) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
}

case object CatalogueValue extends ChangedFlagEnum { override def toString = "catalogue" }
case object FilterValue extends ChangedFlagEnum { override def toString = "filter" }



case class Charge(charge: BigDecimal,
  chargeInterval: Option[Float] = None,
  chargeType: Option[nu.ndw.ChargeTypeEnum] = None,
  chargeTypeDescription: Option[nu.ndw.MultilingualString] = None,
  maxIterationsOfCharge: Option[Int] = None,
  minIterationsOfCharge: Option[Int] = None,
  chargeOrderIndex: Option[Int] = None,
  timePeriodOfDay: Option[nu.ndw.TimePeriodOfDay] = None,
  chargeExtension: Option[nu.ndw._ExtensionType] = None)
      



case class ChargeBand(chargeCurrency: nu.ndw.CurrencyEnum,
  maximumDuration: Option[Float] = None,
  chargeBandName: Option[nu.ndw.MultilingualString] = None,
  applicableForUser: Seq[nu.ndw.UserTypeEnum] = Nil,
  charge: Seq[nu.ndw.Charge] = Nil,
  applicableForPeriod: Option[nu.ndw.OverallPeriod] = None,
  applicableForVehicles: Seq[nu.ndw.VehicleCharacteristics] = Nil,
  parkingPermit: Seq[nu.ndw.ParkingPermit] = Nil,
  chargeBandExtension: Option[nu.ndw._ExtensionType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  @JsonIgnore lazy val id = attributes("@id").as[String]
  @JsonIgnore lazy val version = attributes("@version").as[String]
}

      



case class ChargeBandByReference(chargeBandReference: nu.ndw._ChargeBandVersionedReference,
  chargeBandByReferenceExtension: Option[nu.ndw._ExtensionType] = None)
      

sealed trait ChargeTypeEnum

object ChargeTypeEnum {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[nu.ndw.ChargeTypeEnum]): ChargeTypeEnum = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: ChargeTypeEnum) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
}

case object Minimum extends ChargeTypeEnum { override def toString = "minimum" }
case object Maximum extends ChargeTypeEnum { override def toString = "maximum" }
case object AdditionalIntervalPrice extends ChargeTypeEnum { override def toString = "additionalIntervalPrice" }
case object SeasonTicket extends ChargeTypeEnum { override def toString = "seasonTicket" }
case object TemporaryPrice extends ChargeTypeEnum { override def toString = "temporaryPrice" }
case object FirstIntervalPrice extends ChargeTypeEnum { override def toString = "firstIntervalPrice" }
case object FreeParking extends ChargeTypeEnum { override def toString = "freeParking" }
case object Flat extends ChargeTypeEnum { override def toString = "flat" }
case object UnknownValue24 extends ChargeTypeEnum { override def toString = "unknown" }
case object OtherValue46 extends ChargeTypeEnum { override def toString = "other" }

sealed trait ChargingStationUsageTypeEnum

object ChargingStationUsageTypeEnum {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[nu.ndw.ChargingStationUsageTypeEnum]): ChargingStationUsageTypeEnum = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: ChargingStationUsageTypeEnum) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
}

case object ElectricVehicle extends ChargingStationUsageTypeEnum { override def toString = "electricVehicle" }
case object MotorhomeOrCaravanSupply extends ChargingStationUsageTypeEnum { override def toString = "motorhomeOrCaravanSupply" }
case object ElectricBikeOrMotorcycle extends ChargingStationUsageTypeEnum { override def toString = "electricBikeOrMotorcycle" }
case object LorryPowerConsumption extends ChargingStationUsageTypeEnum { override def toString = "lorryPowerConsumption" }
case object ElectricalDevices extends ChargingStationUsageTypeEnum { override def toString = "electricalDevices" }
case object OtherValue55 extends ChargingStationUsageTypeEnum { override def toString = "other" }

sealed trait CodedReasonForSettingMessageEnum

object CodedReasonForSettingMessageEnum {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[nu.ndw.CodedReasonForSettingMessageEnum]): CodedReasonForSettingMessageEnum = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: CodedReasonForSettingMessageEnum) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
}

case object Situation extends CodedReasonForSettingMessageEnum { override def toString = "situation" }
case object OperatorCreated extends CodedReasonForSettingMessageEnum { override def toString = "operatorCreated" }
case object TrafficManagementValue extends CodedReasonForSettingMessageEnum { override def toString = "trafficManagement" }
case object TravelTimeValue extends CodedReasonForSettingMessageEnum { override def toString = "travelTime" }
case object Campaign extends CodedReasonForSettingMessageEnum { override def toString = "campaign" }
case object Default extends CodedReasonForSettingMessageEnum { override def toString = "default" }

sealed trait ColourEnum

object ColourEnum {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[nu.ndw.ColourEnum]): ColourEnum = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: ColourEnum) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
}

case object Amber extends ColourEnum { override def toString = "amber" }
case object Blue extends ColourEnum { override def toString = "blue" }
case object Green extends ColourEnum { override def toString = "green" }
case object Red extends ColourEnum { override def toString = "red" }
case object White extends ColourEnum { override def toString = "white" }
case object WhiteYellow extends ColourEnum { override def toString = "whiteYellow" }



case class Comment(comment: nu.ndw.MultilingualString,
  commentDateTime: Option[javax.xml.datatype.XMLGregorianCalendar] = None,
  commentType: Option[nu.ndw.CommentTypeEnum] = None,
  commentExtension: Option[nu.ndw._ExtensionType] = None)
      

sealed trait CommentTypeEnum

object CommentTypeEnum {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[nu.ndw.CommentTypeEnum]): CommentTypeEnum = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: CommentTypeEnum) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
}

case object AbnormalLoadMovementNote extends CommentTypeEnum { override def toString = "abnormalLoadMovementNote" }
case object DataProcessingNote extends CommentTypeEnum { override def toString = "dataProcessingNote" }
case object Description extends CommentTypeEnum { override def toString = "description" }
case object InternalNote extends CommentTypeEnum { override def toString = "internalNote" }
case object LocationDescriptor extends CommentTypeEnum { override def toString = "locationDescriptor" }
case object Warning extends CommentTypeEnum { override def toString = "warning" }
case object OtherValue56 extends CommentTypeEnum { override def toString = "other" }

sealed trait ComparisonOperatorEnum

object ComparisonOperatorEnum {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[nu.ndw.ComparisonOperatorEnum]): ComparisonOperatorEnum = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: ComparisonOperatorEnum) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
}

case object EqualTo extends ComparisonOperatorEnum { override def toString = "equalTo" }
case object GreaterThan extends ComparisonOperatorEnum { override def toString = "greaterThan" }
case object GreaterThanOrEqualTo extends ComparisonOperatorEnum { override def toString = "greaterThanOrEqualTo" }
case object LessThan extends ComparisonOperatorEnum { override def toString = "lessThan" }
case object LessThanOrEqualTo extends ComparisonOperatorEnum { override def toString = "lessThanOrEqualTo" }

sealed trait ComplianceOptionEnum

object ComplianceOptionEnum {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[nu.ndw.ComplianceOptionEnum]): ComplianceOptionEnum = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: ComplianceOptionEnum) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
}

case object Advisory extends ComplianceOptionEnum { override def toString = "advisory" }
case object Mandatory extends ComplianceOptionEnum { override def toString = "mandatory" }

sealed trait ComputationMethodEnum

object ComputationMethodEnum {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[nu.ndw.ComputationMethodEnum]): ComputationMethodEnum = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: ComputationMethodEnum) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
}

case object LongNameValue6 extends ComputationMethodEnum { override def toString = "arithmeticAverageOfSamplesBasedOnAFixedNumberOfSamples" }
case object ArithmeticAverageOfSamplesInATimePeriod extends ComputationMethodEnum { override def toString = "arithmeticAverageOfSamplesInATimePeriod" }
case object HarmonicAverageOfSamplesInATimePeriod extends ComputationMethodEnum { override def toString = "harmonicAverageOfSamplesInATimePeriod" }
case object MedianOfSamplesInATimePeriod extends ComputationMethodEnum { override def toString = "medianOfSamplesInATimePeriod" }
case object MovingAverageOfSamples extends ComputationMethodEnum { override def toString = "movingAverageOfSamples" }



case class ConcentrationOfVehiclesValue(dataError: Option[Boolean] = None,
  reasonForDataError: Option[nu.ndw.MultilingualString] = None,
  dataValueExtension: Option[nu.ndw._ExtensionType] = None,
  concentrationOfVehicles: Int,
  concentrationOfVehiclesValueExtension: Option[nu.ndw._ExtensionType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) extends DataValue {
  @JsonIgnore lazy val accuracy = attributes.get("@accuracy") map { _.as[Float]}
  @JsonIgnore lazy val computationalMethod = attributes.get("@computationalMethod") map { _.as[ComputationMethodEnum]}
  @JsonIgnore lazy val numberOfIncompleteInputs = attributes.get("@numberOfIncompleteInputs") map { _.as[Int]}
  @JsonIgnore lazy val numberOfInputValuesUsed = attributes.get("@numberOfInputValuesUsed") map { _.as[Int]}
  @JsonIgnore lazy val smoothingFactor = attributes.get("@smoothingFactor") map { _.as[Float]}
  @JsonIgnore lazy val standardDeviation = attributes.get("@standardDeviation") map { _.as[Float]}
  @JsonIgnore lazy val supplierCalculatedDataQuality = attributes.get("@supplierCalculatedDataQuality") map { _.as[Float]}
}

      


sealed trait Conditionsable extends TrafficElement {
  def situationRecordCreationReference: Option[String]
  def situationRecordCreationTime: javax.xml.datatype.XMLGregorianCalendar
  def situationRecordObservationTime: Option[javax.xml.datatype.XMLGregorianCalendar]
  def situationRecordVersionTime: javax.xml.datatype.XMLGregorianCalendar
  def situationRecordFirstSupplierVersionTime: Option[javax.xml.datatype.XMLGregorianCalendar]
  def confidentialityOverride: Option[nu.ndw.ConfidentialityValueEnum]
  def probabilityOfOccurrence: nu.ndw.ProbabilityOfOccurrenceEnum
  def severity: Option[nu.ndw.SeverityEnum]
  def source: Option[nu.ndw.Source]
  def validity: nu.ndw.Validity
  def impact: Option[nu.ndw.Impact]
  def cause: Option[nu.ndw.Cause]
  def generalPublicComment: Seq[nu.ndw.Comment]
  def nonGeneralPublicComment: Seq[nu.ndw.Comment]
  def urlLink: Seq[nu.ndw.UrlLink]
  def groupOfLocations: nu.ndw.GroupOfLocations
  def management: Option[nu.ndw.Management]
  def situationRecordExtension: Option[nu.ndw._SituationRecordExtensionType]
  def trafficElementExtension: Option[nu.ndw._ExtensionType]
  def drivingConditionType: Option[nu.ndw.DrivingConditionTypeEnum]
  def conditionsExtension: Option[nu.ndw._ExtensionType]
  def id: String
  def version: String
}



case class Conditions(situationRecordCreationReference: Option[String] = None,
  situationRecordCreationTime: javax.xml.datatype.XMLGregorianCalendar,
  situationRecordObservationTime: Option[javax.xml.datatype.XMLGregorianCalendar] = None,
  situationRecordVersionTime: javax.xml.datatype.XMLGregorianCalendar,
  situationRecordFirstSupplierVersionTime: Option[javax.xml.datatype.XMLGregorianCalendar] = None,
  confidentialityOverride: Option[nu.ndw.ConfidentialityValueEnum] = None,
  probabilityOfOccurrence: nu.ndw.ProbabilityOfOccurrenceEnum,
  severity: Option[nu.ndw.SeverityEnum] = None,
  source: Option[nu.ndw.Source] = None,
  validity: nu.ndw.Validity,
  impact: Option[nu.ndw.Impact] = None,
  cause: Option[nu.ndw.Cause] = None,
  generalPublicComment: Seq[nu.ndw.Comment] = Nil,
  nonGeneralPublicComment: Seq[nu.ndw.Comment] = Nil,
  urlLink: Seq[nu.ndw.UrlLink] = Nil,
  groupOfLocations: nu.ndw.GroupOfLocations,
  management: Option[nu.ndw.Management] = None,
  situationRecordExtension: Option[nu.ndw._SituationRecordExtensionType] = None,
  trafficElementExtension: Option[nu.ndw._ExtensionType] = None,
  drivingConditionType: Option[nu.ndw.DrivingConditionTypeEnum] = None,
  conditionsExtension: Option[nu.ndw._ExtensionType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) extends Conditionsable {
  @JsonIgnore lazy val id = attributes("@id").as[String]
  @JsonIgnore lazy val version = attributes("@version").as[String]
}

      

sealed trait ConfidentialityValueEnum

object ConfidentialityValueEnum {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[nu.ndw.ConfidentialityValueEnum]): ConfidentialityValueEnum = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: ConfidentialityValueEnum) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
}

case object InternalUse extends ConfidentialityValueEnum { override def toString = "internalUse" }
case object NoRestriction extends ConfidentialityValueEnum { override def toString = "noRestriction" }
case object RestrictedToAuthorities extends ConfidentialityValueEnum { override def toString = "restrictedToAuthorities" }
case object RestrictedToAuthoritiesAndTrafficOperators extends ConfidentialityValueEnum { override def toString = "restrictedToAuthoritiesAndTrafficOperators" }
case object LongNameValue5 extends ConfidentialityValueEnum { override def toString = "restrictedToAuthoritiesTrafficOperatorsAndPublishers" }
case object RestrictedToAuthoritiesTrafficOperatorsAndVms extends ConfidentialityValueEnum { override def toString = "restrictedToAuthoritiesTrafficOperatorsAndVms" }



case class ConstructionWorks(situationRecordCreationReference: Option[String] = None,
  situationRecordCreationTime: javax.xml.datatype.XMLGregorianCalendar,
  situationRecordObservationTime: Option[javax.xml.datatype.XMLGregorianCalendar] = None,
  situationRecordVersionTime: javax.xml.datatype.XMLGregorianCalendar,
  situationRecordFirstSupplierVersionTime: Option[javax.xml.datatype.XMLGregorianCalendar] = None,
  confidentialityOverride: Option[nu.ndw.ConfidentialityValueEnum] = None,
  probabilityOfOccurrence: nu.ndw.ProbabilityOfOccurrenceEnum,
  severity: Option[nu.ndw.SeverityEnum] = None,
  source: Option[nu.ndw.Source] = None,
  validity: nu.ndw.Validity,
  impact: Option[nu.ndw.Impact] = None,
  cause: Option[nu.ndw.Cause] = None,
  generalPublicComment: Seq[nu.ndw.Comment] = Nil,
  nonGeneralPublicComment: Seq[nu.ndw.Comment] = Nil,
  urlLink: Seq[nu.ndw.UrlLink] = Nil,
  groupOfLocations: nu.ndw.GroupOfLocations,
  management: Option[nu.ndw.Management] = None,
  situationRecordExtension: Option[nu.ndw._SituationRecordExtensionType] = None,
  actionOrigin: Option[nu.ndw.OperatorActionOriginEnum] = None,
  actionPlanIdentifier: Option[String] = None,
  operatorActionStatus: Option[nu.ndw.OperatorActionStatusEnum] = None,
  operatorActionExtension: Option[nu.ndw._ExtensionType] = None,
  roadworksDuration: Option[nu.ndw.RoadworksDurationEnum] = None,
  roadworksScale: Option[nu.ndw.RoadworksScaleEnum] = None,
  underTraffic: Option[Boolean] = None,
  urgentRoadworks: Option[Boolean] = None,
  mobility: Option[nu.ndw.Mobility] = None,
  subjects: Option[nu.ndw.Subjects] = None,
  maintenanceVehicles: Option[nu.ndw.MaintenanceVehicles] = None,
  roadworksExtension: Option[nu.ndw._ExtensionType] = None,
  constructionWorkType: Option[nu.ndw.ConstructionWorkTypeEnum] = None,
  constructionWorksExtension: Option[nu.ndw._ExtensionType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) extends RoadworksType {
  @JsonIgnore lazy val id = attributes("@id").as[String]
  @JsonIgnore lazy val version = attributes("@version").as[String]
}

      

sealed trait ConstructionWorkTypeEnum

object ConstructionWorkTypeEnum {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[nu.ndw.ConstructionWorkTypeEnum]): ConstructionWorkTypeEnum = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: ConstructionWorkTypeEnum) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
}

case object BlastingWork extends ConstructionWorkTypeEnum { override def toString = "blastingWork" }
case object ConstructionWork extends ConstructionWorkTypeEnum { override def toString = "constructionWork" }
case object DemolitionWork extends ConstructionWorkTypeEnum { override def toString = "demolitionWork" }
case object RoadImprovementOrUpgrading extends ConstructionWorkTypeEnum { override def toString = "roadImprovementOrUpgrading" }
case object RoadWideningWork extends ConstructionWorkTypeEnum { override def toString = "roadWideningWork" }


sealed trait Contactable {
  def contactUnknown: Option[Boolean]
  def contactNotDefined: Option[Boolean]
  def validityOfContact: Option[nu.ndw.OverallPeriod]
  def contactExtension: Option[nu.ndw._ExtensionType]
}



case class Contact(contactUnknown: Option[Boolean] = None,
  contactNotDefined: Option[Boolean] = None,
  validityOfContact: Option[nu.ndw.OverallPeriod] = None,
  contactExtension: Option[nu.ndw._ExtensionType] = None) extends Contactable
      



case class ContactByReference(contactUnknown: Option[Boolean] = None,
  contactNotDefined: Option[Boolean] = None,
  validityOfContact: Option[nu.ndw.OverallPeriod] = None,
  contactExtension: Option[nu.ndw._ExtensionType] = None,
  contactReference: nu.ndw._ContactDetailsVersionedReference,
  contactByReferenceExtension: Option[nu.ndw._ExtensionType] = None) extends Contactable
      



case class ContactDetails(contactUnknown: Option[Boolean] = None,
  contactNotDefined: Option[Boolean] = None,
  validityOfContact: Option[nu.ndw.OverallPeriod] = None,
  contactExtension: Option[nu.ndw._ExtensionType] = None,
  contactOrganisationName: Option[nu.ndw.MultilingualString] = None,
  contactPersonName: Option[String] = None,
  contactPersonFirstName: Option[String] = None,
  contactPersonPosition: Option[nu.ndw.MultilingualString] = None,
  contactDetailsLanguage: Seq[String] = Nil,
  contactDetailsAddress: Option[nu.ndw.MultilingualString] = None,
  contactDetailsStreet: Option[String] = None,
  contactDetailsHouseNumber: Seq[String] = Nil,
  contactDetailsPostcode: Option[String] = None,
  contactDetailsCity: Option[nu.ndw.MultilingualString] = None,
  country: Option[nu.ndw.CountryEnum] = None,
  contactDetailsTelephoneNumber: Option[String] = None,
  contactDetailsFax: Option[String] = None,
  contactDetailsEMail: Option[String] = None,
  urlLinkAddress: Option[java.net.URI] = None,
  contactDetailsLogoUrl: Option[java.net.URI] = None,
  available24hours: Option[Boolean] = None,
  contactDetailsResponsibility: Seq[nu.ndw.MultilingualString] = Nil,
  contactDetailsMoreInfo: Seq[nu.ndw.MultilingualString] = Nil,
  publishingAgreement: Option[Boolean] = None,
  contactDetailsOwnership: Option[nu.ndw.OwnershipTypeEnum] = None,
  groupOfLocations: Option[nu.ndw.GroupOfLocations] = None,
  contactDetailsExtension: Option[nu.ndw._ExtensionType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) extends Contactable {
  @JsonIgnore lazy val id = attributes("@id").as[String]
  @JsonIgnore lazy val version = attributes("@version").as[String]
}

      

sealed trait CountryEnum

object CountryEnum {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[nu.ndw.CountryEnum]): CountryEnum = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: CountryEnum) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
}

case object At extends CountryEnum { override def toString = "at" }
case object Be extends CountryEnum { override def toString = "be" }
case object Bg extends CountryEnum { override def toString = "bg" }
case object Ch extends CountryEnum { override def toString = "ch" }
case object Cs extends CountryEnum { override def toString = "cs" }
case object Cy extends CountryEnum { override def toString = "cy" }
case object Cz extends CountryEnum { override def toString = "cz" }
case object De extends CountryEnum { override def toString = "de" }
case object Dk extends CountryEnum { override def toString = "dk" }
case object Ee extends CountryEnum { override def toString = "ee" }
case object Es extends CountryEnum { override def toString = "es" }
case object Fi extends CountryEnum { override def toString = "fi" }
case object Fo extends CountryEnum { override def toString = "fo" }
case object Fr extends CountryEnum { override def toString = "fr" }
case object Gb extends CountryEnum { override def toString = "gb" }
case object Gg extends CountryEnum { override def toString = "gg" }
case object Gi extends CountryEnum { override def toString = "gi" }
case object Gr extends CountryEnum { override def toString = "gr" }
case object Hr extends CountryEnum { override def toString = "hr" }
case object Hu extends CountryEnum { override def toString = "hu" }
case object Ie extends CountryEnum { override def toString = "ie" }
case object Im extends CountryEnum { override def toString = "im" }
case object Is extends CountryEnum { override def toString = "is" }
case object It extends CountryEnum { override def toString = "it" }
case object Je extends CountryEnum { override def toString = "je" }
case object Li extends CountryEnum { override def toString = "li" }
case object Lt extends CountryEnum { override def toString = "lt" }
case object Lu extends CountryEnum { override def toString = "lu" }
case object Lv extends CountryEnum { override def toString = "lv" }
case object Ma extends CountryEnum { override def toString = "ma" }
case object Mc extends CountryEnum { override def toString = "mc" }
case object Mk extends CountryEnum { override def toString = "mk" }
case object Mt extends CountryEnum { override def toString = "mt" }
case object Nl extends CountryEnum { override def toString = "nl" }
case object No extends CountryEnum { override def toString = "no" }
case object Pl extends CountryEnum { override def toString = "pl" }
case object Pt extends CountryEnum { override def toString = "pt" }
case object Ro extends CountryEnum { override def toString = "ro" }
case object Se extends CountryEnum { override def toString = "se" }
case object Si extends CountryEnum { override def toString = "si" }
case object Sk extends CountryEnum { override def toString = "sk" }
case object Sm extends CountryEnum { override def toString = "sm" }
case object Tr extends CountryEnum { override def toString = "tr" }
case object Va extends CountryEnum { override def toString = "va" }
case object OtherValue45 extends CountryEnum { override def toString = "other" }

sealed trait CurrencyEnum

object CurrencyEnum {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[nu.ndw.CurrencyEnum]): CurrencyEnum = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: CurrencyEnum) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
}

case object Eur extends CurrencyEnum { override def toString = "eur" }
case object AllTypeValue extends CurrencyEnum { override def toString = "all" }
case object Amd extends CurrencyEnum { override def toString = "amd" }
case object Azn extends CurrencyEnum { override def toString = "azn" }
case object Bam extends CurrencyEnum { override def toString = "bam" }
case object Bgn extends CurrencyEnum { override def toString = "bgn" }
case object Byr extends CurrencyEnum { override def toString = "byr" }
case object Chf extends CurrencyEnum { override def toString = "chf" }
case object Czk extends CurrencyEnum { override def toString = "czk" }
case object Dkk extends CurrencyEnum { override def toString = "dkk" }
case object Gbp extends CurrencyEnum { override def toString = "gbp" }
case object Gel extends CurrencyEnum { override def toString = "gel" }
case object Hrk extends CurrencyEnum { override def toString = "hrk" }
case object Huf extends CurrencyEnum { override def toString = "huf" }
case object Isk extends CurrencyEnum { override def toString = "isk" }
case object Ltl extends CurrencyEnum { override def toString = "ltl" }
case object Mdl extends CurrencyEnum { override def toString = "mdl" }
case object Mkd extends CurrencyEnum { override def toString = "mkd" }
case object Nok extends CurrencyEnum { override def toString = "nok" }
case object Pln extends CurrencyEnum { override def toString = "pln" }
case object Ron extends CurrencyEnum { override def toString = "ron" }
case object Rsd extends CurrencyEnum { override def toString = "rsd" }
case object Rub extends CurrencyEnum { override def toString = "rub" }
case object Sek extends CurrencyEnum { override def toString = "sek" }
case object Try extends CurrencyEnum { override def toString = "try" }
case object Uah extends CurrencyEnum { override def toString = "uah" }
case object Usd extends CurrencyEnum { override def toString = "usd" }
case object OtherValue44 extends CurrencyEnum { override def toString = "other" }



case class D2LogicalModel(exchange: nu.ndw.Exchange,
  payloadPublication: Option[nu.ndw.PayloadPublication] = None,
  d2LogicalModelExtension: Option[nu.ndw._ExtensionType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  @JsonIgnore lazy val modelBaseVersion = attributes("@modelBaseVersion").as[String]
}

      

sealed trait DangerousGoodsRegulationsEnum

object DangerousGoodsRegulationsEnum {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[nu.ndw.DangerousGoodsRegulationsEnum]): DangerousGoodsRegulationsEnum = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: DangerousGoodsRegulationsEnum) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
}

case object Adr extends DangerousGoodsRegulationsEnum { override def toString = "adr" }
case object IataIcao extends DangerousGoodsRegulationsEnum { override def toString = "iataIcao" }
case object ImoImdg extends DangerousGoodsRegulationsEnum { override def toString = "imoImdg" }
case object RailroadDangerousGoodsBook extends DangerousGoodsRegulationsEnum { override def toString = "railroadDangerousGoodsBook" }


sealed trait DataValue {
  def dataError: Option[Boolean]
  def reasonForDataError: Option[nu.ndw.MultilingualString]
  def dataValueExtension: Option[nu.ndw._ExtensionType]
  def accuracy: Option[Float]
  def computationalMethod: Option[nu.ndw.ComputationMethodEnum]
  def numberOfIncompleteInputs: Option[Int]
  def numberOfInputValuesUsed: Option[Int]
  def smoothingFactor: Option[Float]
  def standardDeviation: Option[Float]
  def supplierCalculatedDataQuality: Option[Float]
}



case class DateTimeValue(dataError: Option[Boolean] = None,
  reasonForDataError: Option[nu.ndw.MultilingualString] = None,
  dataValueExtension: Option[nu.ndw._ExtensionType] = None,
  dateTime: javax.xml.datatype.XMLGregorianCalendar,
  dateTimeValueExtension: Option[nu.ndw._ExtensionType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) extends DataValue {
  @JsonIgnore lazy val accuracy = attributes.get("@accuracy") map { _.as[Float]}
  @JsonIgnore lazy val computationalMethod = attributes.get("@computationalMethod") map { _.as[ComputationMethodEnum]}
  @JsonIgnore lazy val numberOfIncompleteInputs = attributes.get("@numberOfIncompleteInputs") map { _.as[Int]}
  @JsonIgnore lazy val numberOfInputValuesUsed = attributes.get("@numberOfInputValuesUsed") map { _.as[Int]}
  @JsonIgnore lazy val smoothingFactor = attributes.get("@smoothingFactor") map { _.as[Float]}
  @JsonIgnore lazy val standardDeviation = attributes.get("@standardDeviation") map { _.as[Float]}
  @JsonIgnore lazy val supplierCalculatedDataQuality = attributes.get("@supplierCalculatedDataQuality") map { _.as[Float]}
}

      

sealed trait DayEnum

object DayEnum {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[nu.ndw.DayEnum]): DayEnum = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: DayEnum) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
}

case object Monday extends DayEnum { override def toString = "monday" }
case object Tuesday extends DayEnum { override def toString = "tuesday" }
case object Wednesday extends DayEnum { override def toString = "wednesday" }
case object Thursday extends DayEnum { override def toString = "thursday" }
case object Friday extends DayEnum { override def toString = "friday" }
case object Saturday extends DayEnum { override def toString = "saturday" }
case object Sunday extends DayEnum { override def toString = "sunday" }



case class DayWeekMonth(applicableDay: Seq[nu.ndw.DayEnum] = Nil,
  applicableWeek: Seq[nu.ndw.WeekOfMonthEnum] = Nil,
  applicableMonth: Seq[nu.ndw.MonthOfYearEnum] = Nil,
  dayWeekMonthExtension: Option[nu.ndw._ExtensionType] = None)
      



case class DedicatedAccess(dedicatedAccess: nu.ndw._ParkingAccessReference,
  distanceFromParkingSpace: Option[Int] = None,
  dedicatedAccessExtension: Option[nu.ndw._ExtensionType] = None)
      

sealed trait DelayBandEnum

object DelayBandEnum {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[nu.ndw.DelayBandEnum]): DelayBandEnum = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: DelayBandEnum) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
}

case object Negligible extends DelayBandEnum { override def toString = "negligible" }
case object UpToTenMinutes extends DelayBandEnum { override def toString = "upToTenMinutes" }
case object BetweenTenMinutesAndThirtyMinutes extends DelayBandEnum { override def toString = "betweenTenMinutesAndThirtyMinutes" }
case object BetweenThirtyMinutesAndOneHour extends DelayBandEnum { override def toString = "betweenThirtyMinutesAndOneHour" }
case object BetweenOneHourAndThreeHours extends DelayBandEnum { override def toString = "betweenOneHourAndThreeHours" }
case object BetweenThreeHoursAndSixHours extends DelayBandEnum { override def toString = "betweenThreeHoursAndSixHours" }
case object LongerThanSixHours extends DelayBandEnum { override def toString = "longerThanSixHours" }



case class Delays(delayBand: Option[nu.ndw.DelayBandEnum] = None,
  delaysType: Option[nu.ndw.DelaysTypeEnum] = None,
  delayTimeValue: Option[Float] = None,
  delaysExtension: Option[nu.ndw._ExtensionType] = None)
      

sealed trait DelaysTypeEnum

object DelaysTypeEnum {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[nu.ndw.DelaysTypeEnum]): DelaysTypeEnum = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: DelaysTypeEnum) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
}

case object DelaysValue extends DelaysTypeEnum { override def toString = "delays" }
case object DelaysOfUncertainDuration extends DelaysTypeEnum { override def toString = "delaysOfUncertainDuration" }
case object LongDelays extends DelaysTypeEnum { override def toString = "longDelays" }
case object VeryLongDelays extends DelaysTypeEnum { override def toString = "veryLongDelays" }

sealed trait DenyReasonEnum

object DenyReasonEnum {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[nu.ndw.DenyReasonEnum]): DenyReasonEnum = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: DenyReasonEnum) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
}

case object UnknownReason extends DenyReasonEnum { override def toString = "unknownReason" }
case object WrongCatalogue extends DenyReasonEnum { override def toString = "wrongCatalogue" }
case object WrongFilter extends DenyReasonEnum { override def toString = "wrongFilter" }
case object WrongOrder extends DenyReasonEnum { override def toString = "wrongOrder" }
case object WrongPartner extends DenyReasonEnum { override def toString = "wrongPartner" }


sealed trait Destination {
  def destinationExtension: Option[nu.ndw._ExtensionType]
}



case class Dimension(dimensionLength: Option[Float] = None,
  dimensionWidth: Option[Float] = None,
  dimensionHeight: Option[Float] = None,
  dimensionUsableArea: Option[Int] = None,
  dimensionExtension: Option[nu.ndw._ExtensionType] = None)
      



case class DirectionBearingValue(dataError: Option[Boolean] = None,
  reasonForDataError: Option[nu.ndw.MultilingualString] = None,
  dataValueExtension: Option[nu.ndw._ExtensionType] = None,
  directionBearing: Int,
  directionBearingValueExtension: Option[nu.ndw._ExtensionType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) extends DataValue {
  @JsonIgnore lazy val accuracy = attributes.get("@accuracy") map { _.as[Float]}
  @JsonIgnore lazy val computationalMethod = attributes.get("@computationalMethod") map { _.as[ComputationMethodEnum]}
  @JsonIgnore lazy val numberOfIncompleteInputs = attributes.get("@numberOfIncompleteInputs") map { _.as[Int]}
  @JsonIgnore lazy val numberOfInputValuesUsed = attributes.get("@numberOfInputValuesUsed") map { _.as[Int]}
  @JsonIgnore lazy val smoothingFactor = attributes.get("@smoothingFactor") map { _.as[Float]}
  @JsonIgnore lazy val standardDeviation = attributes.get("@standardDeviation") map { _.as[Float]}
  @JsonIgnore lazy val supplierCalculatedDataQuality = attributes.get("@supplierCalculatedDataQuality") map { _.as[Float]}
}

      

sealed trait DirectionCompassEnum

object DirectionCompassEnum {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[nu.ndw.DirectionCompassEnum]): DirectionCompassEnum = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: DirectionCompassEnum) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
}

case object East extends DirectionCompassEnum { override def toString = "east" }
case object EastNorthEast extends DirectionCompassEnum { override def toString = "eastNorthEast" }
case object EastSouthEast extends DirectionCompassEnum { override def toString = "eastSouthEast" }
case object North extends DirectionCompassEnum { override def toString = "north" }
case object NorthEast extends DirectionCompassEnum { override def toString = "northEast" }
case object NorthNorthEast extends DirectionCompassEnum { override def toString = "northNorthEast" }
case object NorthNorthWest extends DirectionCompassEnum { override def toString = "northNorthWest" }
case object NorthWest extends DirectionCompassEnum { override def toString = "northWest" }
case object South extends DirectionCompassEnum { override def toString = "south" }
case object SouthEast extends DirectionCompassEnum { override def toString = "southEast" }
case object SouthSouthEast extends DirectionCompassEnum { override def toString = "southSouthEast" }
case object SouthSouthWest extends DirectionCompassEnum { override def toString = "southSouthWest" }
case object SouthWest extends DirectionCompassEnum { override def toString = "southWest" }
case object West extends DirectionCompassEnum { override def toString = "west" }
case object WestNorthWest extends DirectionCompassEnum { override def toString = "westNorthWest" }
case object WestSouthWest extends DirectionCompassEnum { override def toString = "westSouthWest" }



case class DirectionCompassValue(dataError: Option[Boolean] = None,
  reasonForDataError: Option[nu.ndw.MultilingualString] = None,
  dataValueExtension: Option[nu.ndw._ExtensionType] = None,
  directionCompass: nu.ndw.DirectionCompassEnum,
  directionCompassValueExtension: Option[nu.ndw._ExtensionType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) extends DataValue {
  @JsonIgnore lazy val accuracy = attributes.get("@accuracy") map { _.as[Float]}
  @JsonIgnore lazy val computationalMethod = attributes.get("@computationalMethod") map { _.as[ComputationMethodEnum]}
  @JsonIgnore lazy val numberOfIncompleteInputs = attributes.get("@numberOfIncompleteInputs") map { _.as[Int]}
  @JsonIgnore lazy val numberOfInputValuesUsed = attributes.get("@numberOfInputValuesUsed") map { _.as[Int]}
  @JsonIgnore lazy val smoothingFactor = attributes.get("@smoothingFactor") map { _.as[Float]}
  @JsonIgnore lazy val standardDeviation = attributes.get("@standardDeviation") map { _.as[Float]}
  @JsonIgnore lazy val supplierCalculatedDataQuality = attributes.get("@supplierCalculatedDataQuality") map { _.as[Float]}
}

      

sealed trait DirectionEnum

object DirectionEnum {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[nu.ndw.DirectionEnum]): DirectionEnum = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: DirectionEnum) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
}

case object AllDirections extends DirectionEnum { override def toString = "allDirections" }
case object BothWays extends DirectionEnum { override def toString = "bothWays" }
case object Clockwise extends DirectionEnum { override def toString = "clockwise" }
case object Anticlockwise extends DirectionEnum { override def toString = "anticlockwise" }
case object InnerRing extends DirectionEnum { override def toString = "innerRing" }
case object OuterRing extends DirectionEnum { override def toString = "outerRing" }
case object NorthBound extends DirectionEnum { override def toString = "northBound" }
case object NorthEastBound extends DirectionEnum { override def toString = "northEastBound" }
case object EastBound extends DirectionEnum { override def toString = "eastBound" }
case object SouthEastBound extends DirectionEnum { override def toString = "southEastBound" }
case object SouthBound extends DirectionEnum { override def toString = "southBound" }
case object SouthWestBound extends DirectionEnum { override def toString = "southWestBound" }
case object WestBound extends DirectionEnum { override def toString = "westBound" }
case object NorthWestBound extends DirectionEnum { override def toString = "northWestBound" }
case object InboundTowardsTown extends DirectionEnum { override def toString = "inboundTowardsTown" }
case object OutboundFromTown extends DirectionEnum { override def toString = "outboundFromTown" }
case object UnknownValue23 extends DirectionEnum { override def toString = "unknown" }
case object OppositeValue extends DirectionEnum { override def toString = "opposite" }
case object OtherValue43 extends DirectionEnum { override def toString = "other" }


sealed trait DistanceAlongLinearElement {
  def distanceAlongLinearElementExtension: Option[nu.ndw._ExtensionType]
}



case class DistanceFromLinearElementReferent(distanceAlongLinearElementExtension: Option[nu.ndw._ExtensionType] = None,
  distanceAlong: Float,
  fromReferent: nu.ndw.Referent,
  towardsReferent: Option[nu.ndw.Referent] = None,
  distanceFromLinearElementReferentExtension: Option[nu.ndw._ExtensionType] = None) extends DistanceAlongLinearElement
      



case class DistanceFromLinearElementStart(distanceAlongLinearElementExtension: Option[nu.ndw._ExtensionType] = None,
  distanceAlong: Float,
  distanceFromLinearElementStartExtension: Option[nu.ndw._ExtensionType] = None) extends DistanceAlongLinearElement
      



case class DisturbanceActivity(situationRecordCreationReference: Option[String] = None,
  situationRecordCreationTime: javax.xml.datatype.XMLGregorianCalendar,
  situationRecordObservationTime: Option[javax.xml.datatype.XMLGregorianCalendar] = None,
  situationRecordVersionTime: javax.xml.datatype.XMLGregorianCalendar,
  situationRecordFirstSupplierVersionTime: Option[javax.xml.datatype.XMLGregorianCalendar] = None,
  confidentialityOverride: Option[nu.ndw.ConfidentialityValueEnum] = None,
  probabilityOfOccurrence: nu.ndw.ProbabilityOfOccurrenceEnum,
  severity: Option[nu.ndw.SeverityEnum] = None,
  source: Option[nu.ndw.Source] = None,
  validity: nu.ndw.Validity,
  impact: Option[nu.ndw.Impact] = None,
  cause: Option[nu.ndw.Cause] = None,
  generalPublicComment: Seq[nu.ndw.Comment] = Nil,
  nonGeneralPublicComment: Seq[nu.ndw.Comment] = Nil,
  urlLink: Seq[nu.ndw.UrlLink] = Nil,
  groupOfLocations: nu.ndw.GroupOfLocations,
  management: Option[nu.ndw.Management] = None,
  situationRecordExtension: Option[nu.ndw._SituationRecordExtensionType] = None,
  trafficElementExtension: Option[nu.ndw._ExtensionType] = None,
  mobilityOfActivity: Option[nu.ndw.Mobility] = None,
  activityExtension: Option[nu.ndw._ExtensionType] = None,
  disturbanceActivityType: nu.ndw.DisturbanceActivityTypeEnum,
  disturbanceActivityExtension: Option[nu.ndw._ExtensionType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) extends Activity {
  @JsonIgnore lazy val id = attributes("@id").as[String]
  @JsonIgnore lazy val version = attributes("@version").as[String]
}

      

sealed trait DisturbanceActivityTypeEnum

object DisturbanceActivityTypeEnum {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[nu.ndw.DisturbanceActivityTypeEnum]): DisturbanceActivityTypeEnum = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: DisturbanceActivityTypeEnum) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
}

case object AirRaid extends DisturbanceActivityTypeEnum { override def toString = "airRaid" }
case object AltercationOfVehicleOccupants extends DisturbanceActivityTypeEnum { override def toString = "altercationOfVehicleOccupants" }
case object Assault extends DisturbanceActivityTypeEnum { override def toString = "assault" }
case object AssetDestruction extends DisturbanceActivityTypeEnum { override def toString = "assetDestruction" }
case object Attack extends DisturbanceActivityTypeEnum { override def toString = "attack" }
case object AttackOnVehicle extends DisturbanceActivityTypeEnum { override def toString = "attackOnVehicle" }
case object BlockadeOrBarrier extends DisturbanceActivityTypeEnum { override def toString = "blockadeOrBarrier" }
case object BombAlert extends DisturbanceActivityTypeEnum { override def toString = "bombAlert" }
case object Crowd extends DisturbanceActivityTypeEnum { override def toString = "crowd" }
case object Demonstration extends DisturbanceActivityTypeEnum { override def toString = "demonstration" }
case object Evacuation extends DisturbanceActivityTypeEnum { override def toString = "evacuation" }
case object FilterBlockade extends DisturbanceActivityTypeEnum { override def toString = "filterBlockade" }
case object GoSlowOperation extends DisturbanceActivityTypeEnum { override def toString = "goSlowOperation" }
case object GunfireOnRoadway extends DisturbanceActivityTypeEnum { override def toString = "gunfireOnRoadway" }
case object IllVehicleOccupants extends DisturbanceActivityTypeEnum { override def toString = "illVehicleOccupants" }
case object March extends DisturbanceActivityTypeEnum { override def toString = "march" }
case object PublicDisturbance extends DisturbanceActivityTypeEnum { override def toString = "publicDisturbance" }
case object RadioactiveLeakAlertValue extends DisturbanceActivityTypeEnum { override def toString = "radioactiveLeakAlert" }
case object Riot extends DisturbanceActivityTypeEnum { override def toString = "riot" }
case object Sabotage extends DisturbanceActivityTypeEnum { override def toString = "sabotage" }
case object SecurityAlert extends DisturbanceActivityTypeEnum { override def toString = "securityAlert" }
case object SecurityIncidentValue extends DisturbanceActivityTypeEnum { override def toString = "securityIncident" }
case object SightseersObstructingAccess extends DisturbanceActivityTypeEnum { override def toString = "sightseersObstructingAccess" }
case object Strike extends DisturbanceActivityTypeEnum { override def toString = "strike" }
case object TerroristIncident extends DisturbanceActivityTypeEnum { override def toString = "terroristIncident" }
case object Theft extends DisturbanceActivityTypeEnum { override def toString = "theft" }
case object ToxicCloudAlertValue extends DisturbanceActivityTypeEnum { override def toString = "toxicCloudAlert" }
case object UnspecifiedAlert extends DisturbanceActivityTypeEnum { override def toString = "unspecifiedAlert" }
case object OtherValue57 extends DisturbanceActivityTypeEnum { override def toString = "other" }

sealed trait DrivingConditionTypeEnum

object DrivingConditionTypeEnum {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[nu.ndw.DrivingConditionTypeEnum]): DrivingConditionTypeEnum = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: DrivingConditionTypeEnum) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
}

case object ImpossibleValue extends DrivingConditionTypeEnum { override def toString = "impossible" }
case object Hazardous extends DrivingConditionTypeEnum { override def toString = "hazardous" }
case object Normal extends DrivingConditionTypeEnum { override def toString = "normal" }
case object PassableWithCare extends DrivingConditionTypeEnum { override def toString = "passableWithCare" }
case object UnknownValue22 extends DrivingConditionTypeEnum { override def toString = "unknown" }
case object VeryHazardous extends DrivingConditionTypeEnum { override def toString = "veryHazardous" }
case object WinterConditions extends DrivingConditionTypeEnum { override def toString = "winterConditions" }
case object OtherValue42 extends DrivingConditionTypeEnum { override def toString = "other" }



case class DurationValue(dataError: Option[Boolean] = None,
  reasonForDataError: Option[nu.ndw.MultilingualString] = None,
  dataValueExtension: Option[nu.ndw._ExtensionType] = None,
  duration: Float,
  durationValueExtension: Option[nu.ndw._ExtensionType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) extends DataValue {
  @JsonIgnore lazy val accuracy = attributes.get("@accuracy") map { _.as[Float]}
  @JsonIgnore lazy val computationalMethod = attributes.get("@computationalMethod") map { _.as[ComputationMethodEnum]}
  @JsonIgnore lazy val numberOfIncompleteInputs = attributes.get("@numberOfIncompleteInputs") map { _.as[Int]}
  @JsonIgnore lazy val numberOfInputValuesUsed = attributes.get("@numberOfInputValuesUsed") map { _.as[Int]}
  @JsonIgnore lazy val smoothingFactor = attributes.get("@smoothingFactor") map { _.as[Float]}
  @JsonIgnore lazy val standardDeviation = attributes.get("@standardDeviation") map { _.as[Float]}
  @JsonIgnore lazy val supplierCalculatedDataQuality = attributes.get("@supplierCalculatedDataQuality") map { _.as[Float]}
}

      



case class ElaboratedData(forecast: Option[Boolean] = None,
  source: Option[nu.ndw.Source] = None,
  validity: Option[nu.ndw.Validity] = None,
  elaboratedDataFault: Seq[nu.ndw.ElaboratedDataFault] = Nil,
  basicData: Option[nu.ndw.BasicData] = None,
  elaboratedDataExtension: Option[nu.ndw._ExtensionType] = None)
      



case class ElaboratedDataFault(faultIdentifier: Option[String] = None,
  faultDescription: Option[String] = None,
  faultCreationTime: Option[javax.xml.datatype.XMLGregorianCalendar] = None,
  faultLastUpdateTime: javax.xml.datatype.XMLGregorianCalendar,
  faultSeverity: Option[nu.ndw.FaultSeverityEnum] = None,
  faultExtension: Option[nu.ndw._ExtensionType] = None,
  elaboratedDataFault: nu.ndw.ElaboratedDataFaultEnum,
  elaboratedDataFaultExtension: Option[nu.ndw._ExtensionType] = None) extends Faultable
      

sealed trait ElaboratedDataFaultEnum

object ElaboratedDataFaultEnum {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[nu.ndw.ElaboratedDataFaultEnum]): ElaboratedDataFaultEnum = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: ElaboratedDataFaultEnum) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
}

case object IntermittentDataValues extends ElaboratedDataFaultEnum { override def toString = "intermittentDataValues" }
case object NoDataValuesAvailable extends ElaboratedDataFaultEnum { override def toString = "noDataValuesAvailable" }
case object SpuriousUnreliableDataValues extends ElaboratedDataFaultEnum { override def toString = "spuriousUnreliableDataValues" }
case object UnspecifiedOrUnknownFault extends ElaboratedDataFaultEnum { override def toString = "unspecifiedOrUnknownFault" }
case object OtherValue41 extends ElaboratedDataFaultEnum { override def toString = "other" }



case class ElaboratedDataPublication(feedDescription: Option[nu.ndw.MultilingualString] = None,
  feedType: Option[String] = None,
  publicationTime: javax.xml.datatype.XMLGregorianCalendar,
  publicationCreator: nu.ndw.InternationalIdentifier,
  payloadPublicationExtension: Option[nu.ndw._ExtensionType] = None,
  forecastDefault: Option[Boolean] = None,
  periodDefault: Option[Float] = None,
  timeDefault: Option[javax.xml.datatype.XMLGregorianCalendar] = None,
  headerInformation: nu.ndw.HeaderInformation,
  referenceSettings: Option[nu.ndw.ReferenceSettings] = None,
  elaboratedData: Seq[nu.ndw.ElaboratedData] = Nil,
  elaboratedDataPublicationExtension: Option[nu.ndw._ExtensionType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) extends PayloadPublication {
  @JsonIgnore lazy val lang = attributes("@lang").as[String]
}

      



case class ElectricCharging(chargingStationUsageType: Seq[nu.ndw.ChargingStationUsageTypeEnum] = Nil,
  chargingStationModelType: Option[nu.ndw.MultilingualString] = None,
  maximumCurrent: Option[Float] = None,
  voltage: Seq[Float] = Nil,
  chargingStationConnectorType: Seq[nu.ndw.MultilingualString] = Nil,
  numberOfChargingPoints: Option[Int] = None,
  electricChargingExtension: Option[nu.ndw._ExtensionType] = None)
      



case class EnvironmentalObstruction(situationRecordCreationReference: Option[String] = None,
  situationRecordCreationTime: javax.xml.datatype.XMLGregorianCalendar,
  situationRecordObservationTime: Option[javax.xml.datatype.XMLGregorianCalendar] = None,
  situationRecordVersionTime: javax.xml.datatype.XMLGregorianCalendar,
  situationRecordFirstSupplierVersionTime: Option[javax.xml.datatype.XMLGregorianCalendar] = None,
  confidentialityOverride: Option[nu.ndw.ConfidentialityValueEnum] = None,
  probabilityOfOccurrence: nu.ndw.ProbabilityOfOccurrenceEnum,
  severity: Option[nu.ndw.SeverityEnum] = None,
  source: Option[nu.ndw.Source] = None,
  validity: nu.ndw.Validity,
  impact: Option[nu.ndw.Impact] = None,
  cause: Option[nu.ndw.Cause] = None,
  generalPublicComment: Seq[nu.ndw.Comment] = Nil,
  nonGeneralPublicComment: Seq[nu.ndw.Comment] = Nil,
  urlLink: Seq[nu.ndw.UrlLink] = Nil,
  groupOfLocations: nu.ndw.GroupOfLocations,
  management: Option[nu.ndw.Management] = None,
  situationRecordExtension: Option[nu.ndw._SituationRecordExtensionType] = None,
  trafficElementExtension: Option[nu.ndw._ExtensionType] = None,
  numberOfObstructions: Option[Int] = None,
  mobilityOfObstruction: Option[nu.ndw.Mobility] = None,
  obstructionExtension: Option[nu.ndw._ExtensionType] = None,
  depth: Option[Float] = None,
  environmentalObstructionType: nu.ndw.EnvironmentalObstructionTypeEnum,
  environmentalObstructionExtension: Option[nu.ndw._ExtensionType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) extends ObstructionType {
  @JsonIgnore lazy val id = attributes("@id").as[String]
  @JsonIgnore lazy val version = attributes("@version").as[String]
}

      

sealed trait EnvironmentalObstructionTypeEnum

object EnvironmentalObstructionTypeEnum {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[nu.ndw.EnvironmentalObstructionTypeEnum]): EnvironmentalObstructionTypeEnum = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: EnvironmentalObstructionTypeEnum) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
}

case object Avalanches extends EnvironmentalObstructionTypeEnum { override def toString = "avalanches" }
case object EarthquakeDamage extends EnvironmentalObstructionTypeEnum { override def toString = "earthquakeDamage" }
case object FallenTrees extends EnvironmentalObstructionTypeEnum { override def toString = "fallenTrees" }
case object FallingIce extends EnvironmentalObstructionTypeEnum { override def toString = "fallingIce" }
case object FallingLightIceOrSnow extends EnvironmentalObstructionTypeEnum { override def toString = "fallingLightIceOrSnow" }
case object FlashFloods extends EnvironmentalObstructionTypeEnum { override def toString = "flashFloods" }
case object Flooding extends EnvironmentalObstructionTypeEnum { override def toString = "flooding" }
case object ForestFire extends EnvironmentalObstructionTypeEnum { override def toString = "forestFire" }
case object GrassFire extends EnvironmentalObstructionTypeEnum { override def toString = "grassFire" }
case object Landslips extends EnvironmentalObstructionTypeEnum { override def toString = "landslips" }
case object MudSlide extends EnvironmentalObstructionTypeEnum { override def toString = "mudSlide" }
case object SewerOverflow extends EnvironmentalObstructionTypeEnum { override def toString = "sewerOverflow" }
case object Rockfalls extends EnvironmentalObstructionTypeEnum { override def toString = "rockfalls" }
case object SeriousFire extends EnvironmentalObstructionTypeEnum { override def toString = "seriousFire" }
case object SmokeOrFumes extends EnvironmentalObstructionTypeEnum { override def toString = "smokeOrFumes" }
case object StormDamage extends EnvironmentalObstructionTypeEnum { override def toString = "stormDamage" }
case object Subsidence extends EnvironmentalObstructionTypeEnum { override def toString = "subsidence" }
case object OtherValue40 extends EnvironmentalObstructionTypeEnum { override def toString = "other" }



case class Equipment(equipmentOrServiceFacilityIdentifier: Seq[String] = Nil,
  availability: Option[nu.ndw.AvailabilityEnum] = None,
  numberOfEquipmentOrServiceFacility: Option[Int] = None,
  additionalDescription: Option[nu.ndw.MultilingualString] = None,
  otherEquipmentOrServiceFacility: Option[nu.ndw.MultilingualString] = None,
  accessibility: Seq[nu.ndw.AccessibilityEnum] = Nil,
  nameOrBrand: Option[nu.ndw.MultilingualString] = None,
  comment: Option[nu.ndw.MultilingualString] = None,
  photoUrl: Option[java.net.URI] = None,
  applicableForUser: Seq[nu.ndw.UserTypeEnum] = Nil,
  availabilityAndOpeningTimes: Option[nu.ndw.OpeningTimes] = None,
  tariffsAndPayment: Option[nu.ndw.TariffsAndPayment] = None,
  groupOfLocations: Option[nu.ndw.GroupOfLocations] = None,
  applicableForVehicles: Seq[nu.ndw.VehicleCharacteristics] = Nil,
  parkingEquipmentOrServiceFacilityExtension: Option[nu.ndw._ExtensionType] = None,
  equipmentType: nu.ndw.EquipmentTypeEnum,
  electricCharging: Option[nu.ndw.ElectricCharging] = None,
  equipmentExtension: Option[nu.ndw._ExtensionType] = None) extends ParkingEquipmentOrServiceFacility
      



case class EquipmentOrSystemFault(situationRecordCreationReference: Option[String] = None,
  situationRecordCreationTime: javax.xml.datatype.XMLGregorianCalendar,
  situationRecordObservationTime: Option[javax.xml.datatype.XMLGregorianCalendar] = None,
  situationRecordVersionTime: javax.xml.datatype.XMLGregorianCalendar,
  situationRecordFirstSupplierVersionTime: Option[javax.xml.datatype.XMLGregorianCalendar] = None,
  confidentialityOverride: Option[nu.ndw.ConfidentialityValueEnum] = None,
  probabilityOfOccurrence: nu.ndw.ProbabilityOfOccurrenceEnum,
  severity: Option[nu.ndw.SeverityEnum] = None,
  source: Option[nu.ndw.Source] = None,
  validity: nu.ndw.Validity,
  impact: Option[nu.ndw.Impact] = None,
  cause: Option[nu.ndw.Cause] = None,
  generalPublicComment: Seq[nu.ndw.Comment] = Nil,
  nonGeneralPublicComment: Seq[nu.ndw.Comment] = Nil,
  urlLink: Seq[nu.ndw.UrlLink] = Nil,
  groupOfLocations: nu.ndw.GroupOfLocations,
  management: Option[nu.ndw.Management] = None,
  situationRecordExtension: Option[nu.ndw._SituationRecordExtensionType] = None,
  trafficElementExtension: Option[nu.ndw._ExtensionType] = None,
  equipmentOrSystemFaultType: nu.ndw.EquipmentOrSystemFaultTypeEnum,
  faultyEquipmentOrSystemType: nu.ndw.EquipmentOrSystemTypeEnum,
  equipmentOrSystemFaultExtension: Option[nu.ndw._ExtensionType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) extends TrafficElement {
  @JsonIgnore lazy val id = attributes("@id").as[String]
  @JsonIgnore lazy val version = attributes("@version").as[String]
}

      

sealed trait EquipmentOrSystemFaultTypeEnum

object EquipmentOrSystemFaultTypeEnum {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[nu.ndw.EquipmentOrSystemFaultTypeEnum]): EquipmentOrSystemFaultTypeEnum = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: EquipmentOrSystemFaultTypeEnum) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
}

case object NotWorking extends EquipmentOrSystemFaultTypeEnum { override def toString = "notWorking" }
case object OutOfServiceValue extends EquipmentOrSystemFaultTypeEnum { override def toString = "outOfService" }
case object WorkingIncorrectly extends EquipmentOrSystemFaultTypeEnum { override def toString = "workingIncorrectly" }
case object WorkingIntermittently extends EquipmentOrSystemFaultTypeEnum { override def toString = "workingIntermittently" }

sealed trait EquipmentOrSystemTypeEnum

object EquipmentOrSystemTypeEnum {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[nu.ndw.EquipmentOrSystemTypeEnum]): EquipmentOrSystemTypeEnum = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: EquipmentOrSystemTypeEnum) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
}

case object AnprCameras extends EquipmentOrSystemTypeEnum { override def toString = "anprCameras" }
case object AutomatedTollSystem extends EquipmentOrSystemTypeEnum { override def toString = "automatedTollSystem" }
case object CctvCameras extends EquipmentOrSystemTypeEnum { override def toString = "cctvCameras" }
case object EmergencyRoadsideTelephones extends EquipmentOrSystemTypeEnum { override def toString = "emergencyRoadsideTelephones" }
case object GalleryLights extends EquipmentOrSystemTypeEnum { override def toString = "galleryLights" }
case object LaneControlSigns extends EquipmentOrSystemTypeEnum { override def toString = "laneControlSigns" }
case object LevelCrossing extends EquipmentOrSystemTypeEnum { override def toString = "levelCrossing" }
case object MatrixSigns extends EquipmentOrSystemTypeEnum { override def toString = "matrixSigns" }
case object RampControls extends EquipmentOrSystemTypeEnum { override def toString = "rampControls" }
case object RoadsideCommunicationsSystem extends EquipmentOrSystemTypeEnum { override def toString = "roadsideCommunicationsSystem" }
case object RoadsidePowerSystem extends EquipmentOrSystemTypeEnum { override def toString = "roadsidePowerSystem" }
case object SpeedControlSigns extends EquipmentOrSystemTypeEnum { override def toString = "speedControlSigns" }
case object StreetLighting extends EquipmentOrSystemTypeEnum { override def toString = "streetLighting" }
case object TemporaryTrafficLights extends EquipmentOrSystemTypeEnum { override def toString = "temporaryTrafficLights" }
case object TollGates extends EquipmentOrSystemTypeEnum { override def toString = "tollGates" }
case object TrafficLightSets extends EquipmentOrSystemTypeEnum { override def toString = "trafficLightSets" }
case object TrafficSignals extends EquipmentOrSystemTypeEnum { override def toString = "trafficSignals" }
case object TunnelLights extends EquipmentOrSystemTypeEnum { override def toString = "tunnelLights" }
case object TunnelVentilation extends EquipmentOrSystemTypeEnum { override def toString = "tunnelVentilation" }
case object VariableMessageSigns extends EquipmentOrSystemTypeEnum { override def toString = "variableMessageSigns" }
case object OtherValue39 extends EquipmentOrSystemTypeEnum { override def toString = "other" }

sealed trait EquipmentTypeEnum

object EquipmentTypeEnum {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[nu.ndw.EquipmentTypeEnum]): EquipmentTypeEnum = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: EquipmentTypeEnum) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
}

case object Toilet extends EquipmentTypeEnum { override def toString = "toilet" }
case object Shower extends EquipmentTypeEnum { override def toString = "shower" }
case object InformationPoint extends EquipmentTypeEnum { override def toString = "informationPoint" }
case object InformatonStele extends EquipmentTypeEnum { override def toString = "informatonStele" }
case object InternetTerminal extends EquipmentTypeEnum { override def toString = "internetTerminal" }
case object InternetWireless extends EquipmentTypeEnum { override def toString = "internetWireless" }
case object PayDesk extends EquipmentTypeEnum { override def toString = "payDesk" }
case object PaymentMachine extends EquipmentTypeEnum { override def toString = "paymentMachine" }
case object CashMachine extends EquipmentTypeEnum { override def toString = "cashMachine" }
case object VendingMachine extends EquipmentTypeEnum { override def toString = "vendingMachine" }
case object FaxMachineOrService extends EquipmentTypeEnum { override def toString = "faxMachineOrService" }
case object CopyMachineOrService extends EquipmentTypeEnum { override def toString = "copyMachineOrService" }
case object SafeDeposit extends EquipmentTypeEnum { override def toString = "safeDeposit" }
case object LuggageLocker extends EquipmentTypeEnum { override def toString = "luggageLocker" }
case object PublicPhone extends EquipmentTypeEnum { override def toString = "publicPhone" }
case object PublicCoinPhone extends EquipmentTypeEnum { override def toString = "publicCoinPhone" }
case object PublicCardPhone extends EquipmentTypeEnum { override def toString = "publicCardPhone" }
case object Elevator extends EquipmentTypeEnum { override def toString = "elevator" }
case object PicnicFacilities extends EquipmentTypeEnum { override def toString = "picnicFacilities" }
case object DumpingStation extends EquipmentTypeEnum { override def toString = "dumpingStation" }
case object FreshWater extends EquipmentTypeEnum { override def toString = "freshWater" }
case object WasteDisposal extends EquipmentTypeEnum { override def toString = "wasteDisposal" }
case object RefuseBin extends EquipmentTypeEnum { override def toString = "refuseBin" }
case object IceFreeScaffold extends EquipmentTypeEnum { override def toString = "iceFreeScaffold" }
case object Playground extends EquipmentTypeEnum { override def toString = "playground" }
case object ElectricChargingStation extends EquipmentTypeEnum { override def toString = "electricChargingStation" }
case object BikeParking extends EquipmentTypeEnum { override def toString = "bikeParking" }
case object TollTerminal extends EquipmentTypeEnum { override def toString = "tollTerminal" }
case object Defibrillator extends EquipmentTypeEnum { override def toString = "defibrillator" }
case object FirstAidEquipment extends EquipmentTypeEnum { override def toString = "firstAidEquipment" }
case object FireHose extends EquipmentTypeEnum { override def toString = "fireHose" }
case object FireExtingiusher extends EquipmentTypeEnum { override def toString = "fireExtingiusher" }
case object FireHydrant extends EquipmentTypeEnum { override def toString = "fireHydrant" }
case object NoneTypeValue5 extends EquipmentTypeEnum { override def toString = "none" }
case object UnknownValue30 extends EquipmentTypeEnum { override def toString = "unknown" }
case object OtherValue58 extends EquipmentTypeEnum { override def toString = "other" }



case class Exchange(changedFlag: Option[nu.ndw.ChangedFlagEnum] = None,
  clientIdentification: Option[String] = None,
  deliveryBreak: Option[Boolean] = None,
  denyReason: Option[nu.ndw.DenyReasonEnum] = None,
  historicalStartDate: Option[javax.xml.datatype.XMLGregorianCalendar] = None,
  historicalStopDate: Option[javax.xml.datatype.XMLGregorianCalendar] = None,
  keepAlive: Option[Boolean] = None,
  requestType: Option[nu.ndw.RequestTypeEnum] = None,
  response: Option[nu.ndw.ResponseEnum] = None,
  subscriptionReference: Option[String] = None,
  supplierIdentification: nu.ndw.InternationalIdentifier,
  target: Option[nu.ndw.Target] = None,
  subscription: Option[nu.ndw.Subscription] = None,
  filterReference: Seq[nu.ndw.FilterReference] = Nil,
  catalogueReference: Seq[nu.ndw.CatalogueReference] = Nil,
  exchangeExtension: Option[nu.ndw._ExtensionType] = None)
      



case class ExternalReferencing(externalLocationCode: String,
  externalReferencingSystem: String,
  externalReferencingExtension: Option[nu.ndw._ExtensionType] = None)
      


sealed trait Faultable {
  def faultIdentifier: Option[String]
  def faultDescription: Option[String]
  def faultCreationTime: Option[javax.xml.datatype.XMLGregorianCalendar]
  def faultLastUpdateTime: javax.xml.datatype.XMLGregorianCalendar
  def faultSeverity: Option[nu.ndw.FaultSeverityEnum]
  def faultExtension: Option[nu.ndw._ExtensionType]
}



case class Fault(faultIdentifier: Option[String] = None,
  faultDescription: Option[String] = None,
  faultCreationTime: Option[javax.xml.datatype.XMLGregorianCalendar] = None,
  faultLastUpdateTime: javax.xml.datatype.XMLGregorianCalendar,
  faultSeverity: Option[nu.ndw.FaultSeverityEnum] = None,
  faultExtension: Option[nu.ndw._ExtensionType] = None) extends Faultable
      

sealed trait FaultSeverityEnum

object FaultSeverityEnum {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[nu.ndw.FaultSeverityEnum]): FaultSeverityEnum = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: FaultSeverityEnum) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
}

case object LowValue extends FaultSeverityEnum { override def toString = "low" }
case object MediumValue2 extends FaultSeverityEnum { override def toString = "medium" }
case object HighValue extends FaultSeverityEnum { override def toString = "high" }
case object UnknownValue31 extends FaultSeverityEnum { override def toString = "unknown" }



case class FilterExitManagement(filterEnd: Boolean,
  filterOutOfRange: Boolean,
  filterExitManagementExtension: Option[nu.ndw._ExtensionType] = None)
      



case class FilterReference(deleteFilter: Option[Boolean] = None,
  filterOperationApproved: Option[Boolean] = None,
  keyFilterReference: String,
  filterReferenceExtension: Option[nu.ndw._ExtensionType] = None)
      



case class FloatingPointMetreDistanceValue(dataError: Option[Boolean] = None,
  reasonForDataError: Option[nu.ndw.MultilingualString] = None,
  dataValueExtension: Option[nu.ndw._ExtensionType] = None,
  floatingPointMetreDistance: Float,
  floatingPointMetreDistanceValueExtension: Option[nu.ndw._ExtensionType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) extends DataValue {
  @JsonIgnore lazy val accuracy = attributes.get("@accuracy") map { _.as[Float]}
  @JsonIgnore lazy val computationalMethod = attributes.get("@computationalMethod") map { _.as[ComputationMethodEnum]}
  @JsonIgnore lazy val numberOfIncompleteInputs = attributes.get("@numberOfIncompleteInputs") map { _.as[Int]}
  @JsonIgnore lazy val numberOfInputValuesUsed = attributes.get("@numberOfInputValuesUsed") map { _.as[Int]}
  @JsonIgnore lazy val smoothingFactor = attributes.get("@smoothingFactor") map { _.as[Float]}
  @JsonIgnore lazy val standardDeviation = attributes.get("@standardDeviation") map { _.as[Float]}
  @JsonIgnore lazy val supplierCalculatedDataQuality = attributes.get("@supplierCalculatedDataQuality") map { _.as[Float]}
}

      

sealed trait FuelType2Enum

object FuelType2Enum {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[nu.ndw.FuelType2Enum]): FuelType2Enum = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: FuelType2Enum) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
}

case object AllType extends FuelType2Enum { override def toString = "all" }
case object Petrol95Octane extends FuelType2Enum { override def toString = "petrol95Octane" }
case object Petrol98Octane extends FuelType2Enum { override def toString = "petrol98Octane" }
case object PetrolLeaded extends FuelType2Enum { override def toString = "petrolLeaded" }
case object PetrolUnleaded extends FuelType2Enum { override def toString = "petrolUnleaded" }
case object UnknownValue21 extends FuelType2Enum { override def toString = "unknown" }
case object OtherValue38 extends FuelType2Enum { override def toString = "other" }

sealed trait FuelTypeEnum

object FuelTypeEnum {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[nu.ndw.FuelTypeEnum]): FuelTypeEnum = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: FuelTypeEnum) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
}

case object Battery extends FuelTypeEnum { override def toString = "battery" }
case object Biodiesel extends FuelTypeEnum { override def toString = "biodiesel" }
case object Diesel extends FuelTypeEnum { override def toString = "diesel" }
case object DieselBatteryHybrid extends FuelTypeEnum { override def toString = "dieselBatteryHybrid" }
case object Ethanol extends FuelTypeEnum { override def toString = "ethanol" }
case object Hydrogen extends FuelTypeEnum { override def toString = "hydrogen" }
case object LiquidGas extends FuelTypeEnum { override def toString = "liquidGas" }
case object Lpg extends FuelTypeEnum { override def toString = "lpg" }
case object Methane extends FuelTypeEnum { override def toString = "methane" }
case object PetrolValue extends FuelTypeEnum { override def toString = "petrol" }
case object PetrolBatteryHybrid extends FuelTypeEnum { override def toString = "petrolBatteryHybrid" }



case class GeneralInstructionOrMessageToRoadUsers(situationRecordCreationReference: Option[String] = None,
  situationRecordCreationTime: javax.xml.datatype.XMLGregorianCalendar,
  situationRecordObservationTime: Option[javax.xml.datatype.XMLGregorianCalendar] = None,
  situationRecordVersionTime: javax.xml.datatype.XMLGregorianCalendar,
  situationRecordFirstSupplierVersionTime: Option[javax.xml.datatype.XMLGregorianCalendar] = None,
  confidentialityOverride: Option[nu.ndw.ConfidentialityValueEnum] = None,
  probabilityOfOccurrence: nu.ndw.ProbabilityOfOccurrenceEnum,
  severity: Option[nu.ndw.SeverityEnum] = None,
  source: Option[nu.ndw.Source] = None,
  validity: nu.ndw.Validity,
  impact: Option[nu.ndw.Impact] = None,
  cause: Option[nu.ndw.Cause] = None,
  generalPublicComment: Seq[nu.ndw.Comment] = Nil,
  nonGeneralPublicComment: Seq[nu.ndw.Comment] = Nil,
  urlLink: Seq[nu.ndw.UrlLink] = Nil,
  groupOfLocations: nu.ndw.GroupOfLocations,
  management: Option[nu.ndw.Management] = None,
  situationRecordExtension: Option[nu.ndw._SituationRecordExtensionType] = None,
  actionOrigin: Option[nu.ndw.OperatorActionOriginEnum] = None,
  actionPlanIdentifier: Option[String] = None,
  operatorActionStatus: Option[nu.ndw.OperatorActionStatusEnum] = None,
  operatorActionExtension: Option[nu.ndw._ExtensionType] = None,
  complianceOption: nu.ndw.ComplianceOptionEnum,
  applicableForTrafficDirection: Seq[nu.ndw.DirectionEnum] = Nil,
  applicableForTrafficType: Seq[nu.ndw.TrafficTypeEnum] = Nil,
  placesAtWhichApplicable: Seq[nu.ndw.PlacesEnum] = Nil,
  automaticallyInitiated: Option[Boolean] = None,
  forVehiclesWithCharacteristicsOf: Seq[nu.ndw.VehicleCharacteristics] = Nil,
  networkManagementExtension: Option[nu.ndw._ExtensionType] = None,
  generalInstructionToRoadUsersType: Option[nu.ndw.GeneralInstructionToRoadUsersTypeEnum] = None,
  generalMessageToRoadUsers: Option[nu.ndw.MultilingualString] = None,
  generalInstructionOrMessageToRoadUsersExtension: Option[nu.ndw._ExtensionType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) extends NetworkManagement {
  @JsonIgnore lazy val id = attributes("@id").as[String]
  @JsonIgnore lazy val version = attributes("@version").as[String]
}

      

sealed trait GeneralInstructionToRoadUsersTypeEnum

object GeneralInstructionToRoadUsersTypeEnum {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[nu.ndw.GeneralInstructionToRoadUsersTypeEnum]): GeneralInstructionToRoadUsersTypeEnum = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: GeneralInstructionToRoadUsersTypeEnum) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
}

case object AllowEmergencyVehiclesToPass extends GeneralInstructionToRoadUsersTypeEnum { override def toString = "allowEmergencyVehiclesToPass" }
case object ApproachWithCare extends GeneralInstructionToRoadUsersTypeEnum { override def toString = "approachWithCare" }
case object AvoidTheArea extends GeneralInstructionToRoadUsersTypeEnum { override def toString = "avoidTheArea" }
case object CloseAllWindowsTurnOffHeaterAndVents extends GeneralInstructionToRoadUsersTypeEnum { override def toString = "closeAllWindowsTurnOffHeaterAndVents" }
case object CrossJunctionWithCare extends GeneralInstructionToRoadUsersTypeEnum { override def toString = "crossJunctionWithCare" }
case object DoNotAllowUnnecessaryGaps extends GeneralInstructionToRoadUsersTypeEnum { override def toString = "doNotAllowUnnecessaryGaps" }
case object DoNotLeaveYourVehicle extends GeneralInstructionToRoadUsersTypeEnum { override def toString = "doNotLeaveYourVehicle" }
case object DoNotThrowOutAnyBurningObjects extends GeneralInstructionToRoadUsersTypeEnum { override def toString = "doNotThrowOutAnyBurningObjects" }
case object DoNotUseNavigationSystems extends GeneralInstructionToRoadUsersTypeEnum { override def toString = "doNotUseNavigationSystems" }
case object DriveCarefully extends GeneralInstructionToRoadUsersTypeEnum { override def toString = "driveCarefully" }
case object DriveWithExtremeCaution extends GeneralInstructionToRoadUsersTypeEnum { override def toString = "driveWithExtremeCaution" }
case object FlashYourLights extends GeneralInstructionToRoadUsersTypeEnum { override def toString = "flashYourLights" }
case object FollowTheVehicleInFrontSmoothly extends GeneralInstructionToRoadUsersTypeEnum { override def toString = "followTheVehicleInFrontSmoothly" }
case object IncreaseNormalFollowingDistance extends GeneralInstructionToRoadUsersTypeEnum { override def toString = "increaseNormalFollowingDistance" }
case object InEmergencyWaitForPatrolService extends GeneralInstructionToRoadUsersTypeEnum { override def toString = "inEmergencyWaitForPatrolService" }
case object KeepYourDistance extends GeneralInstructionToRoadUsersTypeEnum { override def toString = "keepYourDistance" }
case object LeaveYourVehicleProceedToNextSafePlace extends GeneralInstructionToRoadUsersTypeEnum { override def toString = "leaveYourVehicleProceedToNextSafePlace" }
case object NoNakedFlames extends GeneralInstructionToRoadUsersTypeEnum { override def toString = "noNakedFlames" }
case object NoOvertaking extends GeneralInstructionToRoadUsersTypeEnum { override def toString = "noOvertaking" }
case object NoSmoking extends GeneralInstructionToRoadUsersTypeEnum { override def toString = "noSmoking" }
case object NoStopping extends GeneralInstructionToRoadUsersTypeEnum { override def toString = "noStopping" }
case object NoUturns extends GeneralInstructionToRoadUsersTypeEnum { override def toString = "noUturns" }
case object ObserveAmberAlert extends GeneralInstructionToRoadUsersTypeEnum { override def toString = "observeAmberAlert" }
case object ObserveSignals extends GeneralInstructionToRoadUsersTypeEnum { override def toString = "observeSignals" }
case object ObserveSigns extends GeneralInstructionToRoadUsersTypeEnum { override def toString = "observeSigns" }
case object OnlyTravelIfAbsolutelyNecessary extends GeneralInstructionToRoadUsersTypeEnum { override def toString = "onlyTravelIfAbsolutelyNecessary" }
case object OvertakeWithCare extends GeneralInstructionToRoadUsersTypeEnum { override def toString = "overtakeWithCare" }
case object PullOverToTheEdgeOfTheRoadway extends GeneralInstructionToRoadUsersTypeEnum { override def toString = "pullOverToTheEdgeOfTheRoadway" }
case object StopAtNextSafePlace extends GeneralInstructionToRoadUsersTypeEnum { override def toString = "stopAtNextSafePlace" }
case object StopAtNextServiceArea extends GeneralInstructionToRoadUsersTypeEnum { override def toString = "stopAtNextServiceArea" }
case object SwitchOffEngine extends GeneralInstructionToRoadUsersTypeEnum { override def toString = "switchOffEngine" }
case object SwitchOffMobilePhonesAndTwoWayRadios extends GeneralInstructionToRoadUsersTypeEnum { override def toString = "switchOffMobilePhonesAndTwoWayRadios" }
case object TestYourBrakes extends GeneralInstructionToRoadUsersTypeEnum { override def toString = "testYourBrakes" }
case object UseBusService extends GeneralInstructionToRoadUsersTypeEnum { override def toString = "useBusService" }
case object UseFogLights extends GeneralInstructionToRoadUsersTypeEnum { override def toString = "useFogLights" }
case object UseHazardWarningLights extends GeneralInstructionToRoadUsersTypeEnum { override def toString = "useHazardWarningLights" }
case object UseHeadlights extends GeneralInstructionToRoadUsersTypeEnum { override def toString = "useHeadlights" }
case object UseRailService extends GeneralInstructionToRoadUsersTypeEnum { override def toString = "useRailService" }
case object UseTramService extends GeneralInstructionToRoadUsersTypeEnum { override def toString = "useTramService" }
case object UseUndergroundService extends GeneralInstructionToRoadUsersTypeEnum { override def toString = "useUndergroundService" }
case object WaitForEscortVehicle extends GeneralInstructionToRoadUsersTypeEnum { override def toString = "waitForEscortVehicle" }
case object OtherValue59 extends GeneralInstructionToRoadUsersTypeEnum { override def toString = "other" }



case class GeneralNetworkManagement(situationRecordCreationReference: Option[String] = None,
  situationRecordCreationTime: javax.xml.datatype.XMLGregorianCalendar,
  situationRecordObservationTime: Option[javax.xml.datatype.XMLGregorianCalendar] = None,
  situationRecordVersionTime: javax.xml.datatype.XMLGregorianCalendar,
  situationRecordFirstSupplierVersionTime: Option[javax.xml.datatype.XMLGregorianCalendar] = None,
  confidentialityOverride: Option[nu.ndw.ConfidentialityValueEnum] = None,
  probabilityOfOccurrence: nu.ndw.ProbabilityOfOccurrenceEnum,
  severity: Option[nu.ndw.SeverityEnum] = None,
  source: Option[nu.ndw.Source] = None,
  validity: nu.ndw.Validity,
  impact: Option[nu.ndw.Impact] = None,
  cause: Option[nu.ndw.Cause] = None,
  generalPublicComment: Seq[nu.ndw.Comment] = Nil,
  nonGeneralPublicComment: Seq[nu.ndw.Comment] = Nil,
  urlLink: Seq[nu.ndw.UrlLink] = Nil,
  groupOfLocations: nu.ndw.GroupOfLocations,
  management: Option[nu.ndw.Management] = None,
  situationRecordExtension: Option[nu.ndw._SituationRecordExtensionType] = None,
  actionOrigin: Option[nu.ndw.OperatorActionOriginEnum] = None,
  actionPlanIdentifier: Option[String] = None,
  operatorActionStatus: Option[nu.ndw.OperatorActionStatusEnum] = None,
  operatorActionExtension: Option[nu.ndw._ExtensionType] = None,
  complianceOption: nu.ndw.ComplianceOptionEnum,
  applicableForTrafficDirection: Seq[nu.ndw.DirectionEnum] = Nil,
  applicableForTrafficType: Seq[nu.ndw.TrafficTypeEnum] = Nil,
  placesAtWhichApplicable: Seq[nu.ndw.PlacesEnum] = Nil,
  automaticallyInitiated: Option[Boolean] = None,
  forVehiclesWithCharacteristicsOf: Seq[nu.ndw.VehicleCharacteristics] = Nil,
  networkManagementExtension: Option[nu.ndw._ExtensionType] = None,
  generalNetworkManagementType: nu.ndw.GeneralNetworkManagementTypeEnum,
  trafficManuallyDirectedBy: Option[nu.ndw.PersonCategoryEnum] = None,
  generalNetworkManagementExtension: Option[nu.ndw._ExtensionType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) extends NetworkManagement {
  @JsonIgnore lazy val id = attributes("@id").as[String]
  @JsonIgnore lazy val version = attributes("@version").as[String]
}

      

sealed trait GeneralNetworkManagementTypeEnum

object GeneralNetworkManagementTypeEnum {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[nu.ndw.GeneralNetworkManagementTypeEnum]): GeneralNetworkManagementTypeEnum = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: GeneralNetworkManagementTypeEnum) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
}

case object BridgeSwingInOperationValue extends GeneralNetworkManagementTypeEnum { override def toString = "bridgeSwingInOperation" }
case object ConvoyService extends GeneralNetworkManagementTypeEnum { override def toString = "convoyService" }
case object ObstacleSignalling extends GeneralNetworkManagementTypeEnum { override def toString = "obstacleSignalling" }
case object RampMeteringInOperation extends GeneralNetworkManagementTypeEnum { override def toString = "rampMeteringInOperation" }
case object TemporaryTrafficLightsValue extends GeneralNetworkManagementTypeEnum { override def toString = "temporaryTrafficLights" }
case object TollGatesOpen extends GeneralNetworkManagementTypeEnum { override def toString = "tollGatesOpen" }
case object TrafficBeingManuallyDirected extends GeneralNetworkManagementTypeEnum { override def toString = "trafficBeingManuallyDirected" }
case object TrafficHeld extends GeneralNetworkManagementTypeEnum { override def toString = "trafficHeld" }
case object OtherValue60 extends GeneralNetworkManagementTypeEnum { override def toString = "other" }



case class GeneralObstruction(situationRecordCreationReference: Option[String] = None,
  situationRecordCreationTime: javax.xml.datatype.XMLGregorianCalendar,
  situationRecordObservationTime: Option[javax.xml.datatype.XMLGregorianCalendar] = None,
  situationRecordVersionTime: javax.xml.datatype.XMLGregorianCalendar,
  situationRecordFirstSupplierVersionTime: Option[javax.xml.datatype.XMLGregorianCalendar] = None,
  confidentialityOverride: Option[nu.ndw.ConfidentialityValueEnum] = None,
  probabilityOfOccurrence: nu.ndw.ProbabilityOfOccurrenceEnum,
  severity: Option[nu.ndw.SeverityEnum] = None,
  source: Option[nu.ndw.Source] = None,
  validity: nu.ndw.Validity,
  impact: Option[nu.ndw.Impact] = None,
  cause: Option[nu.ndw.Cause] = None,
  generalPublicComment: Seq[nu.ndw.Comment] = Nil,
  nonGeneralPublicComment: Seq[nu.ndw.Comment] = Nil,
  urlLink: Seq[nu.ndw.UrlLink] = Nil,
  groupOfLocations: nu.ndw.GroupOfLocations,
  management: Option[nu.ndw.Management] = None,
  situationRecordExtension: Option[nu.ndw._SituationRecordExtensionType] = None,
  trafficElementExtension: Option[nu.ndw._ExtensionType] = None,
  numberOfObstructions: Option[Int] = None,
  mobilityOfObstruction: Option[nu.ndw.Mobility] = None,
  obstructionExtension: Option[nu.ndw._ExtensionType] = None,
  obstructionType: Seq[nu.ndw.ObstructionTypeEnum] = Nil,
  groupOfPeopleInvolved: Seq[nu.ndw.GroupOfPeopleInvolved] = Nil,
  generalObstructionExtension: Option[nu.ndw._ExtensionType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) extends ObstructionType {
  @JsonIgnore lazy val id = attributes("@id").as[String]
  @JsonIgnore lazy val version = attributes("@version").as[String]
}

      



case class GenericPublication(feedDescription: Option[nu.ndw.MultilingualString] = None,
  feedType: Option[String] = None,
  publicationTime: javax.xml.datatype.XMLGregorianCalendar,
  publicationCreator: nu.ndw.InternationalIdentifier,
  payloadPublicationExtension: Option[nu.ndw._ExtensionType] = None,
  genericPublicationName: String,
  genericPublicationExtension: Option[nu.ndw._GenericPublicationExtensionType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) extends PayloadPublication {
  @JsonIgnore lazy val lang = attributes("@lang").as[String]
}

      



case class GenericSituationRecord(situationRecordCreationReference: Option[String] = None,
  situationRecordCreationTime: javax.xml.datatype.XMLGregorianCalendar,
  situationRecordObservationTime: Option[javax.xml.datatype.XMLGregorianCalendar] = None,
  situationRecordVersionTime: javax.xml.datatype.XMLGregorianCalendar,
  situationRecordFirstSupplierVersionTime: Option[javax.xml.datatype.XMLGregorianCalendar] = None,
  confidentialityOverride: Option[nu.ndw.ConfidentialityValueEnum] = None,
  probabilityOfOccurrence: nu.ndw.ProbabilityOfOccurrenceEnum,
  severity: Option[nu.ndw.SeverityEnum] = None,
  source: Option[nu.ndw.Source] = None,
  validity: nu.ndw.Validity,
  impact: Option[nu.ndw.Impact] = None,
  cause: Option[nu.ndw.Cause] = None,
  generalPublicComment: Seq[nu.ndw.Comment] = Nil,
  nonGeneralPublicComment: Seq[nu.ndw.Comment] = Nil,
  urlLink: Seq[nu.ndw.UrlLink] = Nil,
  groupOfLocations: nu.ndw.GroupOfLocations,
  management: Option[nu.ndw.Management] = None,
  situationRecordExtension: Option[nu.ndw._SituationRecordExtensionType] = None,
  genericSituationRecordName: String,
  genericSituationRecordExtension: Option[nu.ndw._ExtensionType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) extends SituationRecord {
  @JsonIgnore lazy val id = attributes("@id").as[String]
  @JsonIgnore lazy val version = attributes("@version").as[String]
}

      



case class GrossWeightCharacteristic(comparisonOperator: nu.ndw.ComparisonOperatorEnum,
  grossVehicleWeight: Float,
  grossWeightCharacteristicExtension: Option[nu.ndw._ExtensionType] = None)
      


sealed trait GroupOfLocations {
  def groupOfLocationsExtension: Option[nu.ndw._ExtensionType]
}



case class GroupOfParkingSites(parkingName: Option[nu.ndw.MultilingualString] = None,
  parkingAlias: Seq[nu.ndw.MultilingualString] = Nil,
  parkingDescription: Option[nu.ndw.MultilingualString] = None,
  parkingRecordVersionTime: javax.xml.datatype.XMLGregorianCalendar,
  parkingNumberOfSpaces: Option[Int] = None,
  parkingPrincipalNumberOfSpaces: Option[Int] = None,
  maximumParkingDuration: Option[Float] = None,
  photoUrl: Option[java.net.URI] = None,
  urlLinkAddress: Option[java.net.URI] = None,
  parkingOccupanyDetectionType: Seq[nu.ndw.OccupancyDetectionTypeEnum] = Nil,
  emergencyContact: Seq[nu.ndw.Contactable] = Nil,
  owner: Seq[nu.ndw.Contactable] = Nil,
  responisbleAuthority: Seq[nu.ndw.Contactable] = Nil,
  securityService: Seq[nu.ndw.Contactable] = Nil,
  operator: Seq[nu.ndw.Contactable] = Nil,
  servicePartner: Seq[nu.ndw.Contactable] = Nil,
  parkingVMS: Seq[nu.ndw.ParkingVMS] = Nil,
  parkingLocation: nu.ndw.GroupOfLocations,
  parkingRoute: Seq[nu.ndw.ParkingRoute] = Nil,
  parkingColour: Option[nu.ndw.RGBColour] = None,
  onlyAssignedParking: Option[nu.ndw.ParkingAssignment] = None,
  assignedParkingAmongOthers: Option[nu.ndw.ParkingAssignment] = None,
  prohibitedParking: Option[nu.ndw.ParkingAssignment] = None,
  tariffsAndPayment: Option[nu.ndw.TariffsAndPayment] = None,
  parkingEquipmentOrServiceFacility: Seq[nu.ndw._ParkingRecordEquipmentOrServiceFacilityIndexParkingEquipmentOrServiceFacility] = Nil,
  parkingSpace: Seq[nu.ndw._ParkingSpace] = Nil,
  groupOfParkingSpaces: Seq[nu.ndw._GroupOfParkingSpaces] = Nil,
  parkingThresholds: Option[nu.ndw.ParkingThresholds] = None,
  permitsAndProhibitions: Seq[nu.ndw.PermitsAndProhibitions] = Nil,
  emergencyAssemblyPoint: Option[nu.ndw.GroupOfLocations] = None,
  entireArea: Option[nu.ndw.Area] = None,
  parkingRecordDimension: Option[nu.ndw.Dimension] = None,
  parkingRecordExtension: Option[nu.ndw._ExtensionType] = None,
  groupOfParkingSitesType: Option[nu.ndw.GroupOfParkingSitesTypeEnum] = None,
  parkingSiteByReference: Seq[nu.ndw._ParkingRecordVersionedReference] = Nil,
  parkingSite: Seq[nu.ndw.ParkingSite] = Nil,
  groupOfParkingSitesExtension: Option[nu.ndw._ExtensionType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) extends ParkingRecord {
  @JsonIgnore lazy val id = attributes("@id").as[String]
  @JsonIgnore lazy val version = attributes("@version").as[String]
}

      



case class GroupOfParkingSitesStatus(parkingRecordReference: nu.ndw._ParkingRecordVersionedReference,
  parkingStatusOriginTime: javax.xml.datatype.XMLGregorianCalendar,
  parkingStatusDescription: Option[nu.ndw.MultilingualString] = None,
  parkingQueueingTime: Option[Float] = None,
  parkingConditions: Option[nu.ndw.ParkingConditionsEnum] = None,
  blurredAvailability: Seq[Boolean] = Nil,
  parkingFault: Seq[nu.ndw.ParkingFaultEnum] = Nil,
  winterEquipmentManagementType: Seq[nu.ndw.WinterEquipmentManagementTypeEnum] = Nil,
  parkingSpaceStatus: Seq[nu.ndw._ParkingRecordStatusParkingSpaceIndexParkingSpaceStatus] = Nil,
  parkingOccupancy: nu.ndw.ParkingOccupancyable,
  groupOfParkingSpacesStatus: Seq[nu.ndw._ParkingRecordStatusGroupIndexGroupOfParkingSpacesStatus] = Nil,
  parkingStatusValidity: Option[nu.ndw.ParkingStatusValidity] = None,
  overrideParkingThresholds: Option[nu.ndw.ParkingThresholds] = None,
  parkingEquipmentOrServiceFacilityStatus: Seq[nu.ndw._ParkingRecordStatusEquipmentOrServiceFacilityIndexParkingEquipmentOrServiceFacilityStatus] = Nil,
  parkingUsageScenarioStatus: Seq[nu.ndw._ParkingRecordStatusScenarioIndexParkingUsageScenarioStatus] = Nil,
  parkingAccessStatus: Seq[nu.ndw.ParkingAccessStatus] = Nil,
  parkingRouteStatus: Seq[nu.ndw.ParkingRouteStatus] = Nil,
  parkingRecordStatusExtension: Option[nu.ndw._ExtensionType] = None,
  groupOfParkingSitesStatus: Option[nu.ndw.GroupOfParkingSitesStatusEnum] = None,
  groupOfParkingSitesStatusExtension: Option[nu.ndw._ExtensionType] = None) extends ParkingRecordStatus
      

sealed trait GroupOfParkingSitesStatusEnum

object GroupOfParkingSitesStatusEnum {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[nu.ndw.GroupOfParkingSitesStatusEnum]): GroupOfParkingSitesStatusEnum = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: GroupOfParkingSitesStatusEnum) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
}

case object AllParkingsFull extends GroupOfParkingSitesStatusEnum { override def toString = "allParkingsFull" }
case object MultiStoreyParkingsFull extends GroupOfParkingSitesStatusEnum { override def toString = "multiStoreyParkingsFull" }
case object NoMoreParkingSpacesAvailableValue extends GroupOfParkingSitesStatusEnum { override def toString = "noMoreParkingSpacesAvailable" }
case object EnoughSpacesAvailableValue extends GroupOfParkingSitesStatusEnum { override def toString = "enoughSpacesAvailable" }
case object UnknownValue32 extends GroupOfParkingSitesStatusEnum { override def toString = "unknown" }
case object OtherValue61 extends GroupOfParkingSitesStatusEnum { override def toString = "other" }

sealed trait GroupOfParkingSitesTypeEnum

object GroupOfParkingSitesTypeEnum {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[nu.ndw.GroupOfParkingSitesTypeEnum]): GroupOfParkingSitesTypeEnum = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: GroupOfParkingSitesTypeEnum) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
}

case object ParkingArea extends GroupOfParkingSitesTypeEnum { override def toString = "parkingArea" }
case object TruckParkingPriorityZone extends GroupOfParkingSitesTypeEnum { override def toString = "truckParkingPriorityZone" }
case object AggregationOfInformation extends GroupOfParkingSitesTypeEnum { override def toString = "aggregationOfInformation" }
case object InhabitantZone extends GroupOfParkingSitesTypeEnum { override def toString = "inhabitantZone" }



case class GroupOfParkingSpaces(parkingSpaceOrGroupIdentifier: Option[nu.ndw.MultilingualString] = None,
  parkingFloorOrLevel: Option[Int] = None,
  accessibility: Seq[nu.ndw.AccessibilityEnum] = Nil,
  parkingSpaceAccessibility: Seq[nu.ndw.ParkingSpaceAccessibilityEnum] = Nil,
  parkingSpacePhysics: Seq[nu.ndw.ParkingSpacePhysicsEnum] = Nil,
  parkingMode: Option[nu.ndw.ParkingModeEnum] = None,
  parkingReservation: Option[nu.ndw.ReservationTypeEnum] = None,
  maximumParkingDuration: Option[Float] = None,
  distanceFromPrimaryRoad: Option[Int] = None,
  parkingOccupanyDetectionType: Seq[nu.ndw.OccupancyDetectionTypeEnum] = Nil,
  parkingSecurity: Seq[nu.ndw.ParkingSecurityEnum] = Nil,
  dedicatedAccess: Seq[nu.ndw.DedicatedAccess] = Nil,
  onlyAssignedParking: Option[nu.ndw.ParkingAssignment] = None,
  assignedParkingAmongOthers: Option[nu.ndw.ParkingAssignment] = None,
  prohibitedParking: Option[nu.ndw.ParkingAssignment] = None,
  parkingEquipmentOrServiceFacility: Seq[nu.ndw._ParkingSpaceBasicsEquipmentOrServiceFacilityIndexParkingEquipmentOrServiceFacility] = Nil,
  parkingUsageScenario: Seq[nu.ndw._ParkingSpaceBasicsScenarioIndexParkingUsageScenario] = Nil,
  parkingSpaceBasicsExtension: Option[nu.ndw._ExtensionType] = None,
  parkingNumberOfSpaces: Int,
  parkingTypeOfGroup: nu.ndw.ParkingTypeOfGroup,
  identicalToGroup: Seq[String] = Nil,
  realSubsetOfGroup: Seq[String] = Nil,
  minimumParkingSpaceDimension: Option[nu.ndw.Dimension] = None,
  dimensionOfGroup: Option[nu.ndw.Dimension] = None,
  maximumParkingSpaceDimension: Option[nu.ndw.Dimension] = None,
  parkingSpace: Seq[nu.ndw._GroupOfParkingSpacesParkingSpaceIndexParkingSpace] = Nil,
  groupOfLocations: Option[nu.ndw.GroupOfLocations] = None,
  groupOfParkingSpacesExtension: Option[nu.ndw._ExtensionType] = None) extends ParkingSpaceBasics
      



case class GroupOfParkingSpacesStatus(parkingNumberOfSpacesOverride: Option[Int] = None,
  parkingNumberOfVacantSpaces: Option[Int] = None,
  parkingNumberOfVacantSpacesLowerThan: Option[Int] = None,
  parkingNumberOfVacantSpacesHigherThan: Option[Int] = None,
  parkingNumberOfVacantSpacesGraded: Option[nu.ndw.ParkingVacantSpacesEnum] = None,
  parkingNumberOfOccupiedSpaces: Option[Int] = None,
  parkingNumberOfVehicles: Option[Int] = None,
  parkingOccupancy: Option[Float] = None,
  parkingOccupancyGraded: Option[nu.ndw.ParkingOccupancyEnum] = None,
  parkingOccupancyTrend: Option[nu.ndw.ParkingOccupancyTrendEnum] = None,
  parkingNotAllowed: Option[Boolean] = None,
  vehicleCountAndRate: Seq[nu.ndw.VehicleCountAndRate] = Nil,
  parkingOccupancyExtension: Option[nu.ndw._ExtensionType] = None,
  groupDeclarationValidNow: Option[Boolean] = None,
  groupOfParkingSpacesClosed: Option[Boolean] = None,
  groupOfParkingSpacesStatusExtension: Option[nu.ndw._ExtensionType] = None) extends ParkingOccupancyable
      



case class GroupOfPeopleInvolved(numberOfPeople: Option[Int] = None,
  injuryStatus: Option[nu.ndw.InjuryStatusTypeEnum] = None,
  involvementRole: Option[nu.ndw.InvolvementRolesEnum] = None,
  categoryOfPeopleInvolved: Option[nu.ndw.PersonCategoryEnum] = None,
  groupOfPeopleInvolvedExtension: Option[nu.ndw._ExtensionType] = None)
      



case class GroupOfVehiclesInvolved(numberOfVehicles: Option[Int] = None,
  vehicleStatus: Option[nu.ndw.VehicleStatusEnum] = None,
  vehicleCharacteristics: Option[nu.ndw.VehicleCharacteristics] = None,
  groupOfVehiclesInvolvedExtension: Option[nu.ndw._ExtensionType] = None)
      



case class HazardousMaterialsType(chemicalName: nu.ndw.MultilingualString,
  dangerousGoodsFlashPoint: Option[Float] = None,
  dangerousGoodsRegulations: Option[nu.ndw.DangerousGoodsRegulationsEnum] = None,
  hazardCodeIdentification: Option[String] = None,
  hazardCodeVersionNumber: Option[Int] = None,
  hazardSubstanceItemPageNumber: Option[String] = None,
  tremCardNumber: Option[String] = None,
  undgNumber: Option[String] = None,
  volumeOfDangerousGoods: Option[Float] = None,
  weightOfDangerousGoods: Option[Float] = None,
  hazardousMaterialsExtension: Option[nu.ndw._ExtensionType] = None)
      



case class HeaderInformation(areaOfInterest: Option[nu.ndw.AreaOfInterestEnum] = None,
  confidentiality: nu.ndw.ConfidentialityValueEnum,
  informationStatus: nu.ndw.InformationStatusEnum,
  urgency: Option[nu.ndw.UrgencyEnum] = None,
  headerInformationExtension: Option[nu.ndw._ExtensionType] = None)
      



case class HeaviestAxleWeightCharacteristic(comparisonOperator: nu.ndw.ComparisonOperatorEnum,
  heaviestAxleWeight: Float,
  heaviestAxleWeightCharacteristicExtension: Option[nu.ndw._ExtensionType] = None)
      



case class HeightCharacteristic(comparisonOperator: nu.ndw.ComparisonOperatorEnum,
  vehicleHeight: Float,
  heightCharacteristicExtension: Option[nu.ndw._ExtensionType] = None)
      

sealed trait HeightGradeEnum

object HeightGradeEnum {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[nu.ndw.HeightGradeEnum]): HeightGradeEnum = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: HeightGradeEnum) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
}

case object AboveGrade extends HeightGradeEnum { override def toString = "aboveGrade" }
case object AtGrade extends HeightGradeEnum { override def toString = "atGrade" }
case object BelowGrade extends HeightGradeEnum { override def toString = "belowGrade" }



case class Humidity(relativeHumidity: nu.ndw.PercentageValue,
  humidityExtension: Option[nu.ndw._ExtensionType] = None)
      



case class HumidityInformationType(measurementOrCalculationPeriod: Option[Float] = None,
  measurementOrCalculationTime: Option[javax.xml.datatype.XMLGregorianCalendar] = None,
  pertinentLocation: Option[nu.ndw.GroupOfLocations] = None,
  basicDataExtension: Option[nu.ndw._ExtensionType] = None,
  weatherDataExtension: Option[nu.ndw._ExtensionType] = None,
  humidity: nu.ndw.Humidity,
  humidityInformationExtension: Option[nu.ndw._ExtensionType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) extends WeatherData {
  @JsonIgnore lazy val measurementOrCalculatedTimePrecision = attributes.get("@measurementOrCalculatedTimePrecision") map { _.as[TimePrecisionEnum]}
}

      



case class Impact(capacityRemaining: Option[Float] = None,
  numberOfLanesRestricted: Option[Int] = None,
  numberOfOperationalLanes: Option[Int] = None,
  originalNumberOfLanes: Option[Int] = None,
  residualRoadWidth: Option[Float] = None,
  trafficConstrictionType: Option[nu.ndw.TrafficConstrictionTypeEnum] = None,
  delays: Option[nu.ndw.Delays] = None,
  impactExtension: Option[nu.ndw._ExtensionType] = None)
      



case class IndividualCharge(chargeBandReference: Option[nu.ndw._ChargeBandVersionedReference] = None,
  chargePaid: BigDecimal,
  chargeCurrency: Option[nu.ndw.CurrencyEnum] = None,
  usedMeansOfPayment: Option[nu.ndw.MeansOfPaymentEnum] = None,
  withReservation: Option[Boolean] = None,
  usedPaymentCard: Option[nu.ndw.UsedPaymentCard] = None,
  individualChargeExtension: Option[nu.ndw._ExtensionType] = None)
      



case class IndividualVehicleDataValues(measurementOrCalculationPeriod: Option[Float] = None,
  measurementOrCalculationTime: Option[javax.xml.datatype.XMLGregorianCalendar] = None,
  pertinentLocation: Option[nu.ndw.GroupOfLocations] = None,
  basicDataExtension: Option[nu.ndw._ExtensionType] = None,
  forVehiclesWithCharacteristicsOf: Option[nu.ndw.VehicleCharacteristics] = None,
  trafficDataExtension: Option[nu.ndw._ExtensionType] = None,
  individualVehicleSpeed: Option[nu.ndw.SpeedValue] = None,
  arrivalTime: Option[nu.ndw.DateTimeValue] = None,
  exitTime: Option[nu.ndw.DateTimeValue] = None,
  passageDurationTime: Option[nu.ndw.DurationValue] = None,
  presenceDurationTime: Option[nu.ndw.DurationValue] = None,
  timeGap: Option[nu.ndw.DurationValue] = None,
  timeHeadway: Option[nu.ndw.DurationValue] = None,
  distanceGap: Option[nu.ndw.FloatingPointMetreDistanceValue] = None,
  distanceHeadway: Option[nu.ndw.FloatingPointMetreDistanceValue] = None,
  individualVehicleDataValuesExtension: Option[nu.ndw._ExtensionType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) extends TrafficData {
  @JsonIgnore lazy val measurementOrCalculatedTimePrecision = attributes.get("@measurementOrCalculatedTimePrecision") map { _.as[TimePrecisionEnum]}
}

      

sealed trait InformationStatusEnum

object InformationStatusEnum {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[nu.ndw.InformationStatusEnum]): InformationStatusEnum = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: InformationStatusEnum) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
}

case object Real extends InformationStatusEnum { override def toString = "real" }
case object SecurityExercise extends InformationStatusEnum { override def toString = "securityExercise" }
case object TechnicalExercise extends InformationStatusEnum { override def toString = "technicalExercise" }
case object Test extends InformationStatusEnum { override def toString = "test" }



case class InfrastructureDamageObstruction(situationRecordCreationReference: Option[String] = None,
  situationRecordCreationTime: javax.xml.datatype.XMLGregorianCalendar,
  situationRecordObservationTime: Option[javax.xml.datatype.XMLGregorianCalendar] = None,
  situationRecordVersionTime: javax.xml.datatype.XMLGregorianCalendar,
  situationRecordFirstSupplierVersionTime: Option[javax.xml.datatype.XMLGregorianCalendar] = None,
  confidentialityOverride: Option[nu.ndw.ConfidentialityValueEnum] = None,
  probabilityOfOccurrence: nu.ndw.ProbabilityOfOccurrenceEnum,
  severity: Option[nu.ndw.SeverityEnum] = None,
  source: Option[nu.ndw.Source] = None,
  validity: nu.ndw.Validity,
  impact: Option[nu.ndw.Impact] = None,
  cause: Option[nu.ndw.Cause] = None,
  generalPublicComment: Seq[nu.ndw.Comment] = Nil,
  nonGeneralPublicComment: Seq[nu.ndw.Comment] = Nil,
  urlLink: Seq[nu.ndw.UrlLink] = Nil,
  groupOfLocations: nu.ndw.GroupOfLocations,
  management: Option[nu.ndw.Management] = None,
  situationRecordExtension: Option[nu.ndw._SituationRecordExtensionType] = None,
  trafficElementExtension: Option[nu.ndw._ExtensionType] = None,
  numberOfObstructions: Option[Int] = None,
  mobilityOfObstruction: Option[nu.ndw.Mobility] = None,
  obstructionExtension: Option[nu.ndw._ExtensionType] = None,
  infrastructureDamageType: nu.ndw.InfrastructureDamageTypeEnum,
  infrastructureDamageObstructionExtension: Option[nu.ndw._ExtensionType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) extends ObstructionType {
  @JsonIgnore lazy val id = attributes("@id").as[String]
  @JsonIgnore lazy val version = attributes("@version").as[String]
}

      

sealed trait InfrastructureDamageTypeEnum

object InfrastructureDamageTypeEnum {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[nu.ndw.InfrastructureDamageTypeEnum]): InfrastructureDamageTypeEnum = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: InfrastructureDamageTypeEnum) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
}

case object BurstPipe extends InfrastructureDamageTypeEnum { override def toString = "burstPipe" }
case object BurstWaterMain extends InfrastructureDamageTypeEnum { override def toString = "burstWaterMain" }
case object CollapsedSewer extends InfrastructureDamageTypeEnum { override def toString = "collapsedSewer" }
case object DamagedBridge extends InfrastructureDamageTypeEnum { override def toString = "damagedBridge" }
case object DamagedCrashBarrier extends InfrastructureDamageTypeEnum { override def toString = "damagedCrashBarrier" }
case object DamagedFlyover extends InfrastructureDamageTypeEnum { override def toString = "damagedFlyover" }
case object DamagedGallery extends InfrastructureDamageTypeEnum { override def toString = "damagedGallery" }
case object DamagedGantry extends InfrastructureDamageTypeEnum { override def toString = "damagedGantry" }
case object DamagedRoadSurface extends InfrastructureDamageTypeEnum { override def toString = "damagedRoadSurface" }
case object DamagedTunnel extends InfrastructureDamageTypeEnum { override def toString = "damagedTunnel" }
case object DamagedViaduct extends InfrastructureDamageTypeEnum { override def toString = "damagedViaduct" }
case object FallenPowerCables extends InfrastructureDamageTypeEnum { override def toString = "fallenPowerCables" }
case object GasLeak extends InfrastructureDamageTypeEnum { override def toString = "gasLeak" }
case object WeakBridge extends InfrastructureDamageTypeEnum { override def toString = "weakBridge" }
case object OtherValue37 extends InfrastructureDamageTypeEnum { override def toString = "other" }

sealed trait InjuryStatusTypeEnum

object InjuryStatusTypeEnum {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[nu.ndw.InjuryStatusTypeEnum]): InjuryStatusTypeEnum = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: InjuryStatusTypeEnum) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
}

case object Dead extends InjuryStatusTypeEnum { override def toString = "dead" }
case object Injured extends InjuryStatusTypeEnum { override def toString = "injured" }
case object SeriouslyInjured extends InjuryStatusTypeEnum { override def toString = "seriouslyInjured" }
case object SlightlyInjured extends InjuryStatusTypeEnum { override def toString = "slightlyInjured" }
case object Uninjured extends InjuryStatusTypeEnum { override def toString = "uninjured" }
case object UnknownValue33 extends InjuryStatusTypeEnum { override def toString = "unknown" }



case class IntegerMetreDistanceValue(dataError: Option[Boolean] = None,
  reasonForDataError: Option[nu.ndw.MultilingualString] = None,
  dataValueExtension: Option[nu.ndw._ExtensionType] = None,
  integerMetreDistance: Int,
  integerMetreDistanceValueExtension: Option[nu.ndw._ExtensionType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) extends DataValue {
  @JsonIgnore lazy val accuracy = attributes.get("@accuracy") map { _.as[Float]}
  @JsonIgnore lazy val computationalMethod = attributes.get("@computationalMethod") map { _.as[ComputationMethodEnum]}
  @JsonIgnore lazy val numberOfIncompleteInputs = attributes.get("@numberOfIncompleteInputs") map { _.as[Int]}
  @JsonIgnore lazy val numberOfInputValuesUsed = attributes.get("@numberOfInputValuesUsed") map { _.as[Int]}
  @JsonIgnore lazy val smoothingFactor = attributes.get("@smoothingFactor") map { _.as[Float]}
  @JsonIgnore lazy val standardDeviation = attributes.get("@standardDeviation") map { _.as[Float]}
  @JsonIgnore lazy val supplierCalculatedDataQuality = attributes.get("@supplierCalculatedDataQuality") map { _.as[Float]}
}

      



case class InternationalIdentifier(country: nu.ndw.CountryEnum,
  nationalIdentifier: String,
  internationalIdentifierExtension: Option[nu.ndw._ExtensionType] = None)
      



case class InterUrbanParkingSite(parkingName: Option[nu.ndw.MultilingualString] = None,
  parkingAlias: Seq[nu.ndw.MultilingualString] = Nil,
  parkingDescription: Option[nu.ndw.MultilingualString] = None,
  parkingRecordVersionTime: javax.xml.datatype.XMLGregorianCalendar,
  parkingNumberOfSpaces: Option[Int] = None,
  parkingPrincipalNumberOfSpaces: Option[Int] = None,
  maximumParkingDuration: Option[Float] = None,
  photoUrl: Option[java.net.URI] = None,
  urlLinkAddress: Option[java.net.URI] = None,
  parkingOccupanyDetectionType: Seq[nu.ndw.OccupancyDetectionTypeEnum] = Nil,
  emergencyContact: Seq[nu.ndw.Contactable] = Nil,
  owner: Seq[nu.ndw.Contactable] = Nil,
  responisbleAuthority: Seq[nu.ndw.Contactable] = Nil,
  securityService: Seq[nu.ndw.Contactable] = Nil,
  operator: Seq[nu.ndw.Contactable] = Nil,
  servicePartner: Seq[nu.ndw.Contactable] = Nil,
  parkingVMS: Seq[nu.ndw.ParkingVMS] = Nil,
  parkingLocation: nu.ndw.GroupOfLocations,
  parkingRoute: Seq[nu.ndw.ParkingRoute] = Nil,
  parkingColour: Option[nu.ndw.RGBColour] = None,
  onlyAssignedParking: Option[nu.ndw.ParkingAssignment] = None,
  assignedParkingAmongOthers: Option[nu.ndw.ParkingAssignment] = None,
  prohibitedParking: Option[nu.ndw.ParkingAssignment] = None,
  tariffsAndPayment: Option[nu.ndw.TariffsAndPayment] = None,
  parkingEquipmentOrServiceFacility: Seq[nu.ndw._ParkingRecordEquipmentOrServiceFacilityIndexParkingEquipmentOrServiceFacility] = Nil,
  parkingSpace: Seq[nu.ndw._ParkingSpace] = Nil,
  groupOfParkingSpaces: Seq[nu.ndw._GroupOfParkingSpaces] = Nil,
  parkingThresholds: Option[nu.ndw.ParkingThresholds] = None,
  permitsAndProhibitions: Seq[nu.ndw.PermitsAndProhibitions] = Nil,
  emergencyAssemblyPoint: Option[nu.ndw.GroupOfLocations] = None,
  entireArea: Option[nu.ndw.Area] = None,
  parkingRecordDimension: Option[nu.ndw.Dimension] = None,
  parkingRecordExtension: Option[nu.ndw._ExtensionType] = None,
  parkingReservation: Option[nu.ndw.ReservationTypeEnum] = None,
  parkingLayout: Seq[nu.ndw.ParkingLayoutEnum] = Nil,
  highestFloor: Option[Int] = None,
  lowestFloor: Option[Int] = None,
  temporaryParking: Option[Boolean] = None,
  parkingSiteAddress: Seq[nu.ndw.Contactable] = Nil,
  reservationService: Seq[nu.ndw.Contactable] = Nil,
  parkingUsageScenario: Seq[nu.ndw._ParkingSiteScenarioIndexParkingUsageScenario] = Nil,
  openingTimes: Option[nu.ndw.OpeningTimes] = None,
  parkingAccess: Seq[nu.ndw.ParkingAccess] = Nil,
  parkingStandardsAndSecurity: Option[nu.ndw.ParkingStandardsAndSecurity] = None,
  parkingSiteExtension: Option[nu.ndw._ExtensionType] = None,
  interUrbanParkingSiteLocation: nu.ndw.InterUrbanParkingSiteLocationEnum,
  interUrbanParkingSiteExtension: Option[nu.ndw._ExtensionType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) extends ParkingSite {
  @JsonIgnore lazy val id = attributes("@id").as[String]
  @JsonIgnore lazy val version = attributes("@version").as[String]
}

      

sealed trait InterUrbanParkingSiteLocationEnum

object InterUrbanParkingSiteLocationEnum {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[nu.ndw.InterUrbanParkingSiteLocationEnum]): InterUrbanParkingSiteLocationEnum = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: InterUrbanParkingSiteLocationEnum) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
}

case object MotorwayValue extends InterUrbanParkingSiteLocationEnum { override def toString = "motorway" }
case object NearbyMotorway extends InterUrbanParkingSiteLocationEnum { override def toString = "nearbyMotorway" }
case object LayBy extends InterUrbanParkingSiteLocationEnum { override def toString = "layBy" }
case object OnStreet extends InterUrbanParkingSiteLocationEnum { override def toString = "onStreet" }
case object OtherValue36 extends InterUrbanParkingSiteLocationEnum { override def toString = "other" }

sealed trait InvolvementRolesEnum

object InvolvementRolesEnum {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[nu.ndw.InvolvementRolesEnum]): InvolvementRolesEnum = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: InvolvementRolesEnum) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
}

case object Cyclist extends InvolvementRolesEnum { override def toString = "cyclist" }
case object Pedestrian extends InvolvementRolesEnum { override def toString = "pedestrian" }
case object UnknownValue34 extends InvolvementRolesEnum { override def toString = "unknown" }
case object VehicleDriver extends InvolvementRolesEnum { override def toString = "vehicleDriver" }
case object VehicleOccupant extends InvolvementRolesEnum { override def toString = "vehicleOccupant" }
case object VehiclePassenger extends InvolvementRolesEnum { override def toString = "vehiclePassenger" }
case object Witness extends InvolvementRolesEnum { override def toString = "witness" }


sealed trait Itinerary extends GroupOfLocations {
  def groupOfLocationsExtension: Option[nu.ndw._ExtensionType]
  def routeDestination: Seq[nu.ndw.Destination]
  def itineraryExtension: Option[nu.ndw._ExtensionType]
}



case class ItineraryByIndexedLocations(groupOfLocationsExtension: Option[nu.ndw._ExtensionType] = None,
  routeDestination: Seq[nu.ndw.Destination] = Nil,
  itineraryExtension: Option[nu.ndw._ExtensionType] = None,
  locationContainedInItinerary: Seq[nu.ndw._LocationContainedInItinerary] = Nil,
  itineraryByIndexedLocationsExtension: Option[nu.ndw._ExtensionType] = None) extends Itinerary
      



case class ItineraryByReference(groupOfLocationsExtension: Option[nu.ndw._ExtensionType] = None,
  routeDestination: Seq[nu.ndw.Destination] = Nil,
  itineraryExtension: Option[nu.ndw._ExtensionType] = None,
  predefinedItineraryReference: nu.ndw._PredefinedItineraryVersionedReference,
  itineraryByReferenceExtension: Option[nu.ndw._ExtensionType] = None) extends Itinerary
      



case class JunctionType(junctionClassification: Option[nu.ndw.JunctionClassificationEnum] = None,
  junctionName: nu.ndw.MultilingualString,
  junctionNumber: Option[String] = None,
  motorway: Option[nu.ndw.Roadable] = None,
  destinationMotorway: Seq[nu.ndw.Roadable] = Nil,
  junctionExtension: Option[nu.ndw._ExtensionType] = None)
      

sealed trait JunctionClassificationEnum

object JunctionClassificationEnum {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[nu.ndw.JunctionClassificationEnum]): JunctionClassificationEnum = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: JunctionClassificationEnum) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
}

case object ThreeWayInterchange extends JunctionClassificationEnum { override def toString = "threeWayInterchange" }
case object Interchange extends JunctionClassificationEnum { override def toString = "interchange" }
case object MotorwayConnection extends JunctionClassificationEnum { override def toString = "motorwayConnection" }
case object Junction extends JunctionClassificationEnum { override def toString = "junction" }
case object TemporaryJunction extends JunctionClassificationEnum { override def toString = "temporaryJunction" }
case object BorderCrossing extends JunctionClassificationEnum { override def toString = "borderCrossing" }
case object JunctionInOneDirection extends JunctionClassificationEnum { override def toString = "junctionInOneDirection" }
case object OperationalServiceJunction extends JunctionClassificationEnum { override def toString = "operationalServiceJunction" }
case object OtherValue35 extends JunctionClassificationEnum { override def toString = "other" }



case class KilogramsConcentrationValue(dataError: Option[Boolean] = None,
  reasonForDataError: Option[nu.ndw.MultilingualString] = None,
  dataValueExtension: Option[nu.ndw._ExtensionType] = None,
  kilogramsConcentration: Float,
  kilogramsConcentrationValueExtension: Option[nu.ndw._ExtensionType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) extends DataValue {
  @JsonIgnore lazy val accuracy = attributes.get("@accuracy") map { _.as[Float]}
  @JsonIgnore lazy val computationalMethod = attributes.get("@computationalMethod") map { _.as[ComputationMethodEnum]}
  @JsonIgnore lazy val numberOfIncompleteInputs = attributes.get("@numberOfIncompleteInputs") map { _.as[Int]}
  @JsonIgnore lazy val numberOfInputValuesUsed = attributes.get("@numberOfInputValuesUsed") map { _.as[Int]}
  @JsonIgnore lazy val smoothingFactor = attributes.get("@smoothingFactor") map { _.as[Float]}
  @JsonIgnore lazy val standardDeviation = attributes.get("@standardDeviation") map { _.as[Float]}
  @JsonIgnore lazy val supplierCalculatedDataQuality = attributes.get("@supplierCalculatedDataQuality") map { _.as[Float]}
}

      

sealed trait LABELSecurityLevelEnum

object LABELSecurityLevelEnum {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[nu.ndw.LABELSecurityLevelEnum]): LABELSecurityLevelEnum = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: LABELSecurityLevelEnum) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
}

case object NoneTypeValue6 extends LABELSecurityLevelEnum { override def toString = "none" }
case object SecurityLevel1 extends LABELSecurityLevelEnum { override def toString = "securityLevel1" }
case object SecurityLevel2 extends LABELSecurityLevelEnum { override def toString = "securityLevel2" }
case object SecurityLevel3 extends LABELSecurityLevelEnum { override def toString = "securityLevel3" }
case object SecurityLevel4 extends LABELSecurityLevelEnum { override def toString = "securityLevel4" }
case object SecurityLevel5 extends LABELSecurityLevelEnum { override def toString = "securityLevel5" }
case object UnknownValue35 extends LABELSecurityLevelEnum { override def toString = "unknown" }

sealed trait LABELServiceLevelEnum

object LABELServiceLevelEnum {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[nu.ndw.LABELServiceLevelEnum]): LABELServiceLevelEnum = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: LABELServiceLevelEnum) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
}

case object NoneTypeValue3 extends LABELServiceLevelEnum { override def toString = "none" }
case object ServiceLevel1 extends LABELServiceLevelEnum { override def toString = "serviceLevel1" }
case object ServiceLevel2 extends LABELServiceLevelEnum { override def toString = "serviceLevel2" }
case object ServiceLevel3 extends LABELServiceLevelEnum { override def toString = "serviceLevel3" }
case object ServiceLevel4 extends LABELServiceLevelEnum { override def toString = "serviceLevel4" }
case object ServiceLevel5 extends LABELServiceLevelEnum { override def toString = "serviceLevel5" }
case object UnknownValue20 extends LABELServiceLevelEnum { override def toString = "unknown" }

sealed trait LaneEnum

object LaneEnum {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[nu.ndw.LaneEnum]): LaneEnum = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: LaneEnum) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
}

case object AllLanesCompleteCarriageway extends LaneEnum { override def toString = "allLanesCompleteCarriageway" }
case object BusLane extends LaneEnum { override def toString = "busLane" }
case object BusStop extends LaneEnum { override def toString = "busStop" }
case object CarPoolLane extends LaneEnum { override def toString = "carPoolLane" }
case object CentralReservation extends LaneEnum { override def toString = "centralReservation" }
case object CrawlerLane extends LaneEnum { override def toString = "crawlerLane" }
case object EmergencyLane extends LaneEnum { override def toString = "emergencyLane" }
case object EscapeLane extends LaneEnum { override def toString = "escapeLane" }
case object ExpressLane extends LaneEnum { override def toString = "expressLane" }
case object HardShoulder extends LaneEnum { override def toString = "hardShoulder" }
case object HeavyVehicleLane extends LaneEnum { override def toString = "heavyVehicleLane" }
case object Lane1 extends LaneEnum { override def toString = "lane1" }
case object Lane2 extends LaneEnum { override def toString = "lane2" }
case object Lane3 extends LaneEnum { override def toString = "lane3" }
case object Lane4 extends LaneEnum { override def toString = "lane4" }
case object Lane5 extends LaneEnum { override def toString = "lane5" }
case object Lane6 extends LaneEnum { override def toString = "lane6" }
case object Lane7 extends LaneEnum { override def toString = "lane7" }
case object Lane8 extends LaneEnum { override def toString = "lane8" }
case object Lane9 extends LaneEnum { override def toString = "lane9" }
case object LayByValue extends LaneEnum { override def toString = "layBy" }
case object LeftHandTurningLane extends LaneEnum { override def toString = "leftHandTurningLane" }
case object LeftLane extends LaneEnum { override def toString = "leftLane" }
case object LocalTrafficLane extends LaneEnum { override def toString = "localTrafficLane" }
case object MiddleLane extends LaneEnum { override def toString = "middleLane" }
case object OpposingLanes extends LaneEnum { override def toString = "opposingLanes" }
case object OvertakingLane extends LaneEnum { override def toString = "overtakingLane" }
case object RightHandTurningLane extends LaneEnum { override def toString = "rightHandTurningLane" }
case object RightLane extends LaneEnum { override def toString = "rightLane" }
case object RushHourLane extends LaneEnum { override def toString = "rushHourLane" }
case object SetDownArea extends LaneEnum { override def toString = "setDownArea" }
case object SlowVehicleLane extends LaneEnum { override def toString = "slowVehicleLane" }
case object ThroughTrafficLane extends LaneEnum { override def toString = "throughTrafficLane" }
case object TidalFlowLane extends LaneEnum { override def toString = "tidalFlowLane" }
case object TurningLane extends LaneEnum { override def toString = "turningLane" }
case object Verge extends LaneEnum { override def toString = "verge" }



case class LengthCharacteristic(comparisonOperator: nu.ndw.ComparisonOperatorEnum,
  vehicleLength: Float,
  lengthCharacteristicExtension: Option[nu.ndw._ExtensionType] = None)
      



case class LifeCycleManagement(cancel: Option[Boolean] = None,
  end: Option[Boolean] = None,
  lifeCycleManagementExtension: Option[nu.ndw._ExtensionType] = None)
      



case class Linear(groupOfLocationsExtension: Option[nu.ndw._ExtensionType] = None,
  externalReferencing: Seq[nu.ndw.ExternalReferencing] = Nil,
  locationForDisplay: Option[nu.ndw.PointCoordinates] = None,
  locationExtension: Option[nu.ndw._ExtensionType] = None,
  supplementaryPositionalDescription: Option[nu.ndw.SupplementaryPositionalDescription] = None,
  destination: Option[nu.ndw.Destination] = None,
  networkLocationExtension: Option[nu.ndw._ExtensionType] = None,
  tpegLinearLocation: Option[nu.ndw.TpegLinearLocation] = None,
  alertCLinear: Option[nu.ndw.AlertCLinear] = None,
  linearWithinLinearElement: Option[nu.ndw.LinearWithinLinearElement] = None,
  linearExtension: Option[nu.ndw._LinearExtensionType] = None) extends NetworkLocation
      


sealed trait LinearElementable {
  def roadName: Option[nu.ndw.MultilingualString]
  def roadNumber: Option[String]
  def linearElementReferenceModel: Option[String]
  def linearElementReferenceModelVersion: Option[String]
  def linearElementNature: Option[nu.ndw.LinearElementNatureEnum]
  def linearElementExtension: Option[nu.ndw._ExtensionType]
}



case class LinearElement(roadName: Option[nu.ndw.MultilingualString] = None,
  roadNumber: Option[String] = None,
  linearElementReferenceModel: Option[String] = None,
  linearElementReferenceModelVersion: Option[String] = None,
  linearElementNature: Option[nu.ndw.LinearElementNatureEnum] = None,
  linearElementExtension: Option[nu.ndw._ExtensionType] = None) extends LinearElementable
      



case class LinearElementByCode(roadName: Option[nu.ndw.MultilingualString] = None,
  roadNumber: Option[String] = None,
  linearElementReferenceModel: Option[String] = None,
  linearElementReferenceModelVersion: Option[String] = None,
  linearElementNature: Option[nu.ndw.LinearElementNatureEnum] = None,
  linearElementExtension: Option[nu.ndw._ExtensionType] = None,
  linearElementIdentifier: String,
  linearElementByCodeExtension: Option[nu.ndw._ExtensionType] = None) extends LinearElementable
      



case class LinearElementByPoints(roadName: Option[nu.ndw.MultilingualString] = None,
  roadNumber: Option[String] = None,
  linearElementReferenceModel: Option[String] = None,
  linearElementReferenceModelVersion: Option[String] = None,
  linearElementNature: Option[nu.ndw.LinearElementNatureEnum] = None,
  linearElementExtension: Option[nu.ndw._ExtensionType] = None,
  startPointOfLinearElement: nu.ndw.Referent,
  intermediatePointOnLinearElement: Seq[nu.ndw._IntermediatePointOnLinearElement] = Nil,
  endPointOfLinearElement: nu.ndw.Referent,
  linearElementByPointsExtension: Option[nu.ndw._ExtensionType] = None) extends LinearElementable
      

sealed trait LinearElementNatureEnum

object LinearElementNatureEnum {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[nu.ndw.LinearElementNatureEnum]): LinearElementNatureEnum = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: LinearElementNatureEnum) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
}

case object Road extends LinearElementNatureEnum { override def toString = "road" }
case object RoadSection extends LinearElementNatureEnum { override def toString = "roadSection" }
case object SlipRoadValue extends LinearElementNatureEnum { override def toString = "slipRoad" }
case object OtherValue62 extends LinearElementNatureEnum { override def toString = "other" }

sealed trait LinearReferencingDirectionEnum

object LinearReferencingDirectionEnum {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[nu.ndw.LinearReferencingDirectionEnum]): LinearReferencingDirectionEnum = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: LinearReferencingDirectionEnum) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
}

case object BothValue extends LinearReferencingDirectionEnum { override def toString = "both" }
case object Opposite extends LinearReferencingDirectionEnum { override def toString = "opposite" }
case object Aligned extends LinearReferencingDirectionEnum { override def toString = "aligned" }
case object UnknownValue19 extends LinearReferencingDirectionEnum { override def toString = "unknown" }



case class LinearTrafficView(linearPredefinedLocationReference: nu.ndw._PredefinedLocationVersionedReference,
  trafficViewRecord: Seq[nu.ndw.TrafficViewRecord] = Nil,
  linearTrafficViewExtension: Option[nu.ndw._ExtensionType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  @JsonIgnore lazy val id = attributes("@id").as[String]
}

      



case class LinearWithinLinearElement(administrativeAreaOfLinearSection: Option[nu.ndw.MultilingualString] = None,
  directionBoundOnLinearSection: Option[nu.ndw.DirectionEnum] = None,
  directionRelativeOnLinearSection: Option[nu.ndw.LinearReferencingDirectionEnum] = None,
  heightGradeOfLinearSection: Option[nu.ndw.HeightGradeEnum] = None,
  linearElement: nu.ndw.LinearElementable,
  fromPoint: nu.ndw.DistanceAlongLinearElement,
  toPoint: nu.ndw.DistanceAlongLinearElement,
  linearWithinLinearElementExtension: Option[nu.ndw._ExtensionType] = None)
      

sealed trait LoadType2Enum

object LoadType2Enum {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[nu.ndw.LoadType2Enum]): LoadType2Enum = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: LoadType2Enum) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
}

case object RefrigeratedGoods extends LoadType2Enum { override def toString = "refrigeratedGoods" }

sealed trait LoadTypeEnum

object LoadTypeEnum {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[nu.ndw.LoadTypeEnum]): LoadTypeEnum = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: LoadTypeEnum) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
}

case object AbnormalLoadValue extends LoadTypeEnum { override def toString = "abnormalLoad" }
case object Ammunition extends LoadTypeEnum { override def toString = "ammunition" }
case object Chemicals extends LoadTypeEnum { override def toString = "chemicals" }
case object CombustibleMaterials extends LoadTypeEnum { override def toString = "combustibleMaterials" }
case object CorrosiveMaterials extends LoadTypeEnum { override def toString = "corrosiveMaterials" }
case object DebrisValue extends LoadTypeEnum { override def toString = "debris" }
case object Empty extends LoadTypeEnum { override def toString = "empty" }
case object ExplosiveMaterials extends LoadTypeEnum { override def toString = "explosiveMaterials" }
case object ExtraHighLoad extends LoadTypeEnum { override def toString = "extraHighLoad" }
case object ExtraLongLoad extends LoadTypeEnum { override def toString = "extraLongLoad" }
case object ExtraWideLoad extends LoadTypeEnum { override def toString = "extraWideLoad" }
case object Fuel extends LoadTypeEnum { override def toString = "fuel" }
case object Glass extends LoadTypeEnum { override def toString = "glass" }
case object Goods extends LoadTypeEnum { override def toString = "goods" }
case object HazardousMaterials extends LoadTypeEnum { override def toString = "hazardousMaterials" }
case object Liquid extends LoadTypeEnum { override def toString = "liquid" }
case object Livestock extends LoadTypeEnum { override def toString = "livestock" }
case object Materials extends LoadTypeEnum { override def toString = "materials" }
case object MaterialsDangerousForPeople extends LoadTypeEnum { override def toString = "materialsDangerousForPeople" }
case object MaterialsDangerousForTheEnvironment extends LoadTypeEnum { override def toString = "materialsDangerousForTheEnvironment" }
case object MaterialsDangerousForWater extends LoadTypeEnum { override def toString = "materialsDangerousForWater" }
case object Oil extends LoadTypeEnum { override def toString = "oil" }
case object Ordinary extends LoadTypeEnum { override def toString = "ordinary" }
case object PerishableProducts extends LoadTypeEnum { override def toString = "perishableProducts" }
case object Petrol extends LoadTypeEnum { override def toString = "petrol" }
case object PharmaceuticalMaterials extends LoadTypeEnum { override def toString = "pharmaceuticalMaterials" }
case object RadioactiveMaterials extends LoadTypeEnum { override def toString = "radioactiveMaterials" }
case object Refuse extends LoadTypeEnum { override def toString = "refuse" }
case object ToxicMaterials extends LoadTypeEnum { override def toString = "toxicMaterials" }
case object Vehicles extends LoadTypeEnum { override def toString = "vehicles" }
case object OtherValue34 extends LoadTypeEnum { override def toString = "other" }


sealed trait Location extends GroupOfLocations {
  def groupOfLocationsExtension: Option[nu.ndw._ExtensionType]
  def externalReferencing: Seq[nu.ndw.ExternalReferencing]
  def locationForDisplay: Option[nu.ndw.PointCoordinates]
  def locationExtension: Option[nu.ndw._ExtensionType]
}



case class LocationByReference(groupOfLocationsExtension: Option[nu.ndw._ExtensionType] = None,
  externalReferencing: Seq[nu.ndw.ExternalReferencing] = Nil,
  locationForDisplay: Option[nu.ndw.PointCoordinates] = None,
  locationExtension: Option[nu.ndw._ExtensionType] = None,
  predefinedLocationReference: nu.ndw._PredefinedLocationVersionedReference,
  locationByReferenceExtension: Option[nu.ndw._ExtensionType] = None) extends Location
      



case class LocationCharacteristicsOverride(measurementLanesOverride: Option[nu.ndw.LaneEnum] = None,
  reversedFlow: Option[Boolean] = None,
  locationCharacteristicsOverrideExtension: Option[nu.ndw._ExtensionType] = None)
      

sealed trait LocationDescriptorEnum

object LocationDescriptorEnum {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[nu.ndw.LocationDescriptorEnum]): LocationDescriptorEnum = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: LocationDescriptorEnum) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
}

case object AroundABendInRoad extends LocationDescriptorEnum { override def toString = "aroundABendInRoad" }
case object AtMotorwayInterchange extends LocationDescriptorEnum { override def toString = "atMotorwayInterchange" }
case object AtRestArea extends LocationDescriptorEnum { override def toString = "atRestArea" }
case object AtServiceArea extends LocationDescriptorEnum { override def toString = "atServiceArea" }
case object AtTollPlaza extends LocationDescriptorEnum { override def toString = "atTollPlaza" }
case object AtTunnelEntryOrExit extends LocationDescriptorEnum { override def toString = "atTunnelEntryOrExit" }
case object Inbound extends LocationDescriptorEnum { override def toString = "inbound" }
case object InGallery extends LocationDescriptorEnum { override def toString = "inGallery" }
case object InTheCentre extends LocationDescriptorEnum { override def toString = "inTheCentre" }
case object InTheOppositeDirection extends LocationDescriptorEnum { override def toString = "inTheOppositeDirection" }
case object InTunnel extends LocationDescriptorEnum { override def toString = "inTunnel" }
case object OnBorder extends LocationDescriptorEnum { override def toString = "onBorder" }
case object OnBridge extends LocationDescriptorEnum { override def toString = "onBridge" }
case object OnConnector extends LocationDescriptorEnum { override def toString = "onConnector" }
case object OnElevatedSection extends LocationDescriptorEnum { override def toString = "onElevatedSection" }
case object OnFlyover extends LocationDescriptorEnum { override def toString = "onFlyover" }
case object OnIceRoad extends LocationDescriptorEnum { override def toString = "onIceRoad" }
case object OnLevelCrossing extends LocationDescriptorEnum { override def toString = "onLevelCrossing" }
case object OnLinkRoad extends LocationDescriptorEnum { override def toString = "onLinkRoad" }
case object OnPass extends LocationDescriptorEnum { override def toString = "onPass" }
case object OnRoundabout extends LocationDescriptorEnum { override def toString = "onRoundabout" }
case object OnTheLeft extends LocationDescriptorEnum { override def toString = "onTheLeft" }
case object OnTheRight extends LocationDescriptorEnum { override def toString = "onTheRight" }
case object OnTheRoadway extends LocationDescriptorEnum { override def toString = "onTheRoadway" }
case object OnUndergroundSection extends LocationDescriptorEnum { override def toString = "onUndergroundSection" }
case object OnUnderpass extends LocationDescriptorEnum { override def toString = "onUnderpass" }
case object Outbound extends LocationDescriptorEnum { override def toString = "outbound" }
case object OverCrestOfHill extends LocationDescriptorEnum { override def toString = "overCrestOfHill" }
case object WithinJunction extends LocationDescriptorEnum { override def toString = "withinJunction" }

sealed trait MaintenanceVehicleActionsEnum

object MaintenanceVehicleActionsEnum {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[nu.ndw.MaintenanceVehicleActionsEnum]): MaintenanceVehicleActionsEnum = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: MaintenanceVehicleActionsEnum) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
}

case object MaintenanceVehiclesMergingIntoTrafficFlow extends MaintenanceVehicleActionsEnum { override def toString = "maintenanceVehiclesMergingIntoTrafficFlow" }
case object SaltAndGritSpreading extends MaintenanceVehicleActionsEnum { override def toString = "saltAndGritSpreading" }
case object SlowMoving extends MaintenanceVehicleActionsEnum { override def toString = "slowMoving" }
case object SnowClearing extends MaintenanceVehicleActionsEnum { override def toString = "snowClearing" }
case object StoppingToServiceEquipments extends MaintenanceVehicleActionsEnum { override def toString = "stoppingToServiceEquipments" }



case class MaintenanceVehicles(numberOfMaintenanceVehicles: Option[Int] = None,
  maintenanceVehicleActions: Seq[nu.ndw.MaintenanceVehicleActionsEnum] = Nil,
  maintenanceVehiclesExtension: Option[nu.ndw._ExtensionType] = None)
      



case class MaintenanceWorks(situationRecordCreationReference: Option[String] = None,
  situationRecordCreationTime: javax.xml.datatype.XMLGregorianCalendar,
  situationRecordObservationTime: Option[javax.xml.datatype.XMLGregorianCalendar] = None,
  situationRecordVersionTime: javax.xml.datatype.XMLGregorianCalendar,
  situationRecordFirstSupplierVersionTime: Option[javax.xml.datatype.XMLGregorianCalendar] = None,
  confidentialityOverride: Option[nu.ndw.ConfidentialityValueEnum] = None,
  probabilityOfOccurrence: nu.ndw.ProbabilityOfOccurrenceEnum,
  severity: Option[nu.ndw.SeverityEnum] = None,
  source: Option[nu.ndw.Source] = None,
  validity: nu.ndw.Validity,
  impact: Option[nu.ndw.Impact] = None,
  cause: Option[nu.ndw.Cause] = None,
  generalPublicComment: Seq[nu.ndw.Comment] = Nil,
  nonGeneralPublicComment: Seq[nu.ndw.Comment] = Nil,
  urlLink: Seq[nu.ndw.UrlLink] = Nil,
  groupOfLocations: nu.ndw.GroupOfLocations,
  management: Option[nu.ndw.Management] = None,
  situationRecordExtension: Option[nu.ndw._SituationRecordExtensionType] = None,
  actionOrigin: Option[nu.ndw.OperatorActionOriginEnum] = None,
  actionPlanIdentifier: Option[String] = None,
  operatorActionStatus: Option[nu.ndw.OperatorActionStatusEnum] = None,
  operatorActionExtension: Option[nu.ndw._ExtensionType] = None,
  roadworksDuration: Option[nu.ndw.RoadworksDurationEnum] = None,
  roadworksScale: Option[nu.ndw.RoadworksScaleEnum] = None,
  underTraffic: Option[Boolean] = None,
  urgentRoadworks: Option[Boolean] = None,
  mobility: Option[nu.ndw.Mobility] = None,
  subjects: Option[nu.ndw.Subjects] = None,
  maintenanceVehicles: Option[nu.ndw.MaintenanceVehicles] = None,
  roadworksExtension: Option[nu.ndw._ExtensionType] = None,
  roadMaintenanceType: Seq[nu.ndw.RoadMaintenanceTypeEnum] = Nil,
  maintenanceWorksExtension: Option[nu.ndw._ExtensionType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) extends RoadworksType {
  @JsonIgnore lazy val id = attributes("@id").as[String]
  @JsonIgnore lazy val version = attributes("@version").as[String]
}

      



case class ManagedCause(causeExtension: Option[nu.ndw._ExtensionType] = None,
  managedCause: Option[nu.ndw._SituationRecordVersionedReference] = None,
  managedCauseExtension: Option[nu.ndw._ExtensionType] = None) extends Cause
      



case class Management(lifeCycleManagement: Option[nu.ndw.LifeCycleManagement] = None,
  filterExitManagement: Option[nu.ndw.FilterExitManagement] = None,
  managementExtension: Option[nu.ndw._ExtensionType] = None)
      

sealed trait MeansOfPaymentEnum

object MeansOfPaymentEnum {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[nu.ndw.MeansOfPaymentEnum]): MeansOfPaymentEnum = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: MeansOfPaymentEnum) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
}

case object PaymentCard extends MeansOfPaymentEnum { override def toString = "paymentCard" }
case object Cash extends MeansOfPaymentEnum { override def toString = "cash" }
case object CashCoinsOnly extends MeansOfPaymentEnum { override def toString = "cashCoinsOnly" }
case object DirectCashTransfer extends MeansOfPaymentEnum { override def toString = "directCashTransfer" }
case object ElectronicSettlement extends MeansOfPaymentEnum { override def toString = "electronicSettlement" }
case object Rfid extends MeansOfPaymentEnum { override def toString = "rfid" }
case object MobileApp extends MeansOfPaymentEnum { override def toString = "mobileApp" }
case object PayBySMS extends MeansOfPaymentEnum { override def toString = "payBySMS" }
case object MobilePhone extends MeansOfPaymentEnum { override def toString = "mobilePhone" }
case object UnknownValue18 extends MeansOfPaymentEnum { override def toString = "unknown" }
case object OtherValue33 extends MeansOfPaymentEnum { override def toString = "other" }



case class MeasuredDataPublication(feedDescription: Option[nu.ndw.MultilingualString] = None,
  feedType: Option[String] = None,
  publicationTime: javax.xml.datatype.XMLGregorianCalendar,
  publicationCreator: nu.ndw.InternationalIdentifier,
  payloadPublicationExtension: Option[nu.ndw._ExtensionType] = None,
  measurementSiteTableReference: nu.ndw._MeasurementSiteTableVersionedReference,
  headerInformation: nu.ndw.HeaderInformation,
  siteMeasurements: Seq[nu.ndw.SiteMeasurements] = Nil,
  measuredDataPublicationExtension: Option[nu.ndw._ExtensionType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) extends PayloadPublication {
  @JsonIgnore lazy val lang = attributes("@lang").as[String]
}

      

sealed trait MeasuredOrDerivedDataTypeEnum

object MeasuredOrDerivedDataTypeEnum {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[nu.ndw.MeasuredOrDerivedDataTypeEnum]): MeasuredOrDerivedDataTypeEnum = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: MeasuredOrDerivedDataTypeEnum) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
}

case object HumidityInformation extends MeasuredOrDerivedDataTypeEnum { override def toString = "humidityInformation" }
case object IndividualVehicleMeasurements extends MeasuredOrDerivedDataTypeEnum { override def toString = "individualVehicleMeasurements" }
case object PollutionInformation extends MeasuredOrDerivedDataTypeEnum { override def toString = "pollutionInformation" }
case object PrecipitationInformationValue extends MeasuredOrDerivedDataTypeEnum { override def toString = "precipitationInformation" }
case object PressureInformation extends MeasuredOrDerivedDataTypeEnum { override def toString = "pressureInformation" }
case object RadiationInformation extends MeasuredOrDerivedDataTypeEnum { override def toString = "radiationInformation" }
case object RoadSurfaceConditionInformation extends MeasuredOrDerivedDataTypeEnum { override def toString = "roadSurfaceConditionInformation" }
case object TemperatureInformation extends MeasuredOrDerivedDataTypeEnum { override def toString = "temperatureInformation" }
case object TrafficConcentration extends MeasuredOrDerivedDataTypeEnum { override def toString = "trafficConcentration" }
case object TrafficFlow extends MeasuredOrDerivedDataTypeEnum { override def toString = "trafficFlow" }
case object TrafficHeadway extends MeasuredOrDerivedDataTypeEnum { override def toString = "trafficHeadway" }
case object TrafficSpeedValue extends MeasuredOrDerivedDataTypeEnum { override def toString = "trafficSpeed" }
case object TrafficStatusInformation extends MeasuredOrDerivedDataTypeEnum { override def toString = "trafficStatusInformation" }
case object TravelTimeInformation extends MeasuredOrDerivedDataTypeEnum { override def toString = "travelTimeInformation" }
case object VisibilityInformationValue extends MeasuredOrDerivedDataTypeEnum { override def toString = "visibilityInformation" }
case object WindInformationValue extends MeasuredOrDerivedDataTypeEnum { override def toString = "windInformation" }



case class MeasuredValue(measurementEquipmentTypeUsed: Option[nu.ndw.MultilingualString] = None,
  locationCharacteristicsOverride: Option[nu.ndw.LocationCharacteristicsOverride] = None,
  measurementEquipmentFault: Seq[nu.ndw.MeasurementEquipmentFault] = Nil,
  basicData: Option[nu.ndw.BasicData] = None,
  measuredValueExtension: Option[nu.ndw._ExtensionType] = None)
      



case class MeasurementEquipmentFault(faultIdentifier: Option[String] = None,
  faultDescription: Option[String] = None,
  faultCreationTime: Option[javax.xml.datatype.XMLGregorianCalendar] = None,
  faultLastUpdateTime: javax.xml.datatype.XMLGregorianCalendar,
  faultSeverity: Option[nu.ndw.FaultSeverityEnum] = None,
  faultExtension: Option[nu.ndw._ExtensionType] = None,
  measurementEquipmentFault: nu.ndw.MeasurementEquipmentFaultEnum,
  measurementEquipmentFaultExtension: Option[nu.ndw._ExtensionType] = None) extends Faultable
      

sealed trait MeasurementEquipmentFaultEnum

object MeasurementEquipmentFaultEnum {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[nu.ndw.MeasurementEquipmentFaultEnum]): MeasurementEquipmentFaultEnum = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: MeasurementEquipmentFaultEnum) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
}

case object IntermittentDataValuesValue extends MeasurementEquipmentFaultEnum { override def toString = "intermittentDataValues" }
case object NoDataValuesAvailableValue extends MeasurementEquipmentFaultEnum { override def toString = "noDataValuesAvailable" }
case object SpuriousUnreliableDataValuesValue extends MeasurementEquipmentFaultEnum { override def toString = "spuriousUnreliableDataValues" }
case object UnspecifiedOrUnknownFaultValue extends MeasurementEquipmentFaultEnum { override def toString = "unspecifiedOrUnknownFault" }
case object OtherValue63 extends MeasurementEquipmentFaultEnum { override def toString = "other" }



case class MeasurementSiteRecord(measurementSiteRecordVersionTime: Option[javax.xml.datatype.XMLGregorianCalendar] = None,
  computationMethod: Option[nu.ndw.ComputationMethodEnum] = None,
  measurementEquipmentReference: Option[String] = None,
  measurementEquipmentTypeUsed: Option[nu.ndw.MultilingualString] = None,
  measurementSiteName: Option[nu.ndw.MultilingualString] = None,
  measurementSiteNumberOfLanes: Option[Int] = None,
  measurementSiteIdentification: Option[String] = None,
  measurementSide: Option[nu.ndw.DirectionEnum] = None,
  measurementSpecificCharacteristics: Seq[nu.ndw._MeasurementSiteRecordIndexMeasurementSpecificCharacteristics] = Nil,
  measurementSiteLocation: nu.ndw.GroupOfLocations,
  measurementSiteRecordExtension: Option[nu.ndw._ExtensionType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  @JsonIgnore lazy val id = attributes("@id").as[String]
  @JsonIgnore lazy val version = attributes("@version").as[String]
}

      



case class MeasurementSiteTable(measurementSiteTableIdentification: Option[String] = None,
  measurementSiteRecord: Seq[nu.ndw.MeasurementSiteRecord] = Nil,
  measurementSiteTableExtension: Option[nu.ndw._ExtensionType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  @JsonIgnore lazy val id = attributes("@id").as[String]
  @JsonIgnore lazy val version = attributes("@version").as[String]
}

      



case class MeasurementSiteTablePublication(feedDescription: Option[nu.ndw.MultilingualString] = None,
  feedType: Option[String] = None,
  publicationTime: javax.xml.datatype.XMLGregorianCalendar,
  publicationCreator: nu.ndw.InternationalIdentifier,
  payloadPublicationExtension: Option[nu.ndw._ExtensionType] = None,
  headerInformation: nu.ndw.HeaderInformation,
  measurementSiteTable: Seq[nu.ndw.MeasurementSiteTable] = Nil,
  measurementSiteTablePublicationExtension: Option[nu.ndw._ExtensionType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) extends PayloadPublication {
  @JsonIgnore lazy val lang = attributes("@lang").as[String]
}

      



case class MeasurementSpecificCharacteristics(accuracy: Option[Float] = None,
  period: Option[Float] = None,
  smoothingFactor: Option[Float] = None,
  specificLane: Option[nu.ndw.LaneEnum] = None,
  specificMeasurementValueType: nu.ndw.MeasuredOrDerivedDataTypeEnum,
  specificVehicleCharacteristics: Option[nu.ndw.VehicleCharacteristics] = None,
  measurementSpecificCharacteristicsExtension: Option[nu.ndw._ExtensionType] = None)
      



case class MicrogramsConcentrationValue(dataError: Option[Boolean] = None,
  reasonForDataError: Option[nu.ndw.MultilingualString] = None,
  dataValueExtension: Option[nu.ndw._ExtensionType] = None,
  microgramsConcentration: Float,
  microgramsConcentrationValueExtension: Option[nu.ndw._ExtensionType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) extends DataValue {
  @JsonIgnore lazy val accuracy = attributes.get("@accuracy") map { _.as[Float]}
  @JsonIgnore lazy val computationalMethod = attributes.get("@computationalMethod") map { _.as[ComputationMethodEnum]}
  @JsonIgnore lazy val numberOfIncompleteInputs = attributes.get("@numberOfIncompleteInputs") map { _.as[Int]}
  @JsonIgnore lazy val numberOfInputValuesUsed = attributes.get("@numberOfInputValuesUsed") map { _.as[Int]}
  @JsonIgnore lazy val smoothingFactor = attributes.get("@smoothingFactor") map { _.as[Float]}
  @JsonIgnore lazy val standardDeviation = attributes.get("@standardDeviation") map { _.as[Float]}
  @JsonIgnore lazy val supplierCalculatedDataQuality = attributes.get("@supplierCalculatedDataQuality") map { _.as[Float]}
}

      



case class Mobility(mobilityType: nu.ndw.MobilityEnum,
  mobilityExtension: Option[nu.ndw._ExtensionType] = None)
      

sealed trait MobilityEnum

object MobilityEnum {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[nu.ndw.MobilityEnum]): MobilityEnum = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: MobilityEnum) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
}

case object Mobile extends MobilityEnum { override def toString = "mobile" }
case object Stationary extends MobilityEnum { override def toString = "stationary" }
case object UnknownValue17 extends MobilityEnum { override def toString = "unknown" }

sealed trait MonthOfYearEnum

object MonthOfYearEnum {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[nu.ndw.MonthOfYearEnum]): MonthOfYearEnum = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: MonthOfYearEnum) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
}

case object January extends MonthOfYearEnum { override def toString = "january" }
case object February extends MonthOfYearEnum { override def toString = "february" }
case object MarchValue extends MonthOfYearEnum { override def toString = "march" }
case object April extends MonthOfYearEnum { override def toString = "april" }
case object May extends MonthOfYearEnum { override def toString = "may" }
case object June extends MonthOfYearEnum { override def toString = "june" }
case object July extends MonthOfYearEnum { override def toString = "july" }
case object August extends MonthOfYearEnum { override def toString = "august" }
case object September extends MonthOfYearEnum { override def toString = "september" }
case object October extends MonthOfYearEnum { override def toString = "october" }
case object November extends MonthOfYearEnum { override def toString = "november" }
case object December extends MonthOfYearEnum { override def toString = "december" }


@JsonIgnoreProperties(Array("value"))
case class Values(value: Seq[nu.ndw.MultilingualStringValue] = Nil)
      



case class MultilingualString(values: nu.ndw.Values)
      



case class MultilingualStringValue(value: String, attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  @JsonIgnore lazy val lang = attributes.get("@lang") map { _.as[String]}
}

      



case class NamedArea(country: Option[nu.ndw.CountryEnum] = None,
  nation: Option[nu.ndw.MultilingualString] = None,
  county: Option[nu.ndw.MultilingualString] = None,
  areaName: Option[nu.ndw.MultilingualString] = None,
  policeForceControlArea: Option[nu.ndw.MultilingualString] = None,
  roadOperatorControlArea: Option[nu.ndw.MultilingualString] = None,
  namedAreaExtension: Option[nu.ndw._ExtensionType] = None)
      


sealed trait NetworkLocation extends Location {
  def groupOfLocationsExtension: Option[nu.ndw._ExtensionType]
  def externalReferencing: Seq[nu.ndw.ExternalReferencing]
  def locationForDisplay: Option[nu.ndw.PointCoordinates]
  def locationExtension: Option[nu.ndw._ExtensionType]
  def supplementaryPositionalDescription: Option[nu.ndw.SupplementaryPositionalDescription]
  def destination: Option[nu.ndw.Destination]
  def networkLocationExtension: Option[nu.ndw._ExtensionType]
}


sealed trait NetworkManagement extends OperatorActionable {
  def situationRecordCreationReference: Option[String]
  def situationRecordCreationTime: javax.xml.datatype.XMLGregorianCalendar
  def situationRecordObservationTime: Option[javax.xml.datatype.XMLGregorianCalendar]
  def situationRecordVersionTime: javax.xml.datatype.XMLGregorianCalendar
  def situationRecordFirstSupplierVersionTime: Option[javax.xml.datatype.XMLGregorianCalendar]
  def confidentialityOverride: Option[nu.ndw.ConfidentialityValueEnum]
  def probabilityOfOccurrence: nu.ndw.ProbabilityOfOccurrenceEnum
  def severity: Option[nu.ndw.SeverityEnum]
  def source: Option[nu.ndw.Source]
  def validity: nu.ndw.Validity
  def impact: Option[nu.ndw.Impact]
  def cause: Option[nu.ndw.Cause]
  def generalPublicComment: Seq[nu.ndw.Comment]
  def nonGeneralPublicComment: Seq[nu.ndw.Comment]
  def urlLink: Seq[nu.ndw.UrlLink]
  def groupOfLocations: nu.ndw.GroupOfLocations
  def management: Option[nu.ndw.Management]
  def situationRecordExtension: Option[nu.ndw._SituationRecordExtensionType]
  def actionOrigin: Option[nu.ndw.OperatorActionOriginEnum]
  def actionPlanIdentifier: Option[String]
  def operatorActionStatus: Option[nu.ndw.OperatorActionStatusEnum]
  def operatorActionExtension: Option[nu.ndw._ExtensionType]
  def complianceOption: nu.ndw.ComplianceOptionEnum
  def applicableForTrafficDirection: Seq[nu.ndw.DirectionEnum]
  def applicableForTrafficType: Seq[nu.ndw.TrafficTypeEnum]
  def placesAtWhichApplicable: Seq[nu.ndw.PlacesEnum]
  def automaticallyInitiated: Option[Boolean]
  def forVehiclesWithCharacteristicsOf: Seq[nu.ndw.VehicleCharacteristics]
  def networkManagementExtension: Option[nu.ndw._ExtensionType]
  def id: String
  def version: String
}



case class NonManagedCause(causeExtension: Option[nu.ndw._ExtensionType] = None,
  causeDescription: Option[nu.ndw.MultilingualString] = None,
  causeType: Option[nu.ndw.CauseTypeEnum] = None,
  nonManagedCauseExtension: Option[nu.ndw._ExtensionType] = None) extends Cause
      



case class NonOrderedLocationGroupByList(groupOfLocationsExtension: Option[nu.ndw._ExtensionType] = None,
  nonOrderedLocationsExtension: Option[nu.ndw._ExtensionType] = None,
  locationContainedInGroup: Seq[nu.ndw.Location] = Nil,
  nonOrderedLocationGroupByListExtension: Option[nu.ndw._ExtensionType] = None) extends NonOrderedLocations
      



case class NonOrderedLocationGroupByReference(groupOfLocationsExtension: Option[nu.ndw._ExtensionType] = None,
  nonOrderedLocationsExtension: Option[nu.ndw._ExtensionType] = None,
  predefinedNonOrderedLocationGroupReference: nu.ndw._PredefinedNonOrderedLocationGroupVersionedReference,
  nonOrderedLocationGroupByReferenceExtension: Option[nu.ndw._ExtensionType] = None) extends NonOrderedLocations
      


sealed trait NonOrderedLocations extends GroupOfLocations {
  def groupOfLocationsExtension: Option[nu.ndw._ExtensionType]
  def nonOrderedLocationsExtension: Option[nu.ndw._ExtensionType]
}


sealed trait NonRoadEventInformation extends SituationRecord {
  def situationRecordCreationReference: Option[String]
  def situationRecordCreationTime: javax.xml.datatype.XMLGregorianCalendar
  def situationRecordObservationTime: Option[javax.xml.datatype.XMLGregorianCalendar]
  def situationRecordVersionTime: javax.xml.datatype.XMLGregorianCalendar
  def situationRecordFirstSupplierVersionTime: Option[javax.xml.datatype.XMLGregorianCalendar]
  def confidentialityOverride: Option[nu.ndw.ConfidentialityValueEnum]
  def probabilityOfOccurrence: nu.ndw.ProbabilityOfOccurrenceEnum
  def severity: Option[nu.ndw.SeverityEnum]
  def source: Option[nu.ndw.Source]
  def validity: nu.ndw.Validity
  def impact: Option[nu.ndw.Impact]
  def cause: Option[nu.ndw.Cause]
  def generalPublicComment: Seq[nu.ndw.Comment]
  def nonGeneralPublicComment: Seq[nu.ndw.Comment]
  def urlLink: Seq[nu.ndw.UrlLink]
  def groupOfLocations: nu.ndw.GroupOfLocations
  def management: Option[nu.ndw.Management]
  def situationRecordExtension: Option[nu.ndw._SituationRecordExtensionType]
  def nonRoadEventInformationExtension: Option[nu.ndw._ExtensionType]
  def id: String
  def version: String
}



case class NonWeatherRelatedRoadConditions(situationRecordCreationReference: Option[String] = None,
  situationRecordCreationTime: javax.xml.datatype.XMLGregorianCalendar,
  situationRecordObservationTime: Option[javax.xml.datatype.XMLGregorianCalendar] = None,
  situationRecordVersionTime: javax.xml.datatype.XMLGregorianCalendar,
  situationRecordFirstSupplierVersionTime: Option[javax.xml.datatype.XMLGregorianCalendar] = None,
  confidentialityOverride: Option[nu.ndw.ConfidentialityValueEnum] = None,
  probabilityOfOccurrence: nu.ndw.ProbabilityOfOccurrenceEnum,
  severity: Option[nu.ndw.SeverityEnum] = None,
  source: Option[nu.ndw.Source] = None,
  validity: nu.ndw.Validity,
  impact: Option[nu.ndw.Impact] = None,
  cause: Option[nu.ndw.Cause] = None,
  generalPublicComment: Seq[nu.ndw.Comment] = Nil,
  nonGeneralPublicComment: Seq[nu.ndw.Comment] = Nil,
  urlLink: Seq[nu.ndw.UrlLink] = Nil,
  groupOfLocations: nu.ndw.GroupOfLocations,
  management: Option[nu.ndw.Management] = None,
  situationRecordExtension: Option[nu.ndw._SituationRecordExtensionType] = None,
  trafficElementExtension: Option[nu.ndw._ExtensionType] = None,
  drivingConditionType: Option[nu.ndw.DrivingConditionTypeEnum] = None,
  conditionsExtension: Option[nu.ndw._ExtensionType] = None,
  roadConditionsExtension: Option[nu.ndw._ExtensionType] = None,
  nonWeatherRelatedRoadConditionType: Seq[nu.ndw.NonWeatherRelatedRoadConditionTypeEnum] = Nil,
  nonWeatherRelatedRoadConditionsExtension: Option[nu.ndw._ExtensionType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) extends RoadConditions {
  @JsonIgnore lazy val id = attributes("@id").as[String]
  @JsonIgnore lazy val version = attributes("@version").as[String]
}

      

sealed trait NonWeatherRelatedRoadConditionTypeEnum

object NonWeatherRelatedRoadConditionTypeEnum {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[nu.ndw.NonWeatherRelatedRoadConditionTypeEnum]): NonWeatherRelatedRoadConditionTypeEnum = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: NonWeatherRelatedRoadConditionTypeEnum) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
}

case object DieselOnRoad extends NonWeatherRelatedRoadConditionTypeEnum { override def toString = "dieselOnRoad" }
case object LeavesOnRoad extends NonWeatherRelatedRoadConditionTypeEnum { override def toString = "leavesOnRoad" }
case object LooseChippings extends NonWeatherRelatedRoadConditionTypeEnum { override def toString = "looseChippings" }
case object LooseSandOnRoad extends NonWeatherRelatedRoadConditionTypeEnum { override def toString = "looseSandOnRoad" }
case object MudOnRoad extends NonWeatherRelatedRoadConditionTypeEnum { override def toString = "mudOnRoad" }
case object OilOnRoad extends NonWeatherRelatedRoadConditionTypeEnum { override def toString = "oilOnRoad" }
case object PetrolOnRoad extends NonWeatherRelatedRoadConditionTypeEnum { override def toString = "petrolOnRoad" }
case object RoadSurfaceInPoorCondition extends NonWeatherRelatedRoadConditionTypeEnum { override def toString = "roadSurfaceInPoorCondition" }
case object SlipperyRoadValue2 extends NonWeatherRelatedRoadConditionTypeEnum { override def toString = "slipperyRoad" }
case object OtherValue64 extends NonWeatherRelatedRoadConditionTypeEnum { override def toString = "other" }



case class NumberOfAxlesCharacteristic(comparisonOperator: nu.ndw.ComparisonOperatorEnum,
  numberOfAxles: Int,
  numberOfAxlesCharacteristicExtension: Option[nu.ndw._ExtensionType] = None)
      


sealed trait ObstructionType extends TrafficElement {
  def situationRecordCreationReference: Option[String]
  def situationRecordCreationTime: javax.xml.datatype.XMLGregorianCalendar
  def situationRecordObservationTime: Option[javax.xml.datatype.XMLGregorianCalendar]
  def situationRecordVersionTime: javax.xml.datatype.XMLGregorianCalendar
  def situationRecordFirstSupplierVersionTime: Option[javax.xml.datatype.XMLGregorianCalendar]
  def confidentialityOverride: Option[nu.ndw.ConfidentialityValueEnum]
  def probabilityOfOccurrence: nu.ndw.ProbabilityOfOccurrenceEnum
  def severity: Option[nu.ndw.SeverityEnum]
  def source: Option[nu.ndw.Source]
  def validity: nu.ndw.Validity
  def impact: Option[nu.ndw.Impact]
  def cause: Option[nu.ndw.Cause]
  def generalPublicComment: Seq[nu.ndw.Comment]
  def nonGeneralPublicComment: Seq[nu.ndw.Comment]
  def urlLink: Seq[nu.ndw.UrlLink]
  def groupOfLocations: nu.ndw.GroupOfLocations
  def management: Option[nu.ndw.Management]
  def situationRecordExtension: Option[nu.ndw._SituationRecordExtensionType]
  def trafficElementExtension: Option[nu.ndw._ExtensionType]
  def numberOfObstructions: Option[Int]
  def mobilityOfObstruction: Option[nu.ndw.Mobility]
  def obstructionExtension: Option[nu.ndw._ExtensionType]
  def id: String
  def version: String
}

sealed trait ObstructionTypeEnum

object ObstructionTypeEnum {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[nu.ndw.ObstructionTypeEnum]): ObstructionTypeEnum = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: ObstructionTypeEnum) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
}

case object AirCrash extends ObstructionTypeEnum { override def toString = "airCrash" }
case object ChildrenOnRoadway extends ObstructionTypeEnum { override def toString = "childrenOnRoadway" }
case object ClearanceWork extends ObstructionTypeEnum { override def toString = "clearanceWork" }
case object CraneOperating extends ObstructionTypeEnum { override def toString = "craneOperating" }
case object CyclistsOnRoadway extends ObstructionTypeEnum { override def toString = "cyclistsOnRoadway" }
case object Debris extends ObstructionTypeEnum { override def toString = "debris" }
case object Explosion extends ObstructionTypeEnum { override def toString = "explosion" }
case object ExplosionHazard extends ObstructionTypeEnum { override def toString = "explosionHazard" }
case object HazardsOnTheRoad extends ObstructionTypeEnum { override def toString = "hazardsOnTheRoad" }
case object HighSpeedChase extends ObstructionTypeEnum { override def toString = "highSpeedChase" }
case object HouseFire extends ObstructionTypeEnum { override def toString = "houseFire" }
case object Incident extends ObstructionTypeEnum { override def toString = "incident" }
case object IndustrialAccident extends ObstructionTypeEnum { override def toString = "industrialAccident" }
case object ObjectOnTheRoad extends ObstructionTypeEnum { override def toString = "objectOnTheRoad" }
case object ObjectsFallingFromMovingVehicle extends ObstructionTypeEnum { override def toString = "objectsFallingFromMovingVehicle" }
case object ObstructionOnTheRoad extends ObstructionTypeEnum { override def toString = "obstructionOnTheRoad" }
case object PeopleOnRoadway extends ObstructionTypeEnum { override def toString = "peopleOnRoadway" }
case object RailCrash extends ObstructionTypeEnum { override def toString = "railCrash" }
case object RecklessDriver extends ObstructionTypeEnum { override def toString = "recklessDriver" }
case object RescueAndRecoveryWork extends ObstructionTypeEnum { override def toString = "rescueAndRecoveryWork" }
case object SevereFrostDamagedRoadway extends ObstructionTypeEnum { override def toString = "severeFrostDamagedRoadway" }
case object ShedLoad extends ObstructionTypeEnum { override def toString = "shedLoad" }
case object SnowAndIceDebris extends ObstructionTypeEnum { override def toString = "snowAndIceDebris" }
case object SpillageOccurringFromMovingVehicle extends ObstructionTypeEnum { override def toString = "spillageOccurringFromMovingVehicle" }
case object SpillageOnTheRoad extends ObstructionTypeEnum { override def toString = "spillageOnTheRoad" }
case object UnprotectedAccidentArea extends ObstructionTypeEnum { override def toString = "unprotectedAccidentArea" }
case object OtherValue32 extends ObstructionTypeEnum { override def toString = "other" }



case class OccupancyChangeValue(dataError: Option[Boolean] = None,
  reasonForDataError: Option[nu.ndw.MultilingualString] = None,
  dataValueExtension: Option[nu.ndw._ExtensionType] = None,
  occupancyChange: Int,
  occupancyChangeValueExtension: Option[nu.ndw._ExtensionType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) extends DataValue {
  @JsonIgnore lazy val accuracy = attributes.get("@accuracy") map { _.as[Float]}
  @JsonIgnore lazy val computationalMethod = attributes.get("@computationalMethod") map { _.as[ComputationMethodEnum]}
  @JsonIgnore lazy val numberOfIncompleteInputs = attributes.get("@numberOfIncompleteInputs") map { _.as[Int]}
  @JsonIgnore lazy val numberOfInputValuesUsed = attributes.get("@numberOfInputValuesUsed") map { _.as[Int]}
  @JsonIgnore lazy val smoothingFactor = attributes.get("@smoothingFactor") map { _.as[Float]}
  @JsonIgnore lazy val standardDeviation = attributes.get("@standardDeviation") map { _.as[Float]}
  @JsonIgnore lazy val supplierCalculatedDataQuality = attributes.get("@supplierCalculatedDataQuality") map { _.as[Float]}
}

      

sealed trait OccupancyDetectionTypeEnum

object OccupancyDetectionTypeEnum {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[nu.ndw.OccupancyDetectionTypeEnum]): OccupancyDetectionTypeEnum = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: OccupancyDetectionTypeEnum) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
}

case object NoneTypeValue2 extends OccupancyDetectionTypeEnum { override def toString = "none" }
case object Balancing extends OccupancyDetectionTypeEnum { override def toString = "balancing" }
case object SingleSpaceDetection extends OccupancyDetectionTypeEnum { override def toString = "singleSpaceDetection" }
case object ModelBased extends OccupancyDetectionTypeEnum { override def toString = "modelBased" }
case object Manual extends OccupancyDetectionTypeEnum { override def toString = "manual" }
case object UnspecifiedValue2 extends OccupancyDetectionTypeEnum { override def toString = "unspecified" }
case object OtherValue31 extends OccupancyDetectionTypeEnum { override def toString = "other" }
case object UnknownValue16 extends OccupancyDetectionTypeEnum { override def toString = "unknown" }



case class OffsetDistance(offsetDistance: Int,
  offsetDistanceExtension: Option[nu.ndw._ExtensionType] = None)
      

sealed trait OpeningStatusEnum

object OpeningStatusEnum {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[nu.ndw.OpeningStatusEnum]): OpeningStatusEnum = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: OpeningStatusEnum) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
}

case object Open extends OpeningStatusEnum { override def toString = "open" }
case object Closed extends OpeningStatusEnum { override def toString = "closed" }
case object ClosedAbnormal extends OpeningStatusEnum { override def toString = "closedAbnormal" }
case object OpeningTimesInForce extends OpeningStatusEnum { override def toString = "openingTimesInForce" }
case object StatusUnknown extends OpeningStatusEnum { override def toString = "statusUnknown" }
case object OtherValue30 extends OpeningStatusEnum { override def toString = "other" }



case class OpeningTimes(lastUpdated: Option[javax.xml.datatype.XMLGregorianCalendar] = None,
  openAllYear: Option[Boolean] = None,
  available24hours: Option[Boolean] = None,
  urlLinkAddress: Option[java.net.URI] = None,
  openingTimesUnknown: Option[Boolean] = None,
  openingTimesNotSpecified: Option[Boolean] = None,
  validity: Option[nu.ndw.Validity] = None,
  openingTimesExtension: Option[nu.ndw._ExtensionType] = None)
      


sealed trait OpenlrAreaLocationReferencable {
  def openlrAreaLocationReferenceExtension: Option[nu.ndw._ExtensionType]
}



case class OpenlrAreaLocationReference(openlrAreaLocationReferenceExtension: Option[nu.ndw._ExtensionType] = None) extends OpenlrAreaLocationReferencable
      


sealed trait OpenlrBaseLocationReferencePoint {
  def openlrCoordinate: nu.ndw.PointCoordinates
  def openlrLineAttributes: nu.ndw.OpenlrLineAttributes
  def openlrBaseLocationReferencePointExtension: Option[nu.ndw._ExtensionType]
}


sealed trait OpenlrBasePointLocation {
  def openlrSideOfRoad: nu.ndw.OpenlrSideOfRoadEnum
  def openlrOrientation: nu.ndw.OpenlrOrientationEnum
  def openlrPositiveOffset: Option[Int]
  def openlrLocationReferencePoint: nu.ndw.OpenlrLocationReferencePoint
  def openlrLastLocationReferencePoint: nu.ndw.OpenlrLastLocationReferencePoint
  def openlrBasePointLocationExtension: Option[nu.ndw._ExtensionType]
}



case class OpenlrCircleLocationReference(openlrAreaLocationReferenceExtension: Option[nu.ndw._ExtensionType] = None,
  radius: Int,
  openlrGeoCoordinate: nu.ndw.OpenlrGeoCoordinate,
  openlrCircleLocationReferenceExtension: Option[nu.ndw._ExtensionType] = None) extends OpenlrAreaLocationReferencable
      



case class OpenlrClosedLineLocationReference(openlrAreaLocationReferenceExtension: Option[nu.ndw._ExtensionType] = None,
  openlrLocationReferencePoint: Seq[nu.ndw.OpenlrLocationReferencePoint] = Nil,
  openlrLastLine: nu.ndw.OpenlrLineAttributes,
  openlrClosedLineLocationReferenceExtension: Option[nu.ndw._ExtensionType] = None) extends OpenlrAreaLocationReferencable
      



case class OpenlrExtendedArea(openlrAreaLocationReference: nu.ndw.OpenlrAreaLocationReferencable)
      



case class OpenlrExtendedLinear(firstDirection: nu.ndw.OpenlrLineLocationReference,
  oppositeDirection: Option[nu.ndw.OpenlrLineLocationReference] = None)
      



case class OpenlrExtendedPoint(openlrPointLocationReference: nu.ndw.OpenlrPointLocationReference)
      

sealed trait OpenlrFormOfWayEnum

object OpenlrFormOfWayEnum {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[nu.ndw.OpenlrFormOfWayEnum]): OpenlrFormOfWayEnum = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: OpenlrFormOfWayEnum) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
}

case object Undefined extends OpenlrFormOfWayEnum { override def toString = "undefined" }
case object Motorway extends OpenlrFormOfWayEnum { override def toString = "motorway" }
case object MultipleCarriageway extends OpenlrFormOfWayEnum { override def toString = "multipleCarriageway" }
case object SingleCarriageway extends OpenlrFormOfWayEnum { override def toString = "singleCarriageway" }
case object Roundabout extends OpenlrFormOfWayEnum { override def toString = "roundabout" }
case object SlipRoad extends OpenlrFormOfWayEnum { override def toString = "slipRoad" }
case object TrafficSquare extends OpenlrFormOfWayEnum { override def toString = "trafficSquare" }
case object OtherValue29 extends OpenlrFormOfWayEnum { override def toString = "other" }

sealed trait OpenlrFunctionalRoadClassEnum

object OpenlrFunctionalRoadClassEnum {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[nu.ndw.OpenlrFunctionalRoadClassEnum]): OpenlrFunctionalRoadClassEnum = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: OpenlrFunctionalRoadClassEnum) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
}

case object FRC0 extends OpenlrFunctionalRoadClassEnum { override def toString = "FRC0" }
case object FRC1 extends OpenlrFunctionalRoadClassEnum { override def toString = "FRC1" }
case object FRC2 extends OpenlrFunctionalRoadClassEnum { override def toString = "FRC2" }
case object FRC3 extends OpenlrFunctionalRoadClassEnum { override def toString = "FRC3" }
case object FRC4 extends OpenlrFunctionalRoadClassEnum { override def toString = "FRC4" }
case object FRC5 extends OpenlrFunctionalRoadClassEnum { override def toString = "FRC5" }
case object FRC6 extends OpenlrFunctionalRoadClassEnum { override def toString = "FRC6" }
case object FRC7 extends OpenlrFunctionalRoadClassEnum { override def toString = "FRC7" }



case class OpenlrGeoCoordinate(openlrCoordinate: nu.ndw.PointCoordinates,
  openlrGeoCoordinateExtension: Option[nu.ndw._ExtensionType] = None)
      



case class OpenlrGridAttributes(openlrNumColumns: Int,
  openlrNumRows: Int,
  openlrGridAttributesExtension: Option[nu.ndw._ExtensionType] = None)
      



case class OpenlrGridLocationReference(openlrAreaLocationReferenceExtension: Option[nu.ndw._ExtensionType] = None,
  openlrRectangle: nu.ndw.OpenlrRectangle,
  openlrGridAttributes: nu.ndw.OpenlrGridAttributes,
  openlrGridLocationReferenceExtension: Option[nu.ndw._ExtensionType] = None) extends OpenlrAreaLocationReferencable
      



case class OpenlrLastLocationReferencePoint(openlrCoordinate: nu.ndw.PointCoordinates,
  openlrLineAttributes: nu.ndw.OpenlrLineAttributes,
  openlrBaseLocationReferencePointExtension: Option[nu.ndw._ExtensionType] = None,
  openlrLastLocationReferencePointExtension: Option[nu.ndw._ExtensionType] = None) extends OpenlrBaseLocationReferencePoint
      



case class OpenlrLineAttributes(openlrFunctionalRoadClass: nu.ndw.OpenlrFunctionalRoadClassEnum,
  openlrFormOfWay: nu.ndw.OpenlrFormOfWayEnum,
  openlrBearing: Int,
  openlrLineAttributesExtension: Option[nu.ndw._ExtensionType] = None)
      



case class OpenlrLineLocationReference(openlrLocationReferencePoint: Seq[nu.ndw.OpenlrLocationReferencePoint] = Nil,
  openlrLastLocationReferencePoint: nu.ndw.OpenlrLastLocationReferencePoint,
  openlrOffsets: Option[nu.ndw.OpenlrOffsets] = None,
  openlrLineLocationReferenceExtension: Option[nu.ndw._ExtensionType] = None)
      



case class OpenlrLocationReferencePoint(openlrCoordinate: nu.ndw.PointCoordinates,
  openlrLineAttributes: nu.ndw.OpenlrLineAttributes,
  openlrBaseLocationReferencePointExtension: Option[nu.ndw._ExtensionType] = None,
  openlrPathAttributes: nu.ndw.OpenlrPathAttributes,
  openlrLocationReferencePointExtension: Option[nu.ndw._ExtensionType] = None) extends OpenlrBaseLocationReferencePoint
      



case class OpenlrOffsets(openlrPositiveOffset: Option[Int] = None,
  openlrNegativeOffset: Option[Int] = None,
  openlrOffsetsExtension: Option[nu.ndw._ExtensionType] = None)
      

sealed trait OpenlrOrientationEnum

object OpenlrOrientationEnum {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[nu.ndw.OpenlrOrientationEnum]): OpenlrOrientationEnum = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: OpenlrOrientationEnum) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
}

case object NoOrientationOrUnknown extends OpenlrOrientationEnum { override def toString = "noOrientationOrUnknown" }
case object WithLineDirection extends OpenlrOrientationEnum { override def toString = "withLineDirection" }
case object AgainstLineDirection extends OpenlrOrientationEnum { override def toString = "againstLineDirection" }
case object Both extends OpenlrOrientationEnum { override def toString = "both" }



case class OpenlrPathAttributes(openlrLowestFRCToNextLRPoint: nu.ndw.OpenlrFunctionalRoadClassEnum,
  openlrDistanceToNextLRPoint: Int,
  openlrPathAttributesExtension: Option[nu.ndw._ExtensionType] = None)
      



case class OpenlrPointAlongLine(openlrSideOfRoad: nu.ndw.OpenlrSideOfRoadEnum,
  openlrOrientation: nu.ndw.OpenlrOrientationEnum,
  openlrPositiveOffset: Option[Int] = None,
  openlrLocationReferencePoint: nu.ndw.OpenlrLocationReferencePoint,
  openlrLastLocationReferencePoint: nu.ndw.OpenlrLastLocationReferencePoint,
  openlrBasePointLocationExtension: Option[nu.ndw._ExtensionType] = None,
  openlrPointAlongLineExtension: Option[nu.ndw._ExtensionType] = None) extends OpenlrBasePointLocation
      



case class OpenlrPointLocationReference(openlrGeoCoordinate: Option[nu.ndw.OpenlrGeoCoordinate] = None,
  openlrPoiWithAccessPoint: Option[nu.ndw.OpenlrPoiWithAccessPoint] = None,
  openlrPointAlongLine: Option[nu.ndw.OpenlrPointAlongLine] = None,
  openlrPointLocationReferenceExtension: Option[nu.ndw._ExtensionType] = None)
      



case class OpenlrPoiWithAccessPoint(openlrSideOfRoad: nu.ndw.OpenlrSideOfRoadEnum,
  openlrOrientation: nu.ndw.OpenlrOrientationEnum,
  openlrPositiveOffset: Option[Int] = None,
  openlrLocationReferencePoint: nu.ndw.OpenlrLocationReferencePoint,
  openlrLastLocationReferencePoint: nu.ndw.OpenlrLastLocationReferencePoint,
  openlrBasePointLocationExtension: Option[nu.ndw._ExtensionType] = None,
  openlrCoordinate: nu.ndw.PointCoordinates,
  openlrPoiWithAccessPointExtension: Option[nu.ndw._ExtensionType] = None) extends OpenlrBasePointLocation
      



case class OpenlrPolygonCorners(openlrCoordinate: Seq[nu.ndw.PointCoordinates] = Nil,
  openlrPolygonCornersExtension: Option[nu.ndw._ExtensionType] = None)
      



case class OpenlrPolygonLocationReference(openlrAreaLocationReferenceExtension: Option[nu.ndw._ExtensionType] = None,
  openlrPolygonCorners: nu.ndw.OpenlrPolygonCorners,
  openlrPolygonLocationReferenceExtension: Option[nu.ndw._ExtensionType] = None) extends OpenlrAreaLocationReferencable
      



case class OpenlrRectangle(openlrLowerLeft: nu.ndw.PointCoordinates,
  openlrUpperRight: nu.ndw.PointCoordinates,
  openlrRectangleExtension: Option[nu.ndw._ExtensionType] = None)
      



case class OpenlrRectangleLocationReference(openlrAreaLocationReferenceExtension: Option[nu.ndw._ExtensionType] = None,
  openlrRectangle: nu.ndw.OpenlrRectangle,
  openlrRectangleLocationReferenceExtension: Option[nu.ndw._ExtensionType] = None) extends OpenlrAreaLocationReferencable
      

sealed trait OpenlrSideOfRoadEnum

object OpenlrSideOfRoadEnum {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[nu.ndw.OpenlrSideOfRoadEnum]): OpenlrSideOfRoadEnum = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: OpenlrSideOfRoadEnum) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
}

case object OnRoadOrUnknown extends OpenlrSideOfRoadEnum { override def toString = "onRoadOrUnknown" }
case object RightType extends OpenlrSideOfRoadEnum { override def toString = "right" }
case object LeftType extends OpenlrSideOfRoadEnum { override def toString = "left" }
case object BothValue3 extends OpenlrSideOfRoadEnum { override def toString = "both" }

sealed trait OperatingModeEnum

object OperatingModeEnum {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[nu.ndw.OperatingModeEnum]): OperatingModeEnum = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: OperatingModeEnum) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
}

case object OperatingMode0 extends OperatingModeEnum { override def toString = "operatingMode0" }
case object OperatingMode1 extends OperatingModeEnum { override def toString = "operatingMode1" }
case object OperatingMode2 extends OperatingModeEnum { override def toString = "operatingMode2" }
case object OperatingMode3 extends OperatingModeEnum { override def toString = "operatingMode3" }

sealed trait OperationStatusEnum

object OperationStatusEnum {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[nu.ndw.OperationStatusEnum]): OperationStatusEnum = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: OperationStatusEnum) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
}

case object InOperation extends OperationStatusEnum { override def toString = "inOperation" }
case object LimitedOperation extends OperationStatusEnum { override def toString = "limitedOperation" }
case object NotInOperation extends OperationStatusEnum { override def toString = "notInOperation" }
case object NotInOperationAbnormal extends OperationStatusEnum { override def toString = "notInOperationAbnormal" }
case object TechnicalDefect extends OperationStatusEnum { override def toString = "technicalDefect" }
case object UnknownValue36 extends OperationStatusEnum { override def toString = "unknown" }


sealed trait OperatorActionable extends SituationRecord {
  def situationRecordCreationReference: Option[String]
  def situationRecordCreationTime: javax.xml.datatype.XMLGregorianCalendar
  def situationRecordObservationTime: Option[javax.xml.datatype.XMLGregorianCalendar]
  def situationRecordVersionTime: javax.xml.datatype.XMLGregorianCalendar
  def situationRecordFirstSupplierVersionTime: Option[javax.xml.datatype.XMLGregorianCalendar]
  def confidentialityOverride: Option[nu.ndw.ConfidentialityValueEnum]
  def probabilityOfOccurrence: nu.ndw.ProbabilityOfOccurrenceEnum
  def severity: Option[nu.ndw.SeverityEnum]
  def source: Option[nu.ndw.Source]
  def validity: nu.ndw.Validity
  def impact: Option[nu.ndw.Impact]
  def cause: Option[nu.ndw.Cause]
  def generalPublicComment: Seq[nu.ndw.Comment]
  def nonGeneralPublicComment: Seq[nu.ndw.Comment]
  def urlLink: Seq[nu.ndw.UrlLink]
  def groupOfLocations: nu.ndw.GroupOfLocations
  def management: Option[nu.ndw.Management]
  def situationRecordExtension: Option[nu.ndw._SituationRecordExtensionType]
  def actionOrigin: Option[nu.ndw.OperatorActionOriginEnum]
  def actionPlanIdentifier: Option[String]
  def operatorActionStatus: Option[nu.ndw.OperatorActionStatusEnum]
  def operatorActionExtension: Option[nu.ndw._ExtensionType]
  def id: String
  def version: String
}



case class OperatorAction(situationRecordCreationReference: Option[String] = None,
  situationRecordCreationTime: javax.xml.datatype.XMLGregorianCalendar,
  situationRecordObservationTime: Option[javax.xml.datatype.XMLGregorianCalendar] = None,
  situationRecordVersionTime: javax.xml.datatype.XMLGregorianCalendar,
  situationRecordFirstSupplierVersionTime: Option[javax.xml.datatype.XMLGregorianCalendar] = None,
  confidentialityOverride: Option[nu.ndw.ConfidentialityValueEnum] = None,
  probabilityOfOccurrence: nu.ndw.ProbabilityOfOccurrenceEnum,
  severity: Option[nu.ndw.SeverityEnum] = None,
  source: Option[nu.ndw.Source] = None,
  validity: nu.ndw.Validity,
  impact: Option[nu.ndw.Impact] = None,
  cause: Option[nu.ndw.Cause] = None,
  generalPublicComment: Seq[nu.ndw.Comment] = Nil,
  nonGeneralPublicComment: Seq[nu.ndw.Comment] = Nil,
  urlLink: Seq[nu.ndw.UrlLink] = Nil,
  groupOfLocations: nu.ndw.GroupOfLocations,
  management: Option[nu.ndw.Management] = None,
  situationRecordExtension: Option[nu.ndw._SituationRecordExtensionType] = None,
  actionOrigin: Option[nu.ndw.OperatorActionOriginEnum] = None,
  actionPlanIdentifier: Option[String] = None,
  operatorActionStatus: Option[nu.ndw.OperatorActionStatusEnum] = None,
  operatorActionExtension: Option[nu.ndw._ExtensionType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) extends OperatorActionable {
  @JsonIgnore lazy val id = attributes("@id").as[String]
  @JsonIgnore lazy val version = attributes("@version").as[String]
}

      

sealed trait OperatorActionOriginEnum

object OperatorActionOriginEnum {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[nu.ndw.OperatorActionOriginEnum]): OperatorActionOriginEnum = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: OperatorActionOriginEnum) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
}

case object External extends OperatorActionOriginEnum { override def toString = "external" }
case object Internal extends OperatorActionOriginEnum { override def toString = "internal" }

sealed trait OperatorActionStatusEnum

object OperatorActionStatusEnum {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[nu.ndw.OperatorActionStatusEnum]): OperatorActionStatusEnum = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: OperatorActionStatusEnum) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
}

case object Requested extends OperatorActionStatusEnum { override def toString = "requested" }
case object Approved extends OperatorActionStatusEnum { override def toString = "approved" }
case object BeingImplemented extends OperatorActionStatusEnum { override def toString = "beingImplemented" }
case object Implemented extends OperatorActionStatusEnum { override def toString = "implemented" }
case object Rejected extends OperatorActionStatusEnum { override def toString = "rejected" }
case object TerminationRequested extends OperatorActionStatusEnum { override def toString = "terminationRequested" }
case object BeingTerminated extends OperatorActionStatusEnum { override def toString = "beingTerminated" }



case class OverallPeriod(overallStartTime: javax.xml.datatype.XMLGregorianCalendar,
  overallEndTime: Option[javax.xml.datatype.XMLGregorianCalendar] = None,
  validPeriod: Seq[nu.ndw.Period] = Nil,
  exceptionPeriod: Seq[nu.ndw.Period] = Nil,
  overallPeriodExtension: Option[nu.ndw._ExtensionType] = None)
      

sealed trait OwnershipTypeEnum

object OwnershipTypeEnum {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[nu.ndw.OwnershipTypeEnum]): OwnershipTypeEnum = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: OwnershipTypeEnum) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
}

case object Public extends OwnershipTypeEnum { override def toString = "public" }
case object Private extends OwnershipTypeEnum { override def toString = "private" }
case object PublicPrivate extends OwnershipTypeEnum { override def toString = "publicPrivate" }
case object Resident extends OwnershipTypeEnum { override def toString = "resident" }
case object UnknownValue15 extends OwnershipTypeEnum { override def toString = "unknown" }
case object OtherValue28 extends OwnershipTypeEnum { override def toString = "other" }



case class ParkingAccess(accessCategory: Seq[nu.ndw.AccessCategoryEnum] = Nil,
  accessName: Option[nu.ndw.MultilingualString] = None,
  accessEquipment: Seq[nu.ndw.AccessEquipmentEnum] = Nil,
  accessibility: Seq[nu.ndw.AccessibilityEnum] = Nil,
  photoUrl: Option[java.net.URI] = None,
  accessOnlyAssignedFor: Option[nu.ndw.ParkingAssignment] = None,
  accessAssignedAmongOthers: Option[nu.ndw.ParkingAssignment] = None,
  accessProhibitedFor: Option[nu.ndw.ParkingAssignment] = None,
  primaryRoad: Seq[nu.ndw.Roadable] = Nil,
  location: Option[nu.ndw.Location] = None,
  openingTimes: Option[nu.ndw.OpeningTimes] = None,
  parkingAccessExtension: Option[nu.ndw._ExtensionType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  @JsonIgnore lazy val id = attributes("@id").as[String]
}

      



case class ParkingAccessStatus(accessReference: nu.ndw._ParkingAccessReference,
  accessOpeningStatus: Option[nu.ndw.OpeningStatusEnum] = None,
  accessFault: Seq[nu.ndw.ParkingFaultEnum] = Nil,
  parkingAccessStatusExtension: Option[nu.ndw._ExtensionType] = None)
      



case class ParkingAssignment(applicableForUser: Seq[nu.ndw.UserTypeEnum] = Nil,
  parkingDuration: Seq[nu.ndw.ParkingDurationEnum] = Nil,
  vehicleCharacteristics: Seq[nu.ndw.VehicleCharacteristics] = Nil,
  hazardousMaterials: Seq[nu.ndw.HazardousMaterialsType] = Nil,
  timePeriodByHour: Seq[nu.ndw.TimePeriodByHour] = Nil,
  parkingPermit: Seq[nu.ndw.ParkingPermit] = Nil,
  parkingAssignmentExtension: Option[nu.ndw._ExtensionType] = None)
      

sealed trait ParkingConditionsEnum

object ParkingConditionsEnum {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[nu.ndw.ParkingConditionsEnum]): ParkingConditionsEnum = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: ParkingConditionsEnum) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
}

case object NormalParkingConditionsSuspended extends ParkingConditionsEnum { override def toString = "normalParkingConditionsSuspended" }
case object SpecialParkingConditionsInForce extends ParkingConditionsEnum { override def toString = "specialParkingConditionsInForce" }
case object OtherValue27 extends ParkingConditionsEnum { override def toString = "other" }

sealed trait ParkingDurationEnum

object ParkingDurationEnum {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[nu.ndw.ParkingDurationEnum]): ParkingDurationEnum = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: ParkingDurationEnum) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
}

case object PickUpDropOff extends ParkingDurationEnum { override def toString = "pickUpDropOff" }
case object ShortTerm extends ParkingDurationEnum { override def toString = "shortTerm" }
case object ShortTerm24hours extends ParkingDurationEnum { override def toString = "shortTerm24hours" }
case object ShortTerm48hours extends ParkingDurationEnum { override def toString = "shortTerm48hours" }
case object ShortTerm72hours extends ParkingDurationEnum { override def toString = "shortTerm72hours" }
case object ShortTerm96hours extends ParkingDurationEnum { override def toString = "shortTerm96hours" }
case object LongTerm extends ParkingDurationEnum { override def toString = "longTerm" }
case object UnknownValue37 extends ParkingDurationEnum { override def toString = "unknown" }
case object OtherValue65 extends ParkingDurationEnum { override def toString = "other" }


sealed trait ParkingEquipmentOrServiceFacility {
  def equipmentOrServiceFacilityIdentifier: Seq[String]
  def availability: Option[nu.ndw.AvailabilityEnum]
  def numberOfEquipmentOrServiceFacility: Option[Int]
  def additionalDescription: Option[nu.ndw.MultilingualString]
  def otherEquipmentOrServiceFacility: Option[nu.ndw.MultilingualString]
  def accessibility: Seq[nu.ndw.AccessibilityEnum]
  def nameOrBrand: Option[nu.ndw.MultilingualString]
  def comment: Option[nu.ndw.MultilingualString]
  def photoUrl: Option[java.net.URI]
  def applicableForUser: Seq[nu.ndw.UserTypeEnum]
  def availabilityAndOpeningTimes: Option[nu.ndw.OpeningTimes]
  def tariffsAndPayment: Option[nu.ndw.TariffsAndPayment]
  def groupOfLocations: Option[nu.ndw.GroupOfLocations]
  def applicableForVehicles: Seq[nu.ndw.VehicleCharacteristics]
  def parkingEquipmentOrServiceFacilityExtension: Option[nu.ndw._ExtensionType]
}



case class ParkingEquipmentOrServiceFacilityStatus(numberOfEquipmentOrServiceFacilityOverride: Option[Int] = None,
  numberOfSubitemsOverride: Option[Int] = None,
  vacantEquipmentOrServiceFacilitySubitems: Option[Int] = None,
  serviceFacilityOpeningStatus: Option[nu.ndw.OpeningStatusEnum] = None,
  equipmentOperationStatus: Option[nu.ndw.OperationStatusEnum] = None,
  parkingEquipmentOrServiceFacilityStatusExtension: Option[nu.ndw._ExtensionType] = None)
      

sealed trait ParkingFaultEnum

object ParkingFaultEnum {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[nu.ndw.ParkingFaultEnum]): ParkingFaultEnum = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: ParkingFaultEnum) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
}

case object CommunicationsFailureValue extends ParkingFaultEnum { override def toString = "communicationsFailure" }
case object BarrierMalfunction extends ParkingFaultEnum { override def toString = "barrierMalfunction" }
case object EntranceExitObstructed extends ParkingFaultEnum { override def toString = "entranceExitObstructed" }
case object ErroneousOccupancyInformation extends ParkingFaultEnum { override def toString = "erroneousOccupancyInformation" }
case object ErroneousOccupancyDisplayed extends ParkingFaultEnum { override def toString = "erroneousOccupancyDisplayed" }
case object PaymentMachinesInoperative extends ParkingFaultEnum { override def toString = "paymentMachinesInoperative" }
case object ReservationServiceOutOfOrder extends ParkingFaultEnum { override def toString = "reservationServiceOutOfOrder" }
case object NoParkingInformationAvailable extends ParkingFaultEnum { override def toString = "noParkingInformationAvailable" }
case object UnspecifiedValue extends ParkingFaultEnum { override def toString = "unspecified" }
case object UnknownValue14 extends ParkingFaultEnum { override def toString = "unknown" }
case object OtherValue26 extends ParkingFaultEnum { override def toString = "other" }

sealed trait ParkingLayoutEnum

object ParkingLayoutEnum {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[nu.ndw.ParkingLayoutEnum]): ParkingLayoutEnum = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: ParkingLayoutEnum) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
}

case object MultiStoreyValue extends ParkingLayoutEnum { override def toString = "multiStorey" }
case object SingleLevelValue extends ParkingLayoutEnum { override def toString = "singleLevel" }
case object UndergroundValue extends ParkingLayoutEnum { override def toString = "underground" }
case object UndergroundAndMultistorey extends ParkingLayoutEnum { override def toString = "undergroundAndMultistorey" }
case object AutomatedParkingGarage extends ParkingLayoutEnum { override def toString = "automatedParkingGarage" }
case object OpenSpace extends ParkingLayoutEnum { override def toString = "openSpace" }
case object Covered extends ParkingLayoutEnum { override def toString = "covered" }
case object Nested extends ParkingLayoutEnum { override def toString = "nested" }
case object Field extends ParkingLayoutEnum { override def toString = "field" }
case object UnknownValue38 extends ParkingLayoutEnum { override def toString = "unknown" }
case object OtherValue66 extends ParkingLayoutEnum { override def toString = "other" }

sealed trait ParkingModeEnum

object ParkingModeEnum {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[nu.ndw.ParkingModeEnum]): ParkingModeEnum = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: ParkingModeEnum) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
}

case object PerpendicularParking extends ParkingModeEnum { override def toString = "perpendicularParking" }
case object ParallelParking extends ParkingModeEnum { override def toString = "parallelParking" }
case object EchelonParking extends ParkingModeEnum { override def toString = "echelonParking" }
case object ParkingOnOppositeSideOfRoad extends ParkingModeEnum { override def toString = "parkingOnOppositeSideOfRoad" }
case object OtherValue25 extends ParkingModeEnum { override def toString = "other" }


sealed trait ParkingOccupancyable {
  def parkingNumberOfSpacesOverride: Option[Int]
  def parkingNumberOfVacantSpaces: Option[Int]
  def parkingNumberOfVacantSpacesLowerThan: Option[Int]
  def parkingNumberOfVacantSpacesHigherThan: Option[Int]
  def parkingNumberOfVacantSpacesGraded: Option[nu.ndw.ParkingVacantSpacesEnum]
  def parkingNumberOfOccupiedSpaces: Option[Int]
  def parkingNumberOfVehicles: Option[Int]
  def parkingOccupancy: Option[Float]
  def parkingOccupancyGraded: Option[nu.ndw.ParkingOccupancyEnum]
  def parkingOccupancyTrend: Option[nu.ndw.ParkingOccupancyTrendEnum]
  def parkingNotAllowed: Option[Boolean]
  def vehicleCountAndRate: Seq[nu.ndw.VehicleCountAndRate]
  def parkingOccupancyExtension: Option[nu.ndw._ExtensionType]
}



case class ParkingOccupancy(parkingNumberOfSpacesOverride: Option[Int] = None,
  parkingNumberOfVacantSpaces: Option[Int] = None,
  parkingNumberOfVacantSpacesLowerThan: Option[Int] = None,
  parkingNumberOfVacantSpacesHigherThan: Option[Int] = None,
  parkingNumberOfVacantSpacesGraded: Option[nu.ndw.ParkingVacantSpacesEnum] = None,
  parkingNumberOfOccupiedSpaces: Option[Int] = None,
  parkingNumberOfVehicles: Option[Int] = None,
  parkingOccupancy: Option[Float] = None,
  parkingOccupancyGraded: Option[nu.ndw.ParkingOccupancyEnum] = None,
  parkingOccupancyTrend: Option[nu.ndw.ParkingOccupancyTrendEnum] = None,
  parkingNotAllowed: Option[Boolean] = None,
  vehicleCountAndRate: Seq[nu.ndw.VehicleCountAndRate] = Nil,
  parkingOccupancyExtension: Option[nu.ndw._ExtensionType] = None) extends ParkingOccupancyable
      

sealed trait ParkingOccupancyEnum

object ParkingOccupancyEnum {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[nu.ndw.ParkingOccupancyEnum]): ParkingOccupancyEnum = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: ParkingOccupancyEnum) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
}

case object ExpectCarParkToBeFull extends ParkingOccupancyEnum { override def toString = "expectCarParkToBeFull" }
case object Percentage10 extends ParkingOccupancyEnum { override def toString = "percentage10" }
case object Percentage20 extends ParkingOccupancyEnum { override def toString = "percentage20" }
case object Percentage30 extends ParkingOccupancyEnum { override def toString = "percentage30" }
case object Percentage40 extends ParkingOccupancyEnum { override def toString = "percentage40" }
case object Percentage50 extends ParkingOccupancyEnum { override def toString = "percentage50" }
case object Percentage60 extends ParkingOccupancyEnum { override def toString = "percentage60" }
case object Percentage70 extends ParkingOccupancyEnum { override def toString = "percentage70" }
case object Percentage80 extends ParkingOccupancyEnum { override def toString = "percentage80" }
case object Percentage90 extends ParkingOccupancyEnum { override def toString = "percentage90" }
case object FullValue extends ParkingOccupancyEnum { override def toString = "full" }
case object UnknownValue13 extends ParkingOccupancyEnum { override def toString = "unknown" }

sealed trait ParkingOccupancyTrendEnum

object ParkingOccupancyTrendEnum {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[nu.ndw.ParkingOccupancyTrendEnum]): ParkingOccupancyTrendEnum = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: ParkingOccupancyTrendEnum) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
}

case object Decreasing extends ParkingOccupancyTrendEnum { override def toString = "decreasing" }
case object Increasing extends ParkingOccupancyTrendEnum { override def toString = "increasing" }
case object Stable extends ParkingOccupancyTrendEnum { override def toString = "stable" }
case object IncreasingQuickly extends ParkingOccupancyTrendEnum { override def toString = "increasingQuickly" }
case object IncreasingSlowly extends ParkingOccupancyTrendEnum { override def toString = "increasingSlowly" }
case object DecreasingQuickly extends ParkingOccupancyTrendEnum { override def toString = "decreasingQuickly" }
case object DecreasingSlowly extends ParkingOccupancyTrendEnum { override def toString = "decreasingSlowly" }
case object UnknownValue39 extends ParkingOccupancyTrendEnum { override def toString = "unknown" }
case object OtherValue67 extends ParkingOccupancyTrendEnum { override def toString = "other" }

sealed trait ParkingPaymentModeEnum

object ParkingPaymentModeEnum {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[nu.ndw.ParkingPaymentModeEnum]): ParkingPaymentModeEnum = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: ParkingPaymentModeEnum) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
}

case object PayAndDisplay extends ParkingPaymentModeEnum { override def toString = "payAndDisplay" }
case object PayManualAtExitBooth extends ParkingPaymentModeEnum { override def toString = "payManualAtExitBooth" }
case object PayPriorToExit extends ParkingPaymentModeEnum { override def toString = "payPriorToExit" }
case object PayByPrepaidToken extends ParkingPaymentModeEnum { override def toString = "payByPrepaidToken" }
case object PayAndExit extends ParkingPaymentModeEnum { override def toString = "payAndExit" }
case object OtherValue24 extends ParkingPaymentModeEnum { override def toString = "other" }



case class ParkingPermit(parkingPermitType: nu.ndw.PermitTypeEnum,
  parkingPermitScheme: Option[String] = None,
  parkingPermitIdentifier: Option[String] = None,
  parkingPermitExtension: Option[nu.ndw._ExtensionType] = None)
      


sealed trait ParkingRecord {
  def parkingName: Option[nu.ndw.MultilingualString]
  def parkingAlias: Seq[nu.ndw.MultilingualString]
  def parkingDescription: Option[nu.ndw.MultilingualString]
  def parkingRecordVersionTime: javax.xml.datatype.XMLGregorianCalendar
  def parkingNumberOfSpaces: Option[Int]
  def parkingPrincipalNumberOfSpaces: Option[Int]
  def maximumParkingDuration: Option[Float]
  def photoUrl: Option[java.net.URI]
  def urlLinkAddress: Option[java.net.URI]
  def parkingOccupanyDetectionType: Seq[nu.ndw.OccupancyDetectionTypeEnum]
  def emergencyContact: Seq[nu.ndw.Contactable]
  def owner: Seq[nu.ndw.Contactable]
  def responisbleAuthority: Seq[nu.ndw.Contactable]
  def securityService: Seq[nu.ndw.Contactable]
  def operator: Seq[nu.ndw.Contactable]
  def servicePartner: Seq[nu.ndw.Contactable]
  def parkingVMS: Seq[nu.ndw.ParkingVMS]
  def parkingLocation: nu.ndw.GroupOfLocations
  def parkingRoute: Seq[nu.ndw.ParkingRoute]
  def parkingColour: Option[nu.ndw.RGBColour]
  def onlyAssignedParking: Option[nu.ndw.ParkingAssignment]
  def assignedParkingAmongOthers: Option[nu.ndw.ParkingAssignment]
  def prohibitedParking: Option[nu.ndw.ParkingAssignment]
  def tariffsAndPayment: Option[nu.ndw.TariffsAndPayment]
  def parkingEquipmentOrServiceFacility: Seq[nu.ndw._ParkingRecordEquipmentOrServiceFacilityIndexParkingEquipmentOrServiceFacility]
  def parkingSpace: Seq[nu.ndw._ParkingSpace]
  def groupOfParkingSpaces: Seq[nu.ndw._GroupOfParkingSpaces]
  def parkingThresholds: Option[nu.ndw.ParkingThresholds]
  def permitsAndProhibitions: Seq[nu.ndw.PermitsAndProhibitions]
  def emergencyAssemblyPoint: Option[nu.ndw.GroupOfLocations]
  def entireArea: Option[nu.ndw.Area]
  def parkingRecordDimension: Option[nu.ndw.Dimension]
  def parkingRecordExtension: Option[nu.ndw._ExtensionType]
  def id: String
  def version: String
}


sealed trait ParkingRecordStatus {
  def parkingRecordReference: nu.ndw._ParkingRecordVersionedReference
  def parkingStatusOriginTime: javax.xml.datatype.XMLGregorianCalendar
  def parkingStatusDescription: Option[nu.ndw.MultilingualString]
  def parkingQueueingTime: Option[Float]
  def parkingConditions: Option[nu.ndw.ParkingConditionsEnum]
  def blurredAvailability: Seq[Boolean]
  def parkingFault: Seq[nu.ndw.ParkingFaultEnum]
  def winterEquipmentManagementType: Seq[nu.ndw.WinterEquipmentManagementTypeEnum]
  def parkingSpaceStatus: Seq[nu.ndw._ParkingRecordStatusParkingSpaceIndexParkingSpaceStatus]
  def parkingOccupancy: nu.ndw.ParkingOccupancyable
  def groupOfParkingSpacesStatus: Seq[nu.ndw._ParkingRecordStatusGroupIndexGroupOfParkingSpacesStatus]
  def parkingStatusValidity: Option[nu.ndw.ParkingStatusValidity]
  def overrideParkingThresholds: Option[nu.ndw.ParkingThresholds]
  def parkingEquipmentOrServiceFacilityStatus: Seq[nu.ndw._ParkingRecordStatusEquipmentOrServiceFacilityIndexParkingEquipmentOrServiceFacilityStatus]
  def parkingUsageScenarioStatus: Seq[nu.ndw._ParkingRecordStatusScenarioIndexParkingUsageScenarioStatus]
  def parkingAccessStatus: Seq[nu.ndw.ParkingAccessStatus]
  def parkingRouteStatus: Seq[nu.ndw.ParkingRouteStatus]
  def parkingRecordStatusExtension: Option[nu.ndw._ExtensionType]
}


sealed trait ParkingRoute {
  def parkingRouteColour: Option[nu.ndw.RGBColour]
  def parkingRouteExtension: Option[nu.ndw._ExtensionType]
}



case class ParkingRouteByReference(parkingRouteColour: Option[nu.ndw.RGBColour] = None,
  parkingRouteExtension: Option[nu.ndw._ExtensionType] = None,
  parkingRouteReference: nu.ndw._ParkingRouteDetailsVersionedReference,
  parkingRouteByReferenceExtension: Option[nu.ndw._ExtensionType] = None) extends ParkingRoute
      



case class ParkingRouteDetails(parkingRouteColour: Option[nu.ndw.RGBColour] = None,
  parkingRouteExtension: Option[nu.ndw._ExtensionType] = None,
  parkingRouteName: Option[nu.ndw.MultilingualString] = None,
  parkingRouteType: Option[nu.ndw.ParkingRouteTypeEnum] = None,
  dynamicRouteManagement: Option[Boolean] = None,
  parkingRouteIconIndex: Option[String] = None,
  parkingRouteDirection: Option[nu.ndw.DirectionEnum] = None,
  parkingRouteDirection2: Option[nu.ndw.ParkingRouteDirectionEnum] = None,
  groupOfLocations: Option[nu.ndw.GroupOfLocations] = None,
  parkingRouteDetailsExtension: Option[nu.ndw._ExtensionType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) extends ParkingRoute {
  @JsonIgnore lazy val id = attributes("@id").as[String]
  @JsonIgnore lazy val version = attributes("@version").as[String]
}

      

sealed trait ParkingRouteDirectionEnum

object ParkingRouteDirectionEnum {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[nu.ndw.ParkingRouteDirectionEnum]): ParkingRouteDirectionEnum = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: ParkingRouteDirectionEnum) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
}

case object TowardsParkingSite extends ParkingRouteDirectionEnum { override def toString = "towardsParkingSite" }
case object AwayFromParkingSite extends ParkingRouteDirectionEnum { override def toString = "awayFromParkingSite" }



case class ParkingRouteStatus(parkingRouteReference: nu.ndw._ParkingRouteDetailsVersionedReference,
  parkingRouteActive: Boolean,
  parkingRouteStatusExtension: Option[nu.ndw._ExtensionType] = None)
      

sealed trait ParkingRouteTypeEnum

object ParkingRouteTypeEnum {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[nu.ndw.ParkingRouteTypeEnum]): ParkingRouteTypeEnum = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: ParkingRouteTypeEnum) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
}

case object PedestrianValue extends ParkingRouteTypeEnum { override def toString = "pedestrian" }
case object Bicycle extends ParkingRouteTypeEnum { override def toString = "bicycle" }
case object Lorry extends ParkingRouteTypeEnum { override def toString = "lorry" }
case object OtherValue68 extends ParkingRouteTypeEnum { override def toString = "other" }

sealed trait ParkingSecurityEnum

object ParkingSecurityEnum {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[nu.ndw.ParkingSecurityEnum]): ParkingSecurityEnum = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: ParkingSecurityEnum) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
}

case object SocialControl extends ParkingSecurityEnum { override def toString = "socialControl" }
case object SecurityStaff extends ParkingSecurityEnum { override def toString = "securityStaff" }
case object ExternalSecurity extends ParkingSecurityEnum { override def toString = "externalSecurity" }
case object Cctv extends ParkingSecurityEnum { override def toString = "cctv" }
case object Dog extends ParkingSecurityEnum { override def toString = "dog" }
case object Guard24hours extends ParkingSecurityEnum { override def toString = "guard24hours" }
case object Lighting extends ParkingSecurityEnum { override def toString = "lighting" }
case object FloodLight extends ParkingSecurityEnum { override def toString = "floodLight" }
case object Fences extends ParkingSecurityEnum { override def toString = "fences" }
case object AreaSeperatedFromSurroundings extends ParkingSecurityEnum { override def toString = "areaSeperatedFromSurroundings" }
case object NoneTypeValue extends ParkingSecurityEnum { override def toString = "none" }
case object UnknownValue12 extends ParkingSecurityEnum { override def toString = "unknown" }
case object OtherValue23 extends ParkingSecurityEnum { override def toString = "other" }


sealed trait ParkingSite extends ParkingRecord {
  def parkingName: Option[nu.ndw.MultilingualString]
  def parkingAlias: Seq[nu.ndw.MultilingualString]
  def parkingDescription: Option[nu.ndw.MultilingualString]
  def parkingRecordVersionTime: javax.xml.datatype.XMLGregorianCalendar
  def parkingNumberOfSpaces: Option[Int]
  def parkingPrincipalNumberOfSpaces: Option[Int]
  def maximumParkingDuration: Option[Float]
  def photoUrl: Option[java.net.URI]
  def urlLinkAddress: Option[java.net.URI]
  def parkingOccupanyDetectionType: Seq[nu.ndw.OccupancyDetectionTypeEnum]
  def emergencyContact: Seq[nu.ndw.Contactable]
  def owner: Seq[nu.ndw.Contactable]
  def responisbleAuthority: Seq[nu.ndw.Contactable]
  def securityService: Seq[nu.ndw.Contactable]
  def operator: Seq[nu.ndw.Contactable]
  def servicePartner: Seq[nu.ndw.Contactable]
  def parkingVMS: Seq[nu.ndw.ParkingVMS]
  def parkingLocation: nu.ndw.GroupOfLocations
  def parkingRoute: Seq[nu.ndw.ParkingRoute]
  def parkingColour: Option[nu.ndw.RGBColour]
  def onlyAssignedParking: Option[nu.ndw.ParkingAssignment]
  def assignedParkingAmongOthers: Option[nu.ndw.ParkingAssignment]
  def prohibitedParking: Option[nu.ndw.ParkingAssignment]
  def tariffsAndPayment: Option[nu.ndw.TariffsAndPayment]
  def parkingEquipmentOrServiceFacility: Seq[nu.ndw._ParkingRecordEquipmentOrServiceFacilityIndexParkingEquipmentOrServiceFacility]
  def parkingSpace: Seq[nu.ndw._ParkingSpace]
  def groupOfParkingSpaces: Seq[nu.ndw._GroupOfParkingSpaces]
  def parkingThresholds: Option[nu.ndw.ParkingThresholds]
  def permitsAndProhibitions: Seq[nu.ndw.PermitsAndProhibitions]
  def emergencyAssemblyPoint: Option[nu.ndw.GroupOfLocations]
  def entireArea: Option[nu.ndw.Area]
  def parkingRecordDimension: Option[nu.ndw.Dimension]
  def parkingRecordExtension: Option[nu.ndw._ExtensionType]
  def parkingReservation: Option[nu.ndw.ReservationTypeEnum]
  def parkingLayout: Seq[nu.ndw.ParkingLayoutEnum]
  def highestFloor: Option[Int]
  def lowestFloor: Option[Int]
  def temporaryParking: Option[Boolean]
  def parkingSiteAddress: Seq[nu.ndw.Contactable]
  def reservationService: Seq[nu.ndw.Contactable]
  def parkingUsageScenario: Seq[nu.ndw._ParkingSiteScenarioIndexParkingUsageScenario]
  def openingTimes: Option[nu.ndw.OpeningTimes]
  def parkingAccess: Seq[nu.ndw.ParkingAccess]
  def parkingStandardsAndSecurity: Option[nu.ndw.ParkingStandardsAndSecurity]
  def parkingSiteExtension: Option[nu.ndw._ExtensionType]
  def id: String
  def version: String
}

sealed trait ParkingSiteOvercrowdingStatusEnum

object ParkingSiteOvercrowdingStatusEnum {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[nu.ndw.ParkingSiteOvercrowdingStatusEnum]): ParkingSiteOvercrowdingStatusEnum = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: ParkingSiteOvercrowdingStatusEnum) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
}

case object Overcrowding extends ParkingSiteOvercrowdingStatusEnum { override def toString = "overcrowding" }
case object NoOvercrowding extends ParkingSiteOvercrowdingStatusEnum { override def toString = "noOvercrowding" }
case object OvercrowdingLevel1 extends ParkingSiteOvercrowdingStatusEnum { override def toString = "overcrowdingLevel1" }
case object OvercrowdingLevel2 extends ParkingSiteOvercrowdingStatusEnum { override def toString = "overcrowdingLevel2" }
case object UnknownValue11 extends ParkingSiteOvercrowdingStatusEnum { override def toString = "unknown" }
case object OtherValue22 extends ParkingSiteOvercrowdingStatusEnum { override def toString = "other" }



case class ParkingSiteStatus(parkingRecordReference: nu.ndw._ParkingRecordVersionedReference,
  parkingStatusOriginTime: javax.xml.datatype.XMLGregorianCalendar,
  parkingStatusDescription: Option[nu.ndw.MultilingualString] = None,
  parkingQueueingTime: Option[Float] = None,
  parkingConditions: Option[nu.ndw.ParkingConditionsEnum] = None,
  blurredAvailability: Seq[Boolean] = Nil,
  parkingFault: Seq[nu.ndw.ParkingFaultEnum] = Nil,
  winterEquipmentManagementType: Seq[nu.ndw.WinterEquipmentManagementTypeEnum] = Nil,
  parkingSpaceStatus: Seq[nu.ndw._ParkingRecordStatusParkingSpaceIndexParkingSpaceStatus] = Nil,
  parkingOccupancy: nu.ndw.ParkingOccupancyable,
  groupOfParkingSpacesStatus: Seq[nu.ndw._ParkingRecordStatusGroupIndexGroupOfParkingSpacesStatus] = Nil,
  parkingStatusValidity: Option[nu.ndw.ParkingStatusValidity] = None,
  overrideParkingThresholds: Option[nu.ndw.ParkingThresholds] = None,
  parkingEquipmentOrServiceFacilityStatus: Seq[nu.ndw._ParkingRecordStatusEquipmentOrServiceFacilityIndexParkingEquipmentOrServiceFacilityStatus] = Nil,
  parkingUsageScenarioStatus: Seq[nu.ndw._ParkingRecordStatusScenarioIndexParkingUsageScenarioStatus] = Nil,
  parkingAccessStatus: Seq[nu.ndw.ParkingAccessStatus] = Nil,
  parkingRouteStatus: Seq[nu.ndw.ParkingRouteStatus] = Nil,
  parkingRecordStatusExtension: Option[nu.ndw._ExtensionType] = None,
  parkingSiteStatus: Option[nu.ndw.ParkingSiteStatusEnum] = None,
  parkingSiteOpeningStatus: Option[nu.ndw.OpeningStatusEnum] = None,
  parkingSiteOvercrowdingStatus: Option[nu.ndw.ParkingSiteOvercrowdingStatusEnum] = None,
  parkingSiteFullAtFloor: Seq[Int] = Nil,
  parkingSiteStatusExtension: Option[nu.ndw._ExtensionType] = None) extends ParkingRecordStatus
      

sealed trait ParkingSiteStatusEnum

object ParkingSiteStatusEnum {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[nu.ndw.ParkingSiteStatusEnum]): ParkingSiteStatusEnum = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: ParkingSiteStatusEnum) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
}

case object SpacesAvailable extends ParkingSiteStatusEnum { override def toString = "spacesAvailable" }
case object AlmostFull extends ParkingSiteStatusEnum { override def toString = "almostFull" }
case object FullAtEntrance extends ParkingSiteStatusEnum { override def toString = "fullAtEntrance" }
case object Full extends ParkingSiteStatusEnum { override def toString = "full" }
case object UnknownValue10 extends ParkingSiteStatusEnum { override def toString = "unknown" }
case object OtherValue21 extends ParkingSiteStatusEnum { override def toString = "other" }



case class ParkingSpace(parkingSpaceOrGroupIdentifier: Option[nu.ndw.MultilingualString] = None,
  parkingFloorOrLevel: Option[Int] = None,
  accessibility: Seq[nu.ndw.AccessibilityEnum] = Nil,
  parkingSpaceAccessibility: Seq[nu.ndw.ParkingSpaceAccessibilityEnum] = Nil,
  parkingSpacePhysics: Seq[nu.ndw.ParkingSpacePhysicsEnum] = Nil,
  parkingMode: Option[nu.ndw.ParkingModeEnum] = None,
  parkingReservation: Option[nu.ndw.ReservationTypeEnum] = None,
  maximumParkingDuration: Option[Float] = None,
  distanceFromPrimaryRoad: Option[Int] = None,
  parkingOccupanyDetectionType: Seq[nu.ndw.OccupancyDetectionTypeEnum] = Nil,
  parkingSecurity: Seq[nu.ndw.ParkingSecurityEnum] = Nil,
  dedicatedAccess: Seq[nu.ndw.DedicatedAccess] = Nil,
  onlyAssignedParking: Option[nu.ndw.ParkingAssignment] = None,
  assignedParkingAmongOthers: Option[nu.ndw.ParkingAssignment] = None,
  prohibitedParking: Option[nu.ndw.ParkingAssignment] = None,
  parkingEquipmentOrServiceFacility: Seq[nu.ndw._ParkingSpaceBasicsEquipmentOrServiceFacilityIndexParkingEquipmentOrServiceFacility] = Nil,
  parkingUsageScenario: Seq[nu.ndw._ParkingSpaceBasicsScenarioIndexParkingUsageScenario] = Nil,
  parkingSpaceBasicsExtension: Option[nu.ndw._ExtensionType] = None,
  identicalToParkingSpace: Seq[String] = Nil,
  location: Option[nu.ndw.Location] = None,
  parkingSpaceDimension: Option[nu.ndw.Dimension] = None,
  parkingSpaceExtension: Option[nu.ndw._ExtensionType] = None) extends ParkingSpaceBasics
      

sealed trait ParkingSpaceAccessibilityEnum

object ParkingSpaceAccessibilityEnum {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[nu.ndw.ParkingSpaceAccessibilityEnum]): ParkingSpaceAccessibilityEnum = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: ParkingSpaceAccessibilityEnum) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
}

case object ExtraSpaceLeftSide extends ParkingSpaceAccessibilityEnum { override def toString = "extraSpaceLeftSide" }
case object ExtraSpaceRightSide extends ParkingSpaceAccessibilityEnum { override def toString = "extraSpaceRightSide" }
case object NearbyPedestrianExit extends ParkingSpaceAccessibilityEnum { override def toString = "nearbyPedestrianExit" }
case object BordersMarked extends ParkingSpaceAccessibilityEnum { override def toString = "bordersMarked" }
case object OtherValue20 extends ParkingSpaceAccessibilityEnum { override def toString = "other" }


sealed trait ParkingSpaceBasics {
  def parkingSpaceOrGroupIdentifier: Option[nu.ndw.MultilingualString]
  def parkingFloorOrLevel: Option[Int]
  def accessibility: Seq[nu.ndw.AccessibilityEnum]
  def parkingSpaceAccessibility: Seq[nu.ndw.ParkingSpaceAccessibilityEnum]
  def parkingSpacePhysics: Seq[nu.ndw.ParkingSpacePhysicsEnum]
  def parkingMode: Option[nu.ndw.ParkingModeEnum]
  def parkingReservation: Option[nu.ndw.ReservationTypeEnum]
  def maximumParkingDuration: Option[Float]
  def distanceFromPrimaryRoad: Option[Int]
  def parkingOccupanyDetectionType: Seq[nu.ndw.OccupancyDetectionTypeEnum]
  def parkingSecurity: Seq[nu.ndw.ParkingSecurityEnum]
  def dedicatedAccess: Seq[nu.ndw.DedicatedAccess]
  def onlyAssignedParking: Option[nu.ndw.ParkingAssignment]
  def assignedParkingAmongOthers: Option[nu.ndw.ParkingAssignment]
  def prohibitedParking: Option[nu.ndw.ParkingAssignment]
  def parkingEquipmentOrServiceFacility: Seq[nu.ndw._ParkingSpaceBasicsEquipmentOrServiceFacilityIndexParkingEquipmentOrServiceFacility]
  def parkingUsageScenario: Seq[nu.ndw._ParkingSpaceBasicsScenarioIndexParkingUsageScenario]
  def parkingSpaceBasicsExtension: Option[nu.ndw._ExtensionType]
}

sealed trait ParkingSpacePhysicsEnum

object ParkingSpacePhysicsEnum {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[nu.ndw.ParkingSpacePhysicsEnum]): ParkingSpacePhysicsEnum = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: ParkingSpacePhysicsEnum) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
}

case object DriveThrough extends ParkingSpacePhysicsEnum { override def toString = "driveThrough" }
case object OpenAir extends ParkingSpacePhysicsEnum { override def toString = "openAir" }



case class ParkingSpaceStatus(parkingSpaceOccupied: Boolean,
  parkingSpaceClosed: Option[Boolean] = None,
  parkingSpaceDeclarationValidNow: Option[Boolean] = None,
  measurementOrCalculationTime: Option[javax.xml.datatype.XMLGregorianCalendar] = None,
  lastCalibration: Option[javax.xml.datatype.XMLGregorianCalendar] = None,
  parkingSpaceStatusExtension: Option[nu.ndw._ExtensionType] = None)
      

sealed trait ParkingSpecialLocationEnum

object ParkingSpecialLocationEnum {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[nu.ndw.ParkingSpecialLocationEnum]): ParkingSpecialLocationEnum = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: ParkingSpecialLocationEnum) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
}

case object AirportTerminal extends ParkingSpecialLocationEnum { override def toString = "airportTerminal" }
case object ExhibitonCentre extends ParkingSpecialLocationEnum { override def toString = "exhibitonCentre" }
case object ShoppingCentre extends ParkingSpecialLocationEnum { override def toString = "shoppingCentre" }
case object SpecificFacility extends ParkingSpecialLocationEnum { override def toString = "specificFacility" }
case object TrainStation extends ParkingSpecialLocationEnum { override def toString = "trainStation" }
case object Campground extends ParkingSpecialLocationEnum { override def toString = "campground" }
case object ThemePark extends ParkingSpecialLocationEnum { override def toString = "themePark" }
case object FerryTerminal extends ParkingSpecialLocationEnum { override def toString = "ferryTerminal" }
case object VehicleOnRailTerminal extends ParkingSpecialLocationEnum { override def toString = "vehicleOnRailTerminal" }
case object CoachStation extends ParkingSpecialLocationEnum { override def toString = "coachStation" }
case object CableCarStation extends ParkingSpecialLocationEnum { override def toString = "cableCarStation" }
case object PublicTransportStation extends ParkingSpecialLocationEnum { override def toString = "publicTransportStation" }
case object Market extends ParkingSpecialLocationEnum { override def toString = "market" }
case object ReligiousCentre extends ParkingSpecialLocationEnum { override def toString = "religiousCentre" }
case object ConventionCentre extends ParkingSpecialLocationEnum { override def toString = "conventionCentre" }
case object Cinema extends ParkingSpecialLocationEnum { override def toString = "cinema" }
case object Skilift extends ParkingSpecialLocationEnum { override def toString = "skilift" }
case object UnknownValue9 extends ParkingSpecialLocationEnum { override def toString = "unknown" }
case object OtherValue19 extends ParkingSpecialLocationEnum { override def toString = "other" }



case class ParkingStandardsAndSecurity(labelSecurityLevel: Option[nu.ndw.LABELSecurityLevelEnum] = None,
  labelServiceLevel: Option[nu.ndw.LABELServiceLevelEnum] = None,
  labelSecurityLevelSelfAssessment: Option[nu.ndw.LABELSecurityLevelEnum] = None,
  labelServiceLevelSelfAssessment: Option[nu.ndw.LABELServiceLevelEnum] = None,
  parkingSecurity: Seq[nu.ndw.ParkingSecurityEnum] = Nil,
  parkingAdditionalSecurity: Seq[nu.ndw.MultilingualString] = Nil,
  parkingSupervision: Seq[nu.ndw.ParkingSupervisionEnum] = Nil,
  parkingSecurityNationalClassification: Option[nu.ndw.MultilingualString] = None,
  certifiedSecureParking: Option[Boolean] = None,
  dateOfCertification: Option[javax.xml.datatype.XMLGregorianCalendar] = None,
  parkingStandardsAndSecurityExtension: Option[nu.ndw._ExtensionType] = None)
      



case class ParkingStatusColourMapping(parkingSiteStatus: nu.ndw.ParkingSiteStatusEnum,
  rgbColour: nu.ndw.RGBColour,
  parkingStatusColourMappingExtension: Option[nu.ndw._ExtensionType] = None)
      



case class ParkingStatusPublication(parkingTableReference: Seq[nu.ndw._ParkingTableVersionedReference] = Nil,
  headerInformation: Option[nu.ndw.HeaderInformation] = None,
  parkingRecordStatus: Seq[nu.ndw.ParkingRecordStatus] = Nil)
      



case class ParkingStatusValidity(parkingStatusTime: Option[javax.xml.datatype.XMLGregorianCalendar] = None,
  parkingStatusTimeOffsetToOrigin: Option[Float] = None,
  validityTimeSpecification: Option[nu.ndw.OverallPeriod] = None,
  parkingStatusValidityExtension: Option[nu.ndw._ExtensionType] = None)
      

sealed trait ParkingSupervisionEnum

object ParkingSupervisionEnum {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[nu.ndw.ParkingSupervisionEnum]): ParkingSupervisionEnum = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: ParkingSupervisionEnum) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
}

case object Remote extends ParkingSupervisionEnum { override def toString = "remote" }
case object OnSite extends ParkingSupervisionEnum { override def toString = "onSite" }
case object ControlCentreOnSite extends ParkingSupervisionEnum { override def toString = "controlCentreOnSite" }
case object ControlCentreOffSite extends ParkingSupervisionEnum { override def toString = "controlCentreOffSite" }
case object Patrol extends ParkingSupervisionEnum { override def toString = "patrol" }
case object NoneTypeValue7 extends ParkingSupervisionEnum { override def toString = "none" }
case object UnknownValue40 extends ParkingSupervisionEnum { override def toString = "unknown" }
case object OtherValue69 extends ParkingSupervisionEnum { override def toString = "other" }



case class ParkingTable(parkingTableName: Option[nu.ndw.MultilingualString] = None,
  parkingTableVersionTime: javax.xml.datatype.XMLGregorianCalendar,
  parkingRecord: Seq[nu.ndw.ParkingRecord] = Nil,
  parkingTableExtension: Option[nu.ndw._ExtensionType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  @JsonIgnore lazy val id = attributes("@id").as[String]
  @JsonIgnore lazy val version = attributes("@version").as[String]
}

      



case class ParkingTablePublication(headerInformation: Option[nu.ndw.HeaderInformation] = None,
  parkingTable: Seq[nu.ndw.ParkingTable] = Nil)
      



case class ParkingThresholds(almostFullDecreasing: Option[Int] = None,
  almostFullIncreasing: Option[Int] = None,
  entranceFull: Option[Int] = None,
  fullDecreasing: Option[Int] = None,
  fullIncreasing: Option[Int] = None,
  overcrowding: Option[Int] = None,
  overcrowdingLevel1: Option[Int] = None,
  overcrowdingLevel2: Option[Int] = None,
  parkingLastMaximumOccupancy: Option[Int] = None,
  parkingStatusColourMapping: Seq[nu.ndw.ParkingStatusColourMapping] = Nil,
  parkingThresholdsExtension: Option[nu.ndw._ExtensionType] = None)
      

sealed trait ParkingTypeOfGroup

object ParkingTypeOfGroup {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[nu.ndw.ParkingTypeOfGroup]): ParkingTypeOfGroup = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: ParkingTypeOfGroup) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
}

case object AdjacentSpaces extends ParkingTypeOfGroup { override def toString = "adjacentSpaces" }
case object NonAdjacentSpaces extends ParkingTypeOfGroup { override def toString = "nonAdjacentSpaces" }
case object CompleteFloor extends ParkingTypeOfGroup { override def toString = "completeFloor" }
case object MixedUsage extends ParkingTypeOfGroup { override def toString = "mixedUsage" }
case object StatisticsOnly extends ParkingTypeOfGroup { override def toString = "statisticsOnly" }
case object SingleParameters extends ParkingTypeOfGroup { override def toString = "singleParameters" }
case object OtherValue70 extends ParkingTypeOfGroup { override def toString = "other" }



case class ParkingUsageScenario(parkingUsageScenario: nu.ndw.ParkingUsageScenarioEnum,
  truckParkingDynamicManagement: Seq[nu.ndw.TruckParkingDynamicManagementEnum] = Nil,
  eventParkingType: Option[nu.ndw.PublicEventTypeEnum] = None,
  eventParkingType2: Option[nu.ndw.PublicEventType2Enum] = None,
  scenarioAvailability: Option[nu.ndw.OverallPeriod] = None,
  parkingUsageScenarioExtension: Option[nu.ndw._ExtensionType] = None)
      

sealed trait ParkingUsageScenarioEnum

object ParkingUsageScenarioEnum {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[nu.ndw.ParkingUsageScenarioEnum]): ParkingUsageScenarioEnum = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: ParkingUsageScenarioEnum) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
}

case object TruckParking extends ParkingUsageScenarioEnum { override def toString = "truckParking" }
case object ParkAndRideValue extends ParkingUsageScenarioEnum { override def toString = "parkAndRide" }
case object ParkAndCycle extends ParkingUsageScenarioEnum { override def toString = "parkAndCycle" }
case object ParkAndWalk extends ParkingUsageScenarioEnum { override def toString = "parkAndWalk" }
case object KissAndRide extends ParkingUsageScenarioEnum { override def toString = "kissAndRide" }
case object Liftshare extends ParkingUsageScenarioEnum { override def toString = "liftshare" }
case object CarSharingValue extends ParkingUsageScenarioEnum { override def toString = "carSharing" }
case object RestArea extends ParkingUsageScenarioEnum { override def toString = "restArea" }
case object ServiceArea extends ParkingUsageScenarioEnum { override def toString = "serviceArea" }
case object DropOffWithValet extends ParkingUsageScenarioEnum { override def toString = "dropOffWithValet" }
case object DropOffMechanical extends ParkingUsageScenarioEnum { override def toString = "dropOffMechanical" }
case object EventParking extends ParkingUsageScenarioEnum { override def toString = "eventParking" }
case object AutomaticParkingGuidance extends ParkingUsageScenarioEnum { override def toString = "automaticParkingGuidance" }
case object StaffGuidesToSpace extends ParkingUsageScenarioEnum { override def toString = "staffGuidesToSpace" }
case object VehicleLift extends ParkingUsageScenarioEnum { override def toString = "vehicleLift" }
case object LoadingBay extends ParkingUsageScenarioEnum { override def toString = "loadingBay" }
case object DropOff extends ParkingUsageScenarioEnum { override def toString = "dropOff" }
case object OvernightParking extends ParkingUsageScenarioEnum { override def toString = "overnightParking" }
case object UnknownValue41 extends ParkingUsageScenarioEnum { override def toString = "unknown" }
case object OtherValue71 extends ParkingUsageScenarioEnum { override def toString = "other" }



case class ParkingUsageScenarioStatus(usageScenarioOperationStatus: nu.ndw.OperationStatusEnum,
  parkingUsageScenarioStatusExtension: Option[nu.ndw._ExtensionType] = None)
      

sealed trait ParkingVacantSpacesEnum

object ParkingVacantSpacesEnum {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[nu.ndw.ParkingVacantSpacesEnum]): ParkingVacantSpacesEnum = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: ParkingVacantSpacesEnum) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
}

case object NoParkingSpacesAvailable extends ParkingVacantSpacesEnum { override def toString = "noParkingSpacesAvailable" }
case object ExpectNoSpacesAvailable extends ParkingVacantSpacesEnum { override def toString = "expectNoSpacesAvailable" }
case object OnlyAFewSpacesAvailableValue extends ParkingVacantSpacesEnum { override def toString = "onlyAFewSpacesAvailable" }
case object LessThan10SpacesAvailable extends ParkingVacantSpacesEnum { override def toString = "lessThan10SpacesAvailable" }
case object LessThan20SpacesAvailable extends ParkingVacantSpacesEnum { override def toString = "lessThan20SpacesAvailable" }
case object LessThan30SpacesAvailable extends ParkingVacantSpacesEnum { override def toString = "lessThan30SpacesAvailable" }
case object LessThan40SpacesAvailable extends ParkingVacantSpacesEnum { override def toString = "lessThan40SpacesAvailable" }
case object LessThan50SpacesAvailable extends ParkingVacantSpacesEnum { override def toString = "lessThan50SpacesAvailable" }
case object UnknownValue42 extends ParkingVacantSpacesEnum { override def toString = "unknown" }
case object OtherValue72 extends ParkingVacantSpacesEnum { override def toString = "other" }



case class ParkingVehicle(parkingRecordReference: nu.ndw._ParkingRecordVersionedReference,
  parkingSpaceReference: Option[String] = None,
  groupOfParkingSpacesReference: Seq[String] = Nil,
  parkingPermit: Seq[nu.ndw.ParkingPermit] = Nil,
  vehicle: nu.ndw.Vehicle,
  individualCharge: Option[nu.ndw.IndividualCharge] = None,
  parkingPeriod: Option[nu.ndw.OverallPeriod] = None,
  parkingVehicleExtension: Option[nu.ndw._ExtensionType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  @JsonIgnore lazy val id = attributes("@id").as[String]
  @JsonIgnore lazy val version = attributes("@version").as[String]
}

      



case class ParkingVehiclesPublication(parkingTableReference: Seq[nu.ndw._ParkingTableVersionedReference] = Nil,
  parkingVehicle: Seq[nu.ndw.ParkingVehicle] = Nil)
      



case class ParkingVMS(vmsUnitUsedToManageParking: nu.ndw._VmsUnitRecordVersionedReference,
  vmsOperator: Seq[nu.ndw.Contactable] = Nil,
  parkingVMSExtension: Option[nu.ndw._ExtensionType] = None)
      


sealed trait PayloadPublication {
  def feedDescription: Option[nu.ndw.MultilingualString]
  def feedType: Option[String]
  def publicationTime: javax.xml.datatype.XMLGregorianCalendar
  def publicationCreator: nu.ndw.InternationalIdentifier
  def payloadPublicationExtension: Option[nu.ndw._ExtensionType]
  def lang: String
}

sealed trait PaymentCardBrandsEnum

object PaymentCardBrandsEnum {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[nu.ndw.PaymentCardBrandsEnum]): PaymentCardBrandsEnum = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: PaymentCardBrandsEnum) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
}

case object AmericanExpress extends PaymentCardBrandsEnum { override def toString = "americanExpress" }
case object Cirrus extends PaymentCardBrandsEnum { override def toString = "cirrus" }
case object DinersClub extends PaymentCardBrandsEnum { override def toString = "dinersClub" }
case object DiscoverCard extends PaymentCardBrandsEnum { override def toString = "discoverCard" }
case object GiroCard extends PaymentCardBrandsEnum { override def toString = "giroCard" }
case object Maestro extends PaymentCardBrandsEnum { override def toString = "maestro" }
case object MasterCard extends PaymentCardBrandsEnum { override def toString = "masterCard" }
case object Visa extends PaymentCardBrandsEnum { override def toString = "visa" }
case object VPay extends PaymentCardBrandsEnum { override def toString = "vPay" }
case object OtherValue73 extends PaymentCardBrandsEnum { override def toString = "other" }

sealed trait PaymentCardTypesEnum

object PaymentCardTypesEnum {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[nu.ndw.PaymentCardTypesEnum]): PaymentCardTypesEnum = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: PaymentCardTypesEnum) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
}

case object CreditCard extends PaymentCardTypesEnum { override def toString = "creditCard" }
case object DebitCard extends PaymentCardTypesEnum { override def toString = "debitCard" }
case object ChargeCard extends PaymentCardTypesEnum { override def toString = "chargeCard" }
case object FleetCard extends PaymentCardTypesEnum { override def toString = "fleetCard" }
case object StoredValueCard extends PaymentCardTypesEnum { override def toString = "storedValueCard" }
case object OtherValue18 extends PaymentCardTypesEnum { override def toString = "other" }



case class PcuFlowValue(dataError: Option[Boolean] = None,
  reasonForDataError: Option[nu.ndw.MultilingualString] = None,
  dataValueExtension: Option[nu.ndw._ExtensionType] = None,
  pcuFlowRate: Int,
  pcuFlowValueExtension: Option[nu.ndw._ExtensionType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) extends DataValue {
  @JsonIgnore lazy val accuracy = attributes.get("@accuracy") map { _.as[Float]}
  @JsonIgnore lazy val computationalMethod = attributes.get("@computationalMethod") map { _.as[ComputationMethodEnum]}
  @JsonIgnore lazy val numberOfIncompleteInputs = attributes.get("@numberOfIncompleteInputs") map { _.as[Int]}
  @JsonIgnore lazy val numberOfInputValuesUsed = attributes.get("@numberOfInputValuesUsed") map { _.as[Int]}
  @JsonIgnore lazy val smoothingFactor = attributes.get("@smoothingFactor") map { _.as[Float]}
  @JsonIgnore lazy val standardDeviation = attributes.get("@standardDeviation") map { _.as[Float]}
  @JsonIgnore lazy val supplierCalculatedDataQuality = attributes.get("@supplierCalculatedDataQuality") map { _.as[Float]}
}

      



case class PercentageDistanceAlongLinearElement(distanceAlongLinearElementExtension: Option[nu.ndw._ExtensionType] = None,
  percentageDistanceAlong: Float,
  percentageDistanceAlongLinearElementExtension: Option[nu.ndw._ExtensionType] = None) extends DistanceAlongLinearElement
      



case class PercentageValue(dataError: Option[Boolean] = None,
  reasonForDataError: Option[nu.ndw.MultilingualString] = None,
  dataValueExtension: Option[nu.ndw._ExtensionType] = None,
  percentage: Float,
  percentageValueExtension: Option[nu.ndw._ExtensionType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) extends DataValue {
  @JsonIgnore lazy val accuracy = attributes.get("@accuracy") map { _.as[Float]}
  @JsonIgnore lazy val computationalMethod = attributes.get("@computationalMethod") map { _.as[ComputationMethodEnum]}
  @JsonIgnore lazy val numberOfIncompleteInputs = attributes.get("@numberOfIncompleteInputs") map { _.as[Int]}
  @JsonIgnore lazy val numberOfInputValuesUsed = attributes.get("@numberOfInputValuesUsed") map { _.as[Int]}
  @JsonIgnore lazy val smoothingFactor = attributes.get("@smoothingFactor") map { _.as[Float]}
  @JsonIgnore lazy val standardDeviation = attributes.get("@standardDeviation") map { _.as[Float]}
  @JsonIgnore lazy val supplierCalculatedDataQuality = attributes.get("@supplierCalculatedDataQuality") map { _.as[Float]}
}

      



case class Period(startOfPeriod: Option[javax.xml.datatype.XMLGregorianCalendar] = None,
  endOfPeriod: Option[javax.xml.datatype.XMLGregorianCalendar] = None,
  periodName: Option[nu.ndw.MultilingualString] = None,
  recurringTimePeriodOfDay: Seq[nu.ndw.TimePeriodOfDay] = Nil,
  recurringDayWeekMonthPeriod: Seq[nu.ndw.DayWeekMonth] = Nil,
  periodExtension: Option[nu.ndw._PeriodExtensionType] = None)
      



case class PeriodExtended(recurringSpecialDay: Seq[nu.ndw.SpecialDay] = Nil)
      



case class PermitsAndProhibitions(activity: nu.ndw.RestAreaActivityEnum,
  regulation: nu.ndw.RegulationEnum,
  permitsAndProhibitionsExtension: Option[nu.ndw._ExtensionType] = None)
      

sealed trait PermitTypeEnum

object PermitTypeEnum {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[nu.ndw.PermitTypeEnum]): PermitTypeEnum = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: PermitTypeEnum) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
}

case object BlueZonePermit extends PermitTypeEnum { override def toString = "blueZonePermit" }
case object CareTakingPermit extends PermitTypeEnum { override def toString = "careTakingPermit" }
case object CarpoolingPermit extends PermitTypeEnum { override def toString = "carpoolingPermit" }
case object CarSharingPermit extends PermitTypeEnum { override def toString = "carSharingPermit" }
case object DisabledPermit extends PermitTypeEnum { override def toString = "disabledPermit" }
case object EmergencyVehiclePermit extends PermitTypeEnum { override def toString = "emergencyVehiclePermit" }
case object EmployeePermit extends PermitTypeEnum { override def toString = "employeePermit" }
case object FairPermit extends PermitTypeEnum { override def toString = "fairPermit" }
case object GovernmentPermit extends PermitTypeEnum { override def toString = "governmentPermit" }
case object MaintenanceVehiclePermit extends PermitTypeEnum { override def toString = "maintenanceVehiclePermit" }
case object ResidentPermit extends PermitTypeEnum { override def toString = "residentPermit" }
case object RoadWorksPermit extends PermitTypeEnum { override def toString = "roadWorksPermit" }
case object SpecificIdentifiedVehiclePermit extends PermitTypeEnum { override def toString = "specificIdentifiedVehiclePermit" }
case object TaxiPermit extends PermitTypeEnum { override def toString = "taxiPermit" }
case object OtherValue17 extends PermitTypeEnum { override def toString = "other" }

sealed trait PersonCategoryEnum

object PersonCategoryEnum {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[nu.ndw.PersonCategoryEnum]): PersonCategoryEnum = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: PersonCategoryEnum) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
}

case object Adult extends PersonCategoryEnum { override def toString = "adult" }
case object Child extends PersonCategoryEnum { override def toString = "child" }
case object EmergencyServicesPerson extends PersonCategoryEnum { override def toString = "emergencyServicesPerson" }
case object Fireman extends PersonCategoryEnum { override def toString = "fireman" }
case object Infant extends PersonCategoryEnum { override def toString = "infant" }
case object MedicalStaff extends PersonCategoryEnum { override def toString = "medicalStaff" }
case object MemberOfThePublic extends PersonCategoryEnum { override def toString = "memberOfThePublic" }
case object Policeman extends PersonCategoryEnum { override def toString = "policeman" }
case object Politician extends PersonCategoryEnum { override def toString = "politician" }
case object PublicTransportPassenger extends PersonCategoryEnum { override def toString = "publicTransportPassenger" }
case object SickPerson extends PersonCategoryEnum { override def toString = "sickPerson" }
case object TrafficOfficer extends PersonCategoryEnum { override def toString = "trafficOfficer" }
case object TrafficWarden extends PersonCategoryEnum { override def toString = "trafficWarden" }
case object VeryImportantPerson extends PersonCategoryEnum { override def toString = "veryImportantPerson" }

sealed trait PhysicalMountingEnum

object PhysicalMountingEnum {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[nu.ndw.PhysicalMountingEnum]): PhysicalMountingEnum = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: PhysicalMountingEnum) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
}

case object CentralReservationMounted extends PhysicalMountingEnum { override def toString = "centralReservationMounted" }
case object GantryMounted extends PhysicalMountingEnum { override def toString = "gantryMounted" }
case object OverheadBridgeMounted extends PhysicalMountingEnum { override def toString = "overheadBridgeMounted" }
case object RoadsideCantileverMounted extends PhysicalMountingEnum { override def toString = "roadsideCantileverMounted" }
case object RoadsideMounted extends PhysicalMountingEnum { override def toString = "roadsideMounted" }
case object TrailerMounted extends PhysicalMountingEnum { override def toString = "trailerMounted" }
case object TunnelEntranceMounted extends PhysicalMountingEnum { override def toString = "tunnelEntranceMounted" }
case object VehicleMounted extends PhysicalMountingEnum { override def toString = "vehicleMounted" }



case class PictogramDisplayAreaSettings(pictogramLanternsOn: Option[Boolean] = None,
  pictogramLuminanceOverride: Option[Boolean] = None,
  pictogramLuminanceLevel: Option[Int] = None,
  pictogramLuminanceLevelName: Option[nu.ndw.VmsLuminanceLevelEnum] = None,
  pictogramDisplayAreaSettingsExtension: Option[nu.ndw._ExtensionType] = None)
      

sealed trait PlacesEnum

object PlacesEnum {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[nu.ndw.PlacesEnum]): PlacesEnum = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: PlacesEnum) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
}

case object AroundBendsInTheRoad extends PlacesEnum { override def toString = "aroundBendsInTheRoad" }
case object AtCustomsPosts extends PlacesEnum { override def toString = "atCustomsPosts" }
case object AtHighAltitudes extends PlacesEnum { override def toString = "atHighAltitudes" }
case object AtTollPlazas extends PlacesEnum { override def toString = "atTollPlazas" }
case object InBuiltUpAreas extends PlacesEnum { override def toString = "inBuiltUpAreas" }
case object InContraflowSections extends PlacesEnum { override def toString = "inContraflowSections" }
case object InForestedAreas extends PlacesEnum { override def toString = "inForestedAreas" }
case object InGalleries extends PlacesEnum { override def toString = "inGalleries" }
case object InLowLyingAreas extends PlacesEnum { override def toString = "inLowLyingAreas" }
case object InRoadworksAreas extends PlacesEnum { override def toString = "inRoadworksAreas" }
case object InRuralAreas extends PlacesEnum { override def toString = "inRuralAreas" }
case object InShadedAreas extends PlacesEnum { override def toString = "inShadedAreas" }
case object InTheCityCentre extends PlacesEnum { override def toString = "inTheCityCentre" }
case object InTheInnerCityAreas extends PlacesEnum { override def toString = "inTheInnerCityAreas" }
case object InTunnels extends PlacesEnum { override def toString = "inTunnels" }
case object OnBridges extends PlacesEnum { override def toString = "onBridges" }
case object OnDownHillSections extends PlacesEnum { override def toString = "onDownHillSections" }
case object OnDualCarriagewaySections extends PlacesEnum { override def toString = "onDualCarriagewaySections" }
case object OnElevatedSections extends PlacesEnum { override def toString = "onElevatedSections" }
case object OnEnteringOrLeavingTunnels extends PlacesEnum { override def toString = "onEnteringOrLeavingTunnels" }
case object OnEnteringTheCountry extends PlacesEnum { override def toString = "onEnteringTheCountry" }
case object OnFlyovers extends PlacesEnum { override def toString = "onFlyovers" }
case object OnLeavingTheCountry extends PlacesEnum { override def toString = "onLeavingTheCountry" }
case object OnMotorways extends PlacesEnum { override def toString = "onMotorways" }
case object OnNonMotorways extends PlacesEnum { override def toString = "onNonMotorways" }
case object OnPasses extends PlacesEnum { override def toString = "onPasses" }
case object OnRoundabouts extends PlacesEnum { override def toString = "onRoundabouts" }
case object OnSingleCarriagewaySections extends PlacesEnum { override def toString = "onSingleCarriagewaySections" }
case object OnSlipRoads extends PlacesEnum { override def toString = "onSlipRoads" }
case object OnUndergroundSections extends PlacesEnum { override def toString = "onUndergroundSections" }
case object OnUnderpasses extends PlacesEnum { override def toString = "onUnderpasses" }
case object OnUpHillSections extends PlacesEnum { override def toString = "onUpHillSections" }
case object OverTheCrestOfHills extends PlacesEnum { override def toString = "overTheCrestOfHills" }
case object OtherValue16 extends PlacesEnum { override def toString = "other" }



case class Point(groupOfLocationsExtension: Option[nu.ndw._ExtensionType] = None,
  externalReferencing: Seq[nu.ndw.ExternalReferencing] = Nil,
  locationForDisplay: Option[nu.ndw.PointCoordinates] = None,
  locationExtension: Option[nu.ndw._ExtensionType] = None,
  supplementaryPositionalDescription: Option[nu.ndw.SupplementaryPositionalDescription] = None,
  destination: Option[nu.ndw.Destination] = None,
  networkLocationExtension: Option[nu.ndw._ExtensionType] = None,
  tpegPointLocation: Option[nu.ndw.TpegPointLocation] = None,
  alertCPoint: Option[nu.ndw.AlertCPoint] = None,
  pointAlongLinearElement: Option[nu.ndw.PointAlongLinearElement] = None,
  pointByCoordinates: Option[nu.ndw.PointByCoordinates] = None,
  pointExtension: Option[nu.ndw._PointExtensionType] = None) extends NetworkLocation
      



case class PointAlongLinearElement(administrativeAreaOfPoint: Option[nu.ndw.MultilingualString] = None,
  directionBoundAtPoint: Option[nu.ndw.DirectionEnum] = None,
  directionRelativeAtPoint: Option[nu.ndw.LinearReferencingDirectionEnum] = None,
  heightGradeOfPoint: Option[nu.ndw.HeightGradeEnum] = None,
  linearElement: nu.ndw.LinearElementable,
  distanceAlongLinearElement: nu.ndw.DistanceAlongLinearElement,
  pointAlongLinearElementExtension: Option[nu.ndw._ExtensionType] = None)
      



case class PointByCoordinates(bearing: Option[Int] = None,
  pointCoordinates: nu.ndw.PointCoordinates,
  pointByCoordinatesExtension: Option[nu.ndw._ExtensionType] = None)
      



case class PointCoordinates(latitude: Float,
  longitude: Float,
  pointCoordinatesExtension: Option[nu.ndw._ExtensionType] = None)
      



case class PointDestination(destinationExtension: Option[nu.ndw._ExtensionType] = None,
  point: nu.ndw.Point,
  pointDestinationExtension: Option[nu.ndw._ExtensionType] = None) extends Destination
      



case class PointExtended(description: Option[nu.ndw.MultilingualString] = None,
  junction: Option[nu.ndw.JunctionType] = None)
      

sealed trait PollutantTypeEnum

object PollutantTypeEnum {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[nu.ndw.PollutantTypeEnum]): PollutantTypeEnum = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: PollutantTypeEnum) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
}

case object BenzeneTolueneXylene extends PollutantTypeEnum { override def toString = "benzeneTolueneXylene" }
case object CarbonMonoxide extends PollutantTypeEnum { override def toString = "carbonMonoxide" }
case object Lead extends PollutantTypeEnum { override def toString = "lead" }
case object MethaneValue extends PollutantTypeEnum { override def toString = "methane" }
case object NitricOxide extends PollutantTypeEnum { override def toString = "nitricOxide" }
case object NitrogenDioxide extends PollutantTypeEnum { override def toString = "nitrogenDioxide" }
case object NitrogenMonoxide extends PollutantTypeEnum { override def toString = "nitrogenMonoxide" }
case object NitrogenOxides extends PollutantTypeEnum { override def toString = "nitrogenOxides" }
case object NonMethaneHydrocarbons extends PollutantTypeEnum { override def toString = "nonMethaneHydrocarbons" }
case object Ozone extends PollutantTypeEnum { override def toString = "ozone" }
case object Particulates10 extends PollutantTypeEnum { override def toString = "particulates10" }
case object PolycyclicAromaticHydrocarbons extends PollutantTypeEnum { override def toString = "polycyclicAromaticHydrocarbons" }
case object PrimaryParticulate extends PollutantTypeEnum { override def toString = "primaryParticulate" }
case object SulphurDioxide extends PollutantTypeEnum { override def toString = "sulphurDioxide" }
case object TotalHydrocarbons extends PollutantTypeEnum { override def toString = "totalHydrocarbons" }



case class PollutionType(pollutantType: nu.ndw.PollutantTypeEnum,
  pollutantConcentration: Option[nu.ndw.MicrogramsConcentrationValue] = None,
  pollutionExtension: Option[nu.ndw._ExtensionType] = None)
      



case class PollutionInformationType(measurementOrCalculationPeriod: Option[Float] = None,
  measurementOrCalculationTime: Option[javax.xml.datatype.XMLGregorianCalendar] = None,
  pertinentLocation: Option[nu.ndw.GroupOfLocations] = None,
  basicDataExtension: Option[nu.ndw._ExtensionType] = None,
  weatherDataExtension: Option[nu.ndw._ExtensionType] = None,
  pollution: Seq[nu.ndw.PollutionType] = Nil,
  pollutionInformationExtension: Option[nu.ndw._ExtensionType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) extends WeatherData {
  @JsonIgnore lazy val measurementOrCalculatedTimePrecision = attributes.get("@measurementOrCalculatedTimePrecision") map { _.as[TimePrecisionEnum]}
}

      



case class PolygonArea(sectionName: Option[nu.ndw.MultilingualString] = None,
  pointCoordinates: Seq[nu.ndw._PolygonAreaIndexPointCoordinates] = Nil,
  polygonAreaExtension: Option[nu.ndw._ExtensionType] = None)
      



case class PoorEnvironmentConditions(situationRecordCreationReference: Option[String] = None,
  situationRecordCreationTime: javax.xml.datatype.XMLGregorianCalendar,
  situationRecordObservationTime: Option[javax.xml.datatype.XMLGregorianCalendar] = None,
  situationRecordVersionTime: javax.xml.datatype.XMLGregorianCalendar,
  situationRecordFirstSupplierVersionTime: Option[javax.xml.datatype.XMLGregorianCalendar] = None,
  confidentialityOverride: Option[nu.ndw.ConfidentialityValueEnum] = None,
  probabilityOfOccurrence: nu.ndw.ProbabilityOfOccurrenceEnum,
  severity: Option[nu.ndw.SeverityEnum] = None,
  source: Option[nu.ndw.Source] = None,
  validity: nu.ndw.Validity,
  impact: Option[nu.ndw.Impact] = None,
  cause: Option[nu.ndw.Cause] = None,
  generalPublicComment: Seq[nu.ndw.Comment] = Nil,
  nonGeneralPublicComment: Seq[nu.ndw.Comment] = Nil,
  urlLink: Seq[nu.ndw.UrlLink] = Nil,
  groupOfLocations: nu.ndw.GroupOfLocations,
  management: Option[nu.ndw.Management] = None,
  situationRecordExtension: Option[nu.ndw._SituationRecordExtensionType] = None,
  trafficElementExtension: Option[nu.ndw._ExtensionType] = None,
  drivingConditionType: Option[nu.ndw.DrivingConditionTypeEnum] = None,
  conditionsExtension: Option[nu.ndw._ExtensionType] = None,
  poorEnvironmentType: Seq[nu.ndw.PoorEnvironmentTypeEnum] = Nil,
  precipitationDetail: Option[nu.ndw.PrecipitationDetail] = None,
  visibility: Option[nu.ndw.Visibility] = None,
  pollution: Option[nu.ndw.PollutionType] = None,
  temperature: Option[nu.ndw.TemperatureType] = None,
  wind: Option[nu.ndw.Wind] = None,
  humidity: Option[nu.ndw.Humidity] = None,
  poorEnvironmentConditionsExtension: Option[nu.ndw._ExtensionType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) extends Conditionsable {
  @JsonIgnore lazy val id = attributes("@id").as[String]
  @JsonIgnore lazy val version = attributes("@version").as[String]
}

      

sealed trait PoorEnvironmentTypeEnum

object PoorEnvironmentTypeEnum {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[nu.ndw.PoorEnvironmentTypeEnum]): PoorEnvironmentTypeEnum = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: PoorEnvironmentTypeEnum) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
}

case object BadWeather extends PoorEnvironmentTypeEnum { override def toString = "badWeather" }
case object Blizzard extends PoorEnvironmentTypeEnum { override def toString = "blizzard" }
case object BlowingDust extends PoorEnvironmentTypeEnum { override def toString = "blowingDust" }
case object BlowingSnow extends PoorEnvironmentTypeEnum { override def toString = "blowingSnow" }
case object Crosswinds extends PoorEnvironmentTypeEnum { override def toString = "crosswinds" }
case object DamagingHail extends PoorEnvironmentTypeEnum { override def toString = "damagingHail" }
case object DenseFog extends PoorEnvironmentTypeEnum { override def toString = "denseFog" }
case object Eclipse extends PoorEnvironmentTypeEnum { override def toString = "eclipse" }
case object ExtremeCold extends PoorEnvironmentTypeEnum { override def toString = "extremeCold" }
case object ExtremeHeat extends PoorEnvironmentTypeEnum { override def toString = "extremeHeat" }
case object FogValue extends PoorEnvironmentTypeEnum { override def toString = "fog" }
case object FreezingFog extends PoorEnvironmentTypeEnum { override def toString = "freezingFog" }
case object Frost extends PoorEnvironmentTypeEnum { override def toString = "frost" }
case object Gales extends PoorEnvironmentTypeEnum { override def toString = "gales" }
case object GustyWinds extends PoorEnvironmentTypeEnum { override def toString = "gustyWinds" }
case object HailValue extends PoorEnvironmentTypeEnum { override def toString = "hail" }
case object HeavyFrost extends PoorEnvironmentTypeEnum { override def toString = "heavyFrost" }
case object HeavyRain extends PoorEnvironmentTypeEnum { override def toString = "heavyRain" }
case object HeavySnowfall extends PoorEnvironmentTypeEnum { override def toString = "heavySnowfall" }
case object HurricaneForceWinds extends PoorEnvironmentTypeEnum { override def toString = "hurricaneForceWinds" }
case object LowSunGlare extends PoorEnvironmentTypeEnum { override def toString = "lowSunGlare" }
case object ModerateFog extends PoorEnvironmentTypeEnum { override def toString = "moderateFog" }
case object OzonePollution extends PoorEnvironmentTypeEnum { override def toString = "ozonePollution" }
case object Pollution extends PoorEnvironmentTypeEnum { override def toString = "pollution" }
case object PatchyFog extends PoorEnvironmentTypeEnum { override def toString = "patchyFog" }
case object PrecipitationInTheArea extends PoorEnvironmentTypeEnum { override def toString = "precipitationInTheArea" }
case object RainValue2 extends PoorEnvironmentTypeEnum { override def toString = "rain" }
case object RainChangingToSnow extends PoorEnvironmentTypeEnum { override def toString = "rainChangingToSnow" }
case object SandStorms extends PoorEnvironmentTypeEnum { override def toString = "sandStorms" }
case object SevereExhaustPollution extends PoorEnvironmentTypeEnum { override def toString = "severeExhaustPollution" }
case object SevereSmog extends PoorEnvironmentTypeEnum { override def toString = "severeSmog" }
case object Showers extends PoorEnvironmentTypeEnum { override def toString = "showers" }
case object SleetValue extends PoorEnvironmentTypeEnum { override def toString = "sleet" }
case object SmogAlert extends PoorEnvironmentTypeEnum { override def toString = "smogAlert" }
case object SmokeHazard extends PoorEnvironmentTypeEnum { override def toString = "smokeHazard" }
case object SnowChangingToRain extends PoorEnvironmentTypeEnum { override def toString = "snowChangingToRain" }
case object Snowfall extends PoorEnvironmentTypeEnum { override def toString = "snowfall" }
case object SprayHazard extends PoorEnvironmentTypeEnum { override def toString = "sprayHazard" }
case object StormForceWinds extends PoorEnvironmentTypeEnum { override def toString = "stormForceWinds" }
case object StrongGustsOfWind extends PoorEnvironmentTypeEnum { override def toString = "strongGustsOfWind" }
case object StrongWinds extends PoorEnvironmentTypeEnum { override def toString = "strongWinds" }
case object SwarmsOfInsects extends PoorEnvironmentTypeEnum { override def toString = "swarmsOfInsects" }
case object TemperatureFalling extends PoorEnvironmentTypeEnum { override def toString = "temperatureFalling" }
case object Thunderstorms extends PoorEnvironmentTypeEnum { override def toString = "thunderstorms" }
case object Tornadoes extends PoorEnvironmentTypeEnum { override def toString = "tornadoes" }
case object VeryStrongGustsOfWind extends PoorEnvironmentTypeEnum { override def toString = "veryStrongGustsOfWind" }
case object VisibilityReduced extends PoorEnvironmentTypeEnum { override def toString = "visibilityReduced" }
case object WhiteOut extends PoorEnvironmentTypeEnum { override def toString = "whiteOut" }
case object WinterStorm extends PoorEnvironmentTypeEnum { override def toString = "winterStorm" }

sealed trait PositionAbsoluteEnum

object PositionAbsoluteEnum {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[nu.ndw.PositionAbsoluteEnum]): PositionAbsoluteEnum = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: PositionAbsoluteEnum) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
}

case object OnLeft extends PositionAbsoluteEnum { override def toString = "onLeft" }
case object OnRight extends PositionAbsoluteEnum { override def toString = "onRight" }
case object AtTop extends PositionAbsoluteEnum { override def toString = "atTop" }
case object AtBottom extends PositionAbsoluteEnum { override def toString = "atBottom" }

sealed trait PositionRelativeEnum

object PositionRelativeEnum {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[nu.ndw.PositionRelativeEnum]): PositionRelativeEnum = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: PositionRelativeEnum) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
}

case object Above extends PositionRelativeEnum { override def toString = "above" }
case object Below extends PositionRelativeEnum { override def toString = "below" }
case object ToTheLeft extends PositionRelativeEnum { override def toString = "toTheLeft" }
case object ToTheRight extends PositionRelativeEnum { override def toString = "toTheRight" }



case class PrecipitationDetail(precipitationType: Option[nu.ndw.PrecipitationTypeEnum] = None,
  precipitationIntensity: Option[nu.ndw.PrecipitationIntensityValue] = None,
  depositionDepth: Option[nu.ndw.FloatingPointMetreDistanceValue] = None,
  precipitationDetailExtension: Option[nu.ndw._ExtensionType] = None)
      



case class PrecipitationInformation(measurementOrCalculationPeriod: Option[Float] = None,
  measurementOrCalculationTime: Option[javax.xml.datatype.XMLGregorianCalendar] = None,
  pertinentLocation: Option[nu.ndw.GroupOfLocations] = None,
  basicDataExtension: Option[nu.ndw._ExtensionType] = None,
  weatherDataExtension: Option[nu.ndw._ExtensionType] = None,
  noPrecipitation: Option[Boolean] = None,
  precipitationDetail: Option[nu.ndw.PrecipitationDetail] = None,
  precipitationInformationExtension: Option[nu.ndw._ExtensionType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) extends WeatherData {
  @JsonIgnore lazy val measurementOrCalculatedTimePrecision = attributes.get("@measurementOrCalculatedTimePrecision") map { _.as[TimePrecisionEnum]}
}

      



case class PrecipitationIntensityValue(dataError: Option[Boolean] = None,
  reasonForDataError: Option[nu.ndw.MultilingualString] = None,
  dataValueExtension: Option[nu.ndw._ExtensionType] = None,
  millimetresPerHourIntensity: Float,
  precipitationIntensityValueExtension: Option[nu.ndw._ExtensionType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) extends DataValue {
  @JsonIgnore lazy val accuracy = attributes.get("@accuracy") map { _.as[Float]}
  @JsonIgnore lazy val computationalMethod = attributes.get("@computationalMethod") map { _.as[ComputationMethodEnum]}
  @JsonIgnore lazy val numberOfIncompleteInputs = attributes.get("@numberOfIncompleteInputs") map { _.as[Int]}
  @JsonIgnore lazy val numberOfInputValuesUsed = attributes.get("@numberOfInputValuesUsed") map { _.as[Int]}
  @JsonIgnore lazy val smoothingFactor = attributes.get("@smoothingFactor") map { _.as[Float]}
  @JsonIgnore lazy val standardDeviation = attributes.get("@standardDeviation") map { _.as[Float]}
  @JsonIgnore lazy val supplierCalculatedDataQuality = attributes.get("@supplierCalculatedDataQuality") map { _.as[Float]}
}

      

sealed trait PrecipitationTypeEnum

object PrecipitationTypeEnum {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[nu.ndw.PrecipitationTypeEnum]): PrecipitationTypeEnum = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: PrecipitationTypeEnum) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
}

case object Drizzle extends PrecipitationTypeEnum { override def toString = "drizzle" }
case object FreezingRainValue extends PrecipitationTypeEnum { override def toString = "freezingRain" }
case object Hail extends PrecipitationTypeEnum { override def toString = "hail" }
case object RainValue extends PrecipitationTypeEnum { override def toString = "rain" }
case object Sleet extends PrecipitationTypeEnum { override def toString = "sleet" }
case object SnowValue extends PrecipitationTypeEnum { override def toString = "snow" }



case class PredefinedItinerary(predefinedLocationContainerExtension: Option[nu.ndw._ExtensionType] = None,
  predefinedItineraryName: Option[nu.ndw.MultilingualString] = None,
  predefinedLocation: Seq[nu.ndw._PredefinedItineraryIndexPredefinedLocation] = Nil,
  predefinedItineraryExtension: Option[nu.ndw._ExtensionType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) extends PredefinedLocationContainer {
  @JsonIgnore lazy val id = attributes("@id").as[String]
  @JsonIgnore lazy val version = attributes("@version").as[String]
}

      



case class PredefinedLocation(predefinedLocationContainerExtension: Option[nu.ndw._ExtensionType] = None,
  predefinedLocationName: Option[nu.ndw.MultilingualString] = None,
  location: nu.ndw.Location,
  predefinedLocationExtension: Option[nu.ndw._ExtensionType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) extends PredefinedLocationContainer {
  @JsonIgnore lazy val id = attributes("@id").as[String]
  @JsonIgnore lazy val version = attributes("@version").as[String]
}

      


sealed trait PredefinedLocationContainer {
  def predefinedLocationContainerExtension: Option[nu.ndw._ExtensionType]
}



case class PredefinedLocationsPublication(feedDescription: Option[nu.ndw.MultilingualString] = None,
  feedType: Option[String] = None,
  publicationTime: javax.xml.datatype.XMLGregorianCalendar,
  publicationCreator: nu.ndw.InternationalIdentifier,
  payloadPublicationExtension: Option[nu.ndw._ExtensionType] = None,
  headerInformation: nu.ndw.HeaderInformation,
  predefinedLocationContainer: Seq[nu.ndw.PredefinedLocationContainer] = Nil,
  predefinedLocationsPublicationExtension: Option[nu.ndw._ExtensionType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) extends PayloadPublication {
  @JsonIgnore lazy val lang = attributes("@lang").as[String]
}

      



case class PredefinedNonOrderedLocationGroup(predefinedLocationContainerExtension: Option[nu.ndw._ExtensionType] = None,
  predefinedNonOrderedLocationGroupName: Option[nu.ndw.MultilingualString] = None,
  predefinedLocation: Seq[nu.ndw.PredefinedLocation] = Nil,
  predefinedNonOrderedLocationGroupExtension: Option[nu.ndw._ExtensionType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) extends PredefinedLocationContainer {
  @JsonIgnore lazy val id = attributes("@id").as[String]
  @JsonIgnore lazy val version = attributes("@version").as[String]
}

      

sealed trait ProbabilityOfOccurrenceEnum

object ProbabilityOfOccurrenceEnum {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[nu.ndw.ProbabilityOfOccurrenceEnum]): ProbabilityOfOccurrenceEnum = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: ProbabilityOfOccurrenceEnum) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
}

case object Certain extends ProbabilityOfOccurrenceEnum { override def toString = "certain" }
case object Probable extends ProbabilityOfOccurrenceEnum { override def toString = "probable" }
case object RiskOf extends ProbabilityOfOccurrenceEnum { override def toString = "riskOf" }



case class PublicEvent(situationRecordCreationReference: Option[String] = None,
  situationRecordCreationTime: javax.xml.datatype.XMLGregorianCalendar,
  situationRecordObservationTime: Option[javax.xml.datatype.XMLGregorianCalendar] = None,
  situationRecordVersionTime: javax.xml.datatype.XMLGregorianCalendar,
  situationRecordFirstSupplierVersionTime: Option[javax.xml.datatype.XMLGregorianCalendar] = None,
  confidentialityOverride: Option[nu.ndw.ConfidentialityValueEnum] = None,
  probabilityOfOccurrence: nu.ndw.ProbabilityOfOccurrenceEnum,
  severity: Option[nu.ndw.SeverityEnum] = None,
  source: Option[nu.ndw.Source] = None,
  validity: nu.ndw.Validity,
  impact: Option[nu.ndw.Impact] = None,
  cause: Option[nu.ndw.Cause] = None,
  generalPublicComment: Seq[nu.ndw.Comment] = Nil,
  nonGeneralPublicComment: Seq[nu.ndw.Comment] = Nil,
  urlLink: Seq[nu.ndw.UrlLink] = Nil,
  groupOfLocations: nu.ndw.GroupOfLocations,
  management: Option[nu.ndw.Management] = None,
  situationRecordExtension: Option[nu.ndw._SituationRecordExtensionType] = None,
  trafficElementExtension: Option[nu.ndw._ExtensionType] = None,
  mobilityOfActivity: Option[nu.ndw.Mobility] = None,
  activityExtension: Option[nu.ndw._ExtensionType] = None,
  publicEventType: nu.ndw.PublicEventTypeEnum,
  publicEventExtension: Option[nu.ndw._ExtensionType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) extends Activity {
  @JsonIgnore lazy val id = attributes("@id").as[String]
  @JsonIgnore lazy val version = attributes("@version").as[String]
}

      

sealed trait PublicEventType2Enum

object PublicEventType2Enum {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[nu.ndw.PublicEventType2Enum]): PublicEventType2Enum = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: PublicEventType2Enum) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
}

case object OpenAirConcert extends PublicEventType2Enum { override def toString = "openAirConcert" }
case object SoundAndLightShow extends PublicEventType2Enum { override def toString = "soundAndLightShow" }
case object ArtEvent extends PublicEventType2Enum { override def toString = "artEvent" }
case object FlowerEvent extends PublicEventType2Enum { override def toString = "flowerEvent" }
case object BeerFestival extends PublicEventType2Enum { override def toString = "beerFestival" }
case object FoodFestival extends PublicEventType2Enum { override def toString = "foodFestival" }
case object WineFestival extends PublicEventType2Enum { override def toString = "wineFestival" }
case object TheatricalEvent extends PublicEventType2Enum { override def toString = "theatricalEvent" }
case object FireworkDisplay extends PublicEventType2Enum { override def toString = "fireworkDisplay" }
case object StreetFestival extends PublicEventType2Enum { override def toString = "streetFestival" }
case object FilmFestival extends PublicEventType2Enum { override def toString = "filmFestival" }
case object UnknownValue8 extends PublicEventType2Enum { override def toString = "unknown" }
case object OtherValue15 extends PublicEventType2Enum { override def toString = "other" }

sealed trait PublicEventTypeEnum

object PublicEventTypeEnum {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[nu.ndw.PublicEventTypeEnum]): PublicEventTypeEnum = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: PublicEventTypeEnum) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
}

case object AgriculturalShow extends PublicEventTypeEnum { override def toString = "agriculturalShow" }
case object AirShow extends PublicEventTypeEnum { override def toString = "airShow" }
case object AthleticsMeeting extends PublicEventTypeEnum { override def toString = "athleticsMeeting" }
case object CommercialEvent extends PublicEventTypeEnum { override def toString = "commercialEvent" }
case object CulturalEvent extends PublicEventTypeEnum { override def toString = "culturalEvent" }
case object BallGame extends PublicEventTypeEnum { override def toString = "ballGame" }
case object BaseballGame extends PublicEventTypeEnum { override def toString = "baseballGame" }
case object BasketballGame extends PublicEventTypeEnum { override def toString = "basketballGame" }
case object BicycleRace extends PublicEventTypeEnum { override def toString = "bicycleRace" }
case object BoatRace extends PublicEventTypeEnum { override def toString = "boatRace" }
case object BoatShow extends PublicEventTypeEnum { override def toString = "boatShow" }
case object BoxingTournament extends PublicEventTypeEnum { override def toString = "boxingTournament" }
case object BullFight extends PublicEventTypeEnum { override def toString = "bullFight" }
case object CeremonialEvent extends PublicEventTypeEnum { override def toString = "ceremonialEvent" }
case object Concert extends PublicEventTypeEnum { override def toString = "concert" }
case object CricketMatch extends PublicEventTypeEnum { override def toString = "cricketMatch" }
case object Exhibition extends PublicEventTypeEnum { override def toString = "exhibition" }
case object Fair extends PublicEventTypeEnum { override def toString = "fair" }
case object Festival extends PublicEventTypeEnum { override def toString = "festival" }
case object FilmTVMaking extends PublicEventTypeEnum { override def toString = "filmTVMaking" }
case object FootballMatchValue extends PublicEventTypeEnum { override def toString = "footballMatch" }
case object Funfair extends PublicEventTypeEnum { override def toString = "funfair" }
case object GardeningOrFlowerShow extends PublicEventTypeEnum { override def toString = "gardeningOrFlowerShow" }
case object GolfTournament extends PublicEventTypeEnum { override def toString = "golfTournament" }
case object HockeyGame extends PublicEventTypeEnum { override def toString = "hockeyGame" }
case object HorseRaceMeeting extends PublicEventTypeEnum { override def toString = "horseRaceMeeting" }
case object InternationalSportsMeeting extends PublicEventTypeEnum { override def toString = "internationalSportsMeeting" }
case object MajorEvent extends PublicEventTypeEnum { override def toString = "majorEvent" }
case object Marathon extends PublicEventTypeEnum { override def toString = "marathon" }
case object MarketValue extends PublicEventTypeEnum { override def toString = "market" }
case object Match extends PublicEventTypeEnum { override def toString = "match" }
case object MotorShow extends PublicEventTypeEnum { override def toString = "motorShow" }
case object MotorSportRaceMeeting extends PublicEventTypeEnum { override def toString = "motorSportRaceMeeting" }
case object Parade extends PublicEventTypeEnum { override def toString = "parade" }
case object Procession extends PublicEventTypeEnum { override def toString = "procession" }
case object RaceMeeting extends PublicEventTypeEnum { override def toString = "raceMeeting" }
case object RugbyMatch extends PublicEventTypeEnum { override def toString = "rugbyMatch" }
case object SeveralMajorEvents extends PublicEventTypeEnum { override def toString = "severalMajorEvents" }
case object Show extends PublicEventTypeEnum { override def toString = "show" }
case object ShowJumping extends PublicEventTypeEnum { override def toString = "showJumping" }
case object SportsMeeting extends PublicEventTypeEnum { override def toString = "sportsMeeting" }
case object StateOccasion extends PublicEventTypeEnum { override def toString = "stateOccasion" }
case object TennisTournament extends PublicEventTypeEnum { override def toString = "tennisTournament" }
case object Tournament extends PublicEventTypeEnum { override def toString = "tournament" }
case object TradeFair extends PublicEventTypeEnum { override def toString = "tradeFair" }
case object WaterSportsMeeting extends PublicEventTypeEnum { override def toString = "waterSportsMeeting" }
case object WinterSportsMeeting extends PublicEventTypeEnum { override def toString = "winterSportsMeeting" }
case object OtherValue74 extends PublicEventTypeEnum { override def toString = "other" }



case class PublicHolidayType(country: nu.ndw.CountryEnum,
  countrySubdivision: Option[String] = None,
  region: Option[nu.ndw.MultilingualString] = None,
  publicHolidayType: nu.ndw.PublicHolidayTypeEnum,
  publicHolidayName: Option[nu.ndw.MultilingualString] = None,
  publicHolidayExtension: Option[nu.ndw._ExtensionType] = None)
      

sealed trait PublicHolidayTypeEnum

object PublicHolidayTypeEnum {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[nu.ndw.PublicHolidayTypeEnum]): PublicHolidayTypeEnum = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: PublicHolidayTypeEnum) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
}

case object BetweenChristmasAndNewYear extends PublicHolidayTypeEnum { override def toString = "betweenChristmasAndNewYear" }
case object BoxingDay extends PublicHolidayTypeEnum { override def toString = "boxingDay" }
case object BridgeHoliday extends PublicHolidayTypeEnum { override def toString = "bridgeHoliday" }
case object ChristmasEve extends PublicHolidayTypeEnum { override def toString = "christmasEve" }
case object ChristmasDayAndBoxingDay extends PublicHolidayTypeEnum { override def toString = "christmasDayAndBoxingDay" }
case object ChristmasHolidayPeriod extends PublicHolidayTypeEnum { override def toString = "christmasHolidayPeriod" }
case object DayFollowingPublicHoliday extends PublicHolidayTypeEnum { override def toString = "dayFollowingPublicHoliday" }
case object EasterFridayHoliday extends PublicHolidayTypeEnum { override def toString = "easterFridayHoliday" }
case object EasterHolidayPeriod extends PublicHolidayTypeEnum { override def toString = "easterHolidayPeriod" }
case object EasterMondayHoliday extends PublicHolidayTypeEnum { override def toString = "easterMondayHoliday" }
case object EasterSaturday extends PublicHolidayTypeEnum { override def toString = "easterSaturday" }
case object EasterSunday extends PublicHolidayTypeEnum { override def toString = "easterSunday" }
case object EveOfPublicHoliday extends PublicHolidayTypeEnum { override def toString = "eveOfPublicHoliday" }
case object HolidayPeriod extends PublicHolidayTypeEnum { override def toString = "holidayPeriod" }
case object InLieuOfPublicHoliday extends PublicHolidayTypeEnum { override def toString = "inLieuOfPublicHoliday" }
case object January2ndHoliday extends PublicHolidayTypeEnum { override def toString = "january2ndHoliday" }
case object NewYearsDay extends PublicHolidayTypeEnum { override def toString = "newYearsDay" }
case object NewYearsEve extends PublicHolidayTypeEnum { override def toString = "newYearsEve" }
case object NotPublicHoliday extends PublicHolidayTypeEnum { override def toString = "notPublicHoliday" }
case object PublicHolidayValue extends PublicHolidayTypeEnum { override def toString = "publicHoliday" }
case object OtherValue75 extends PublicHolidayTypeEnum { override def toString = "other" }


sealed trait Referencable {
  def id: String
}



case class Reference(attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) extends Referencable {
  @JsonIgnore lazy val id = attributes("@id").as[String]
}

      



case class ReferenceSettings(predefinedNonOrderedLocationGroupReference: Option[nu.ndw._PredefinedNonOrderedLocationGroupVersionedReference] = None,
  trafficStatusDefault: Option[nu.ndw.TrafficStatusEnum] = None,
  referenceSettingsExtension: Option[nu.ndw._ExtensionType] = None)
      



case class Referent(referentIdentifier: String,
  referentName: Option[String] = None,
  referentType: nu.ndw.ReferentTypeEnum,
  referentDescription: Option[nu.ndw.MultilingualString] = None,
  pointCoordinates: Option[nu.ndw.PointCoordinates] = None,
  referentExtension: Option[nu.ndw._ExtensionType] = None)
      

sealed trait ReferentTypeEnum

object ReferentTypeEnum {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[nu.ndw.ReferentTypeEnum]): ReferentTypeEnum = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: ReferentTypeEnum) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
}

case object Boundary extends ReferentTypeEnum { override def toString = "boundary" }
case object IntersectionValue extends ReferentTypeEnum { override def toString = "intersection" }
case object ReferenceMarker extends ReferentTypeEnum { override def toString = "referenceMarker" }
case object Landmark extends ReferentTypeEnum { override def toString = "landmark" }
case object RoadNodeValue extends ReferentTypeEnum { override def toString = "roadNode" }

sealed trait RegulationEnum

object RegulationEnum {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[nu.ndw.RegulationEnum]): RegulationEnum = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: RegulationEnum) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
}

case object Permitted extends RegulationEnum { override def toString = "permitted" }
case object Prohibited extends RegulationEnum { override def toString = "prohibited" }
case object Punishable extends RegulationEnum { override def toString = "punishable" }
case object SeasonalHeterogeneous extends RegulationEnum { override def toString = "seasonalHeterogeneous" }
case object PermittedOnlyAtParticularTimes extends RegulationEnum { override def toString = "permittedOnlyAtParticularTimes" }
case object PermittedOnlyOnParticularAreas extends RegulationEnum { override def toString = "permittedOnlyOnParticularAreas" }
case object ProhibitedAtParticularTimes extends RegulationEnum { override def toString = "prohibitedAtParticularTimes" }
case object ProhibitedOnParticularAreas extends RegulationEnum { override def toString = "prohibitedOnParticularAreas" }
case object OnlyOnRequest extends RegulationEnum { override def toString = "onlyOnRequest" }
case object Heterogeneous extends RegulationEnum { override def toString = "heterogeneous" }
case object OnlyOutsideBuildings extends RegulationEnum { override def toString = "onlyOutsideBuildings" }
case object OnlyInsideBuildings extends RegulationEnum { override def toString = "onlyInsideBuildings" }
case object Unspecified extends RegulationEnum { override def toString = "unspecified" }
case object UnknownValue7 extends RegulationEnum { override def toString = "unknown" }
case object OtherValue14 extends RegulationEnum { override def toString = "other" }

sealed trait RelativeTrafficFlowEnum

object RelativeTrafficFlowEnum {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[nu.ndw.RelativeTrafficFlowEnum]): RelativeTrafficFlowEnum = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: RelativeTrafficFlowEnum) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
}

case object TrafficVeryMuchHeavierThanNormal extends RelativeTrafficFlowEnum { override def toString = "trafficVeryMuchHeavierThanNormal" }
case object TrafficHeavierThanNormal extends RelativeTrafficFlowEnum { override def toString = "trafficHeavierThanNormal" }
case object TrafficFlowNormal extends RelativeTrafficFlowEnum { override def toString = "trafficFlowNormal" }
case object TrafficLighterThanNormal extends RelativeTrafficFlowEnum { override def toString = "trafficLighterThanNormal" }
case object TrafficVeryMuchLighterThanNormal extends RelativeTrafficFlowEnum { override def toString = "trafficVeryMuchLighterThanNormal" }

sealed trait RequestTypeEnum

object RequestTypeEnum {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[nu.ndw.RequestTypeEnum]): RequestTypeEnum = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: RequestTypeEnum) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
}

case object Catalogue extends RequestTypeEnum { override def toString = "catalogue" }
case object Filter extends RequestTypeEnum { override def toString = "filter" }
case object RequestData extends RequestTypeEnum { override def toString = "requestData" }
case object RequestHistoricalData extends RequestTypeEnum { override def toString = "requestHistoricalData" }
case object SubscriptionValue extends RequestTypeEnum { override def toString = "subscription" }



case class ReroutingManagement(situationRecordCreationReference: Option[String] = None,
  situationRecordCreationTime: javax.xml.datatype.XMLGregorianCalendar,
  situationRecordObservationTime: Option[javax.xml.datatype.XMLGregorianCalendar] = None,
  situationRecordVersionTime: javax.xml.datatype.XMLGregorianCalendar,
  situationRecordFirstSupplierVersionTime: Option[javax.xml.datatype.XMLGregorianCalendar] = None,
  confidentialityOverride: Option[nu.ndw.ConfidentialityValueEnum] = None,
  probabilityOfOccurrence: nu.ndw.ProbabilityOfOccurrenceEnum,
  severity: Option[nu.ndw.SeverityEnum] = None,
  source: Option[nu.ndw.Source] = None,
  validity: nu.ndw.Validity,
  impact: Option[nu.ndw.Impact] = None,
  cause: Option[nu.ndw.Cause] = None,
  generalPublicComment: Seq[nu.ndw.Comment] = Nil,
  nonGeneralPublicComment: Seq[nu.ndw.Comment] = Nil,
  urlLink: Seq[nu.ndw.UrlLink] = Nil,
  groupOfLocations: nu.ndw.GroupOfLocations,
  management: Option[nu.ndw.Management] = None,
  situationRecordExtension: Option[nu.ndw._SituationRecordExtensionType] = None,
  actionOrigin: Option[nu.ndw.OperatorActionOriginEnum] = None,
  actionPlanIdentifier: Option[String] = None,
  operatorActionStatus: Option[nu.ndw.OperatorActionStatusEnum] = None,
  operatorActionExtension: Option[nu.ndw._ExtensionType] = None,
  complianceOption: nu.ndw.ComplianceOptionEnum,
  applicableForTrafficDirection: Seq[nu.ndw.DirectionEnum] = Nil,
  applicableForTrafficType: Seq[nu.ndw.TrafficTypeEnum] = Nil,
  placesAtWhichApplicable: Seq[nu.ndw.PlacesEnum] = Nil,
  automaticallyInitiated: Option[Boolean] = None,
  forVehiclesWithCharacteristicsOf: Seq[nu.ndw.VehicleCharacteristics] = Nil,
  networkManagementExtension: Option[nu.ndw._ExtensionType] = None,
  reroutingManagementType: Seq[nu.ndw.ReroutingManagementTypeEnum] = Nil,
  reroutingItineraryDescription: Option[nu.ndw.MultilingualString] = None,
  signedRerouting: Option[Boolean] = None,
  entry: Option[String] = None,
  exit: Option[String] = None,
  roadOrJunctionNumber: Option[String] = None,
  alternativeRoute: Seq[nu.ndw.Itinerary] = Nil,
  reroutingManagementExtension: Option[nu.ndw._ExtensionType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) extends NetworkManagement {
  @JsonIgnore lazy val id = attributes("@id").as[String]
  @JsonIgnore lazy val version = attributes("@version").as[String]
}

      

sealed trait ReroutingManagementTypeEnum

object ReroutingManagementTypeEnum {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[nu.ndw.ReroutingManagementTypeEnum]): ReroutingManagementTypeEnum = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: ReroutingManagementTypeEnum) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
}

case object DoNotFollowDiversionSigns extends ReroutingManagementTypeEnum { override def toString = "doNotFollowDiversionSigns" }
case object DoNotUseEntry extends ReroutingManagementTypeEnum { override def toString = "doNotUseEntry" }
case object DoNotUseExit extends ReroutingManagementTypeEnum { override def toString = "doNotUseExit" }
case object DoNotUseIntersectionOrJunction extends ReroutingManagementTypeEnum { override def toString = "doNotUseIntersectionOrJunction" }
case object FollowDiversionSigns extends ReroutingManagementTypeEnum { override def toString = "followDiversionSigns" }
case object FollowLocalDiversion extends ReroutingManagementTypeEnum { override def toString = "followLocalDiversion" }
case object FollowSpecialMarkers extends ReroutingManagementTypeEnum { override def toString = "followSpecialMarkers" }
case object UseEntry extends ReroutingManagementTypeEnum { override def toString = "useEntry" }
case object UseExit extends ReroutingManagementTypeEnum { override def toString = "useExit" }
case object UseIntersectionOrJunction extends ReroutingManagementTypeEnum { override def toString = "useIntersectionOrJunction" }

sealed trait ReservationTypeEnum

object ReservationTypeEnum {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[nu.ndw.ReservationTypeEnum]): ReservationTypeEnum = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: ReservationTypeEnum) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
}

case object Optional extends ReservationTypeEnum { override def toString = "optional" }
case object MandatoryValue extends ReservationTypeEnum { override def toString = "mandatory" }
case object NotAvailableValue extends ReservationTypeEnum { override def toString = "notAvailable" }
case object Partly extends ReservationTypeEnum { override def toString = "partly" }
case object UnknownValue43 extends ReservationTypeEnum { override def toString = "unknown" }
case object UnspecifiedValue4 extends ReservationTypeEnum { override def toString = "unspecified" }

sealed trait ResponseEnum

object ResponseEnum {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[nu.ndw.ResponseEnum]): ResponseEnum = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: ResponseEnum) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
}

case object Acknowledge extends ResponseEnum { override def toString = "acknowledge" }
case object CatalogueRequestDenied extends ResponseEnum { override def toString = "catalogueRequestDenied" }
case object FilterRequestDenied extends ResponseEnum { override def toString = "filterRequestDenied" }
case object RequestDenied extends ResponseEnum { override def toString = "requestDenied" }
case object SubscriptionRequestDenied extends ResponseEnum { override def toString = "subscriptionRequestDenied" }

sealed trait RestAreaActivityEnum

object RestAreaActivityEnum {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[nu.ndw.RestAreaActivityEnum]): RestAreaActivityEnum = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: RestAreaActivityEnum) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
}

case object OpenFire extends RestAreaActivityEnum { override def toString = "openFire" }
case object OvernightParkingValue extends RestAreaActivityEnum { override def toString = "overnightParking" }
case object Picnic extends RestAreaActivityEnum { override def toString = "picnic" }
case object Smoking extends RestAreaActivityEnum { override def toString = "smoking" }
case object Camping extends RestAreaActivityEnum { override def toString = "camping" }
case object HandlingHazardousMaterial extends RestAreaActivityEnum { override def toString = "handlingHazardousMaterial" }
case object Barbecue extends RestAreaActivityEnum { override def toString = "barbecue" }
case object OtherValue76 extends RestAreaActivityEnum { override def toString = "other" }



case class RGBColour(rgbRedValue: Int,
  rgbGreenValue: Int,
  rgbBlueValue: Int,
  colourName: Option[nu.ndw.MultilingualString] = None,
  rgbColourExtension: Option[nu.ndw._ExtensionType] = None)
      


sealed trait Roadable {
  def nameOfRoad: Option[nu.ndw.MultilingualString]
  def roadIdentifier: Option[nu.ndw.MultilingualString]
  def typeOfRoad: Option[nu.ndw.RoadTypeEnum]
  def roadDestination: Seq[nu.ndw.MultilingualString]
  def roadOrigination: Seq[nu.ndw.MultilingualString]
  def distanceToThisRoad: Option[Int]
  def roadExtension: Option[nu.ndw._ExtensionType]
}



case class RoadType(nameOfRoad: Option[nu.ndw.MultilingualString] = None,
  roadIdentifier: Option[nu.ndw.MultilingualString] = None,
  typeOfRoad: Option[nu.ndw.RoadTypeEnum] = None,
  roadDestination: Seq[nu.ndw.MultilingualString] = Nil,
  roadOrigination: Seq[nu.ndw.MultilingualString] = Nil,
  distanceToThisRoad: Option[Int] = None,
  roadExtension: Option[nu.ndw._ExtensionType] = None) extends Roadable
      


sealed trait RoadConditions extends Conditionsable {
  def situationRecordCreationReference: Option[String]
  def situationRecordCreationTime: javax.xml.datatype.XMLGregorianCalendar
  def situationRecordObservationTime: Option[javax.xml.datatype.XMLGregorianCalendar]
  def situationRecordVersionTime: javax.xml.datatype.XMLGregorianCalendar
  def situationRecordFirstSupplierVersionTime: Option[javax.xml.datatype.XMLGregorianCalendar]
  def confidentialityOverride: Option[nu.ndw.ConfidentialityValueEnum]
  def probabilityOfOccurrence: nu.ndw.ProbabilityOfOccurrenceEnum
  def severity: Option[nu.ndw.SeverityEnum]
  def source: Option[nu.ndw.Source]
  def validity: nu.ndw.Validity
  def impact: Option[nu.ndw.Impact]
  def cause: Option[nu.ndw.Cause]
  def generalPublicComment: Seq[nu.ndw.Comment]
  def nonGeneralPublicComment: Seq[nu.ndw.Comment]
  def urlLink: Seq[nu.ndw.UrlLink]
  def groupOfLocations: nu.ndw.GroupOfLocations
  def management: Option[nu.ndw.Management]
  def situationRecordExtension: Option[nu.ndw._SituationRecordExtensionType]
  def trafficElementExtension: Option[nu.ndw._ExtensionType]
  def drivingConditionType: Option[nu.ndw.DrivingConditionTypeEnum]
  def conditionsExtension: Option[nu.ndw._ExtensionType]
  def roadConditionsExtension: Option[nu.ndw._ExtensionType]
  def id: String
  def version: String
}

sealed trait RoadMaintenanceTypeEnum

object RoadMaintenanceTypeEnum {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[nu.ndw.RoadMaintenanceTypeEnum]): RoadMaintenanceTypeEnum = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: RoadMaintenanceTypeEnum) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
}

case object ClearanceWorkValue extends RoadMaintenanceTypeEnum { override def toString = "clearanceWork" }
case object ControlledAvalanche extends RoadMaintenanceTypeEnum { override def toString = "controlledAvalanche" }
case object InstallationWork extends RoadMaintenanceTypeEnum { override def toString = "installationWork" }
case object GrassCuttingWork extends RoadMaintenanceTypeEnum { override def toString = "grassCuttingWork" }
case object LitterClearance extends RoadMaintenanceTypeEnum { override def toString = "litterClearance" }
case object MaintenanceWork extends RoadMaintenanceTypeEnum { override def toString = "maintenanceWork" }
case object OverheadWorks extends RoadMaintenanceTypeEnum { override def toString = "overheadWorks" }
case object RepairWork extends RoadMaintenanceTypeEnum { override def toString = "repairWork" }
case object ResurfacingWork extends RoadMaintenanceTypeEnum { override def toString = "resurfacingWork" }
case object RoadMarkingWork extends RoadMaintenanceTypeEnum { override def toString = "roadMarkingWork" }
case object RoadsideWork extends RoadMaintenanceTypeEnum { override def toString = "roadsideWork" }
case object RoadworksClearance extends RoadMaintenanceTypeEnum { override def toString = "roadworksClearance" }
case object RoadworksValue extends RoadMaintenanceTypeEnum { override def toString = "roadworks" }
case object RockFallPreventativeMaintenance extends RoadMaintenanceTypeEnum { override def toString = "rockFallPreventativeMaintenance" }
case object SaltingInProgress extends RoadMaintenanceTypeEnum { override def toString = "saltingInProgress" }
case object SnowploughsInUse extends RoadMaintenanceTypeEnum { override def toString = "snowploughsInUse" }
case object SweepingOfRoad extends RoadMaintenanceTypeEnum { override def toString = "sweepingOfRoad" }
case object TreeAndVegetationCuttingWork extends RoadMaintenanceTypeEnum { override def toString = "treeAndVegetationCuttingWork" }
case object OtherValue77 extends RoadMaintenanceTypeEnum { override def toString = "other" }



case class RoadNode(nameOfRoad: Option[nu.ndw.MultilingualString] = None,
  roadIdentifier: Option[nu.ndw.MultilingualString] = None,
  typeOfRoad: Option[nu.ndw.RoadTypeEnum] = None,
  roadDestination: Seq[nu.ndw.MultilingualString] = Nil,
  roadOrigination: Seq[nu.ndw.MultilingualString] = Nil,
  distanceToThisRoad: Option[Int] = None,
  roadExtension: Option[nu.ndw._ExtensionType] = None,
  junctionName: nu.ndw.MultilingualString,
  roadNodeExtension: Option[nu.ndw._ExtensionType] = None) extends Roadable
      



case class RoadOperatorServiceDisruption(situationRecordCreationReference: Option[String] = None,
  situationRecordCreationTime: javax.xml.datatype.XMLGregorianCalendar,
  situationRecordObservationTime: Option[javax.xml.datatype.XMLGregorianCalendar] = None,
  situationRecordVersionTime: javax.xml.datatype.XMLGregorianCalendar,
  situationRecordFirstSupplierVersionTime: Option[javax.xml.datatype.XMLGregorianCalendar] = None,
  confidentialityOverride: Option[nu.ndw.ConfidentialityValueEnum] = None,
  probabilityOfOccurrence: nu.ndw.ProbabilityOfOccurrenceEnum,
  severity: Option[nu.ndw.SeverityEnum] = None,
  source: Option[nu.ndw.Source] = None,
  validity: nu.ndw.Validity,
  impact: Option[nu.ndw.Impact] = None,
  cause: Option[nu.ndw.Cause] = None,
  generalPublicComment: Seq[nu.ndw.Comment] = Nil,
  nonGeneralPublicComment: Seq[nu.ndw.Comment] = Nil,
  urlLink: Seq[nu.ndw.UrlLink] = Nil,
  groupOfLocations: nu.ndw.GroupOfLocations,
  management: Option[nu.ndw.Management] = None,
  situationRecordExtension: Option[nu.ndw._SituationRecordExtensionType] = None,
  nonRoadEventInformationExtension: Option[nu.ndw._ExtensionType] = None,
  roadOperatorServiceDisruptionType: Seq[nu.ndw.RoadOperatorServiceDisruptionTypeEnum] = Nil,
  roadOperatorServiceDisruptionExtension: Option[nu.ndw._ExtensionType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) extends NonRoadEventInformation {
  @JsonIgnore lazy val id = attributes("@id").as[String]
  @JsonIgnore lazy val version = attributes("@version").as[String]
}

      

sealed trait RoadOperatorServiceDisruptionTypeEnum

object RoadOperatorServiceDisruptionTypeEnum {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[nu.ndw.RoadOperatorServiceDisruptionTypeEnum]): RoadOperatorServiceDisruptionTypeEnum = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: RoadOperatorServiceDisruptionTypeEnum) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
}

case object EmergencyTelephoneNumberOutOfService extends RoadOperatorServiceDisruptionTypeEnum { override def toString = "emergencyTelephoneNumberOutOfService" }
case object InformationServiceTelephoneNumberOutOfService extends RoadOperatorServiceDisruptionTypeEnum { override def toString = "informationServiceTelephoneNumberOutOfService" }
case object NoTrafficOfficerPatrolService extends RoadOperatorServiceDisruptionTypeEnum { override def toString = "noTrafficOfficerPatrolService" }



case class RoadOrCarriagewayOrLaneManagement(situationRecordCreationReference: Option[String] = None,
  situationRecordCreationTime: javax.xml.datatype.XMLGregorianCalendar,
  situationRecordObservationTime: Option[javax.xml.datatype.XMLGregorianCalendar] = None,
  situationRecordVersionTime: javax.xml.datatype.XMLGregorianCalendar,
  situationRecordFirstSupplierVersionTime: Option[javax.xml.datatype.XMLGregorianCalendar] = None,
  confidentialityOverride: Option[nu.ndw.ConfidentialityValueEnum] = None,
  probabilityOfOccurrence: nu.ndw.ProbabilityOfOccurrenceEnum,
  severity: Option[nu.ndw.SeverityEnum] = None,
  source: Option[nu.ndw.Source] = None,
  validity: nu.ndw.Validity,
  impact: Option[nu.ndw.Impact] = None,
  cause: Option[nu.ndw.Cause] = None,
  generalPublicComment: Seq[nu.ndw.Comment] = Nil,
  nonGeneralPublicComment: Seq[nu.ndw.Comment] = Nil,
  urlLink: Seq[nu.ndw.UrlLink] = Nil,
  groupOfLocations: nu.ndw.GroupOfLocations,
  management: Option[nu.ndw.Management] = None,
  situationRecordExtension: Option[nu.ndw._SituationRecordExtensionType] = None,
  actionOrigin: Option[nu.ndw.OperatorActionOriginEnum] = None,
  actionPlanIdentifier: Option[String] = None,
  operatorActionStatus: Option[nu.ndw.OperatorActionStatusEnum] = None,
  operatorActionExtension: Option[nu.ndw._ExtensionType] = None,
  complianceOption: nu.ndw.ComplianceOptionEnum,
  applicableForTrafficDirection: Seq[nu.ndw.DirectionEnum] = Nil,
  applicableForTrafficType: Seq[nu.ndw.TrafficTypeEnum] = Nil,
  placesAtWhichApplicable: Seq[nu.ndw.PlacesEnum] = Nil,
  automaticallyInitiated: Option[Boolean] = None,
  forVehiclesWithCharacteristicsOf: Seq[nu.ndw.VehicleCharacteristics] = Nil,
  networkManagementExtension: Option[nu.ndw._ExtensionType] = None,
  roadOrCarriagewayOrLaneManagementType: nu.ndw.RoadOrCarriagewayOrLaneManagementTypeEnum,
  minimumCarOccupancy: Option[Int] = None,
  roadOrCarriagewayOrLaneManagementExtension: Option[nu.ndw._ExtensionType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) extends NetworkManagement {
  @JsonIgnore lazy val id = attributes("@id").as[String]
  @JsonIgnore lazy val version = attributes("@version").as[String]
}

      

sealed trait RoadOrCarriagewayOrLaneManagementTypeEnum

object RoadOrCarriagewayOrLaneManagementTypeEnum {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[nu.ndw.RoadOrCarriagewayOrLaneManagementTypeEnum]): RoadOrCarriagewayOrLaneManagementTypeEnum = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: RoadOrCarriagewayOrLaneManagementTypeEnum) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
}

case object CarPoolLaneInOperation extends RoadOrCarriagewayOrLaneManagementTypeEnum { override def toString = "carPoolLaneInOperation" }
case object CarriagewayClosures extends RoadOrCarriagewayOrLaneManagementTypeEnum { override def toString = "carriagewayClosures" }
case object ClearALaneForEmergencyVehicles extends RoadOrCarriagewayOrLaneManagementTypeEnum { override def toString = "clearALaneForEmergencyVehicles" }
case object ClearALaneForSnowploughsAndGrittingVehicles extends RoadOrCarriagewayOrLaneManagementTypeEnum { override def toString = "clearALaneForSnowploughsAndGrittingVehicles" }
case object ClosedPermanentlyForTheWinter extends RoadOrCarriagewayOrLaneManagementTypeEnum { override def toString = "closedPermanentlyForTheWinter" }
case object Contraflow extends RoadOrCarriagewayOrLaneManagementTypeEnum { override def toString = "contraflow" }
case object DoNotUseSpecifiedLanesOrCarriageways extends RoadOrCarriagewayOrLaneManagementTypeEnum { override def toString = "doNotUseSpecifiedLanesOrCarriageways" }
case object HardShoulderRunningInOperation extends RoadOrCarriagewayOrLaneManagementTypeEnum { override def toString = "hardShoulderRunningInOperation" }
case object HeightRestrictionInOperation extends RoadOrCarriagewayOrLaneManagementTypeEnum { override def toString = "heightRestrictionInOperation" }
case object IntermittentShortTermClosures extends RoadOrCarriagewayOrLaneManagementTypeEnum { override def toString = "intermittentShortTermClosures" }
case object KeepToTheLeft extends RoadOrCarriagewayOrLaneManagementTypeEnum { override def toString = "keepToTheLeft" }
case object KeepToTheRight extends RoadOrCarriagewayOrLaneManagementTypeEnum { override def toString = "keepToTheRight" }
case object LaneClosures extends RoadOrCarriagewayOrLaneManagementTypeEnum { override def toString = "laneClosures" }
case object LanesDeviated extends RoadOrCarriagewayOrLaneManagementTypeEnum { override def toString = "lanesDeviated" }
case object NarrowLanes extends RoadOrCarriagewayOrLaneManagementTypeEnum { override def toString = "narrowLanes" }
case object NewRoadworksLayout extends RoadOrCarriagewayOrLaneManagementTypeEnum { override def toString = "newRoadworksLayout" }
case object OvernightClosures extends RoadOrCarriagewayOrLaneManagementTypeEnum { override def toString = "overnightClosures" }
case object RoadCleared extends RoadOrCarriagewayOrLaneManagementTypeEnum { override def toString = "roadCleared" }
case object RoadClosed extends RoadOrCarriagewayOrLaneManagementTypeEnum { override def toString = "roadClosed" }
case object RollingRoadBlock extends RoadOrCarriagewayOrLaneManagementTypeEnum { override def toString = "rollingRoadBlock" }
case object RushHourLaneInOperation extends RoadOrCarriagewayOrLaneManagementTypeEnum { override def toString = "rushHourLaneInOperation" }
case object SingleAlternateLineTraffic extends RoadOrCarriagewayOrLaneManagementTypeEnum { override def toString = "singleAlternateLineTraffic" }
case object TidalFlowLaneInOperation extends RoadOrCarriagewayOrLaneManagementTypeEnum { override def toString = "tidalFlowLaneInOperation" }
case object TurnAroundInOperation extends RoadOrCarriagewayOrLaneManagementTypeEnum { override def toString = "turnAroundInOperation" }
case object UseOfSpecifiedLanesOrCarriagewaysAllowed extends RoadOrCarriagewayOrLaneManagementTypeEnum { override def toString = "useOfSpecifiedLanesOrCarriagewaysAllowed" }
case object UseSpecifiedLanesOrCarriageways extends RoadOrCarriagewayOrLaneManagementTypeEnum { override def toString = "useSpecifiedLanesOrCarriageways" }
case object VehicleStorageInOperation extends RoadOrCarriagewayOrLaneManagementTypeEnum { override def toString = "vehicleStorageInOperation" }
case object WeightRestrictionInOperation extends RoadOrCarriagewayOrLaneManagementTypeEnum { override def toString = "weightRestrictionInOperation" }
case object OtherValue13 extends RoadOrCarriagewayOrLaneManagementTypeEnum { override def toString = "other" }



case class RoadsideAssistance(situationRecordCreationReference: Option[String] = None,
  situationRecordCreationTime: javax.xml.datatype.XMLGregorianCalendar,
  situationRecordObservationTime: Option[javax.xml.datatype.XMLGregorianCalendar] = None,
  situationRecordVersionTime: javax.xml.datatype.XMLGregorianCalendar,
  situationRecordFirstSupplierVersionTime: Option[javax.xml.datatype.XMLGregorianCalendar] = None,
  confidentialityOverride: Option[nu.ndw.ConfidentialityValueEnum] = None,
  probabilityOfOccurrence: nu.ndw.ProbabilityOfOccurrenceEnum,
  severity: Option[nu.ndw.SeverityEnum] = None,
  source: Option[nu.ndw.Source] = None,
  validity: nu.ndw.Validity,
  impact: Option[nu.ndw.Impact] = None,
  cause: Option[nu.ndw.Cause] = None,
  generalPublicComment: Seq[nu.ndw.Comment] = Nil,
  nonGeneralPublicComment: Seq[nu.ndw.Comment] = Nil,
  urlLink: Seq[nu.ndw.UrlLink] = Nil,
  groupOfLocations: nu.ndw.GroupOfLocations,
  management: Option[nu.ndw.Management] = None,
  situationRecordExtension: Option[nu.ndw._SituationRecordExtensionType] = None,
  actionOrigin: Option[nu.ndw.OperatorActionOriginEnum] = None,
  actionPlanIdentifier: Option[String] = None,
  operatorActionStatus: Option[nu.ndw.OperatorActionStatusEnum] = None,
  operatorActionExtension: Option[nu.ndw._ExtensionType] = None,
  roadsideAssistanceType: nu.ndw.RoadsideAssistanceTypeEnum,
  roadsideAssistanceExtension: Option[nu.ndw._ExtensionType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) extends OperatorActionable {
  @JsonIgnore lazy val id = attributes("@id").as[String]
  @JsonIgnore lazy val version = attributes("@version").as[String]
}

      

sealed trait RoadsideAssistanceTypeEnum

object RoadsideAssistanceTypeEnum {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[nu.ndw.RoadsideAssistanceTypeEnum]): RoadsideAssistanceTypeEnum = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: RoadsideAssistanceTypeEnum) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
}

case object AirAmbulance extends RoadsideAssistanceTypeEnum { override def toString = "airAmbulance" }
case object BusPassengerAssistance extends RoadsideAssistanceTypeEnum { override def toString = "busPassengerAssistance" }
case object EmergencyServices extends RoadsideAssistanceTypeEnum { override def toString = "emergencyServices" }
case object FirstAid extends RoadsideAssistanceTypeEnum { override def toString = "firstAid" }
case object FoodDelivery extends RoadsideAssistanceTypeEnum { override def toString = "foodDelivery" }
case object HelicopterRescue extends RoadsideAssistanceTypeEnum { override def toString = "helicopterRescue" }
case object VehicleRepair extends RoadsideAssistanceTypeEnum { override def toString = "vehicleRepair" }
case object VehicleRecovery extends RoadsideAssistanceTypeEnum { override def toString = "vehicleRecovery" }
case object OtherValue12 extends RoadsideAssistanceTypeEnum { override def toString = "other" }



case class RoadsideServiceDisruption(situationRecordCreationReference: Option[String] = None,
  situationRecordCreationTime: javax.xml.datatype.XMLGregorianCalendar,
  situationRecordObservationTime: Option[javax.xml.datatype.XMLGregorianCalendar] = None,
  situationRecordVersionTime: javax.xml.datatype.XMLGregorianCalendar,
  situationRecordFirstSupplierVersionTime: Option[javax.xml.datatype.XMLGregorianCalendar] = None,
  confidentialityOverride: Option[nu.ndw.ConfidentialityValueEnum] = None,
  probabilityOfOccurrence: nu.ndw.ProbabilityOfOccurrenceEnum,
  severity: Option[nu.ndw.SeverityEnum] = None,
  source: Option[nu.ndw.Source] = None,
  validity: nu.ndw.Validity,
  impact: Option[nu.ndw.Impact] = None,
  cause: Option[nu.ndw.Cause] = None,
  generalPublicComment: Seq[nu.ndw.Comment] = Nil,
  nonGeneralPublicComment: Seq[nu.ndw.Comment] = Nil,
  urlLink: Seq[nu.ndw.UrlLink] = Nil,
  groupOfLocations: nu.ndw.GroupOfLocations,
  management: Option[nu.ndw.Management] = None,
  situationRecordExtension: Option[nu.ndw._SituationRecordExtensionType] = None,
  nonRoadEventInformationExtension: Option[nu.ndw._ExtensionType] = None,
  roadsideServiceDisruptionType: Seq[nu.ndw.RoadsideServiceDisruptionTypeEnum] = Nil,
  roadsideServiceDisruptionExtension: Option[nu.ndw._ExtensionType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) extends NonRoadEventInformation {
  @JsonIgnore lazy val id = attributes("@id").as[String]
  @JsonIgnore lazy val version = attributes("@version").as[String]
}

      

sealed trait RoadsideServiceDisruptionTypeEnum

object RoadsideServiceDisruptionTypeEnum {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[nu.ndw.RoadsideServiceDisruptionTypeEnum]): RoadsideServiceDisruptionTypeEnum = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: RoadsideServiceDisruptionTypeEnum) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
}

case object BarClosed extends RoadsideServiceDisruptionTypeEnum { override def toString = "barClosed" }
case object DieselShortage extends RoadsideServiceDisruptionTypeEnum { override def toString = "dieselShortage" }
case object FuelShortage extends RoadsideServiceDisruptionTypeEnum { override def toString = "fuelShortage" }
case object LpgShortage extends RoadsideServiceDisruptionTypeEnum { override def toString = "lpgShortage" }
case object MethaneShortage extends RoadsideServiceDisruptionTypeEnum { override def toString = "methaneShortage" }
case object NoDieselForHeavyVehicles extends RoadsideServiceDisruptionTypeEnum { override def toString = "noDieselForHeavyVehicles" }
case object NoDieselForLightVehicles extends RoadsideServiceDisruptionTypeEnum { override def toString = "noDieselForLightVehicles" }
case object NoPublicTelephones extends RoadsideServiceDisruptionTypeEnum { override def toString = "noPublicTelephones" }
case object NoToiletFacilities extends RoadsideServiceDisruptionTypeEnum { override def toString = "noToiletFacilities" }
case object NoVehicleRepairFacilities extends RoadsideServiceDisruptionTypeEnum { override def toString = "noVehicleRepairFacilities" }
case object PetrolShortage extends RoadsideServiceDisruptionTypeEnum { override def toString = "petrolShortage" }
case object RestAreaBusy extends RoadsideServiceDisruptionTypeEnum { override def toString = "restAreaBusy" }
case object RestAreaClosed extends RoadsideServiceDisruptionTypeEnum { override def toString = "restAreaClosed" }
case object RestAreaOvercrowdedDriveToAnotherRestArea extends RoadsideServiceDisruptionTypeEnum { override def toString = "restAreaOvercrowdedDriveToAnotherRestArea" }
case object ServiceAreaBusy extends RoadsideServiceDisruptionTypeEnum { override def toString = "serviceAreaBusy" }
case object ServiceAreaClosed extends RoadsideServiceDisruptionTypeEnum { override def toString = "serviceAreaClosed" }
case object ServiceAreaFuelStationClosed extends RoadsideServiceDisruptionTypeEnum { override def toString = "serviceAreaFuelStationClosed" }
case object ServiceAreaOvercrowdedDriveToAnotherServiceArea extends RoadsideServiceDisruptionTypeEnum { override def toString = "serviceAreaOvercrowdedDriveToAnotherServiceArea" }
case object ServiceAreaRestaurantClosed extends RoadsideServiceDisruptionTypeEnum { override def toString = "serviceAreaRestaurantClosed" }
case object SomeCommercialServicesClosed extends RoadsideServiceDisruptionTypeEnum { override def toString = "someCommercialServicesClosed" }
case object WaterShortage extends RoadsideServiceDisruptionTypeEnum { override def toString = "waterShortage" }



case class RoadSurfaceConditionInformationType(measurementOrCalculationPeriod: Option[Float] = None,
  measurementOrCalculationTime: Option[javax.xml.datatype.XMLGregorianCalendar] = None,
  pertinentLocation: Option[nu.ndw.GroupOfLocations] = None,
  basicDataExtension: Option[nu.ndw._ExtensionType] = None,
  weatherDataExtension: Option[nu.ndw._ExtensionType] = None,
  weatherRelatedRoadConditionType: Seq[nu.ndw.WeatherRelatedRoadConditionTypeEnum] = Nil,
  roadSurfaceConditionMeasurements: nu.ndw.RoadSurfaceConditionMeasurements,
  roadSurfaceConditionInformationExtension: Option[nu.ndw._ExtensionType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) extends WeatherData {
  @JsonIgnore lazy val measurementOrCalculatedTimePrecision = attributes.get("@measurementOrCalculatedTimePrecision") map { _.as[TimePrecisionEnum]}
}

      



case class RoadSurfaceConditionMeasurements(roadSurfaceTemperature: Option[nu.ndw.TemperatureValue] = None,
  protectionTemperature: Option[nu.ndw.TemperatureValue] = None,
  deIcingApplicationRate: Option[nu.ndw.ApplicationRateValue] = None,
  deIcingConcentration: Option[nu.ndw.KilogramsConcentrationValue] = None,
  depthOfSnow: Option[nu.ndw.FloatingPointMetreDistanceValue] = None,
  waterFilmThickness: Option[nu.ndw.FloatingPointMetreDistanceValue] = None,
  roadSurfaceConditionMeasurementsExtension: Option[nu.ndw._ExtensionType] = None)
      

sealed trait RoadTypeEnum

object RoadTypeEnum {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[nu.ndw.RoadTypeEnum]): RoadTypeEnum = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: RoadTypeEnum) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
}

case object MotorwayValue2 extends RoadTypeEnum { override def toString = "motorway" }
case object TrunkRoad extends RoadTypeEnum { override def toString = "trunkRoad" }
case object MainRoad extends RoadTypeEnum { override def toString = "mainRoad" }
case object OtherValue78 extends RoadTypeEnum { override def toString = "other" }


sealed trait RoadworksType extends OperatorActionable {
  def situationRecordCreationReference: Option[String]
  def situationRecordCreationTime: javax.xml.datatype.XMLGregorianCalendar
  def situationRecordObservationTime: Option[javax.xml.datatype.XMLGregorianCalendar]
  def situationRecordVersionTime: javax.xml.datatype.XMLGregorianCalendar
  def situationRecordFirstSupplierVersionTime: Option[javax.xml.datatype.XMLGregorianCalendar]
  def confidentialityOverride: Option[nu.ndw.ConfidentialityValueEnum]
  def probabilityOfOccurrence: nu.ndw.ProbabilityOfOccurrenceEnum
  def severity: Option[nu.ndw.SeverityEnum]
  def source: Option[nu.ndw.Source]
  def validity: nu.ndw.Validity
  def impact: Option[nu.ndw.Impact]
  def cause: Option[nu.ndw.Cause]
  def generalPublicComment: Seq[nu.ndw.Comment]
  def nonGeneralPublicComment: Seq[nu.ndw.Comment]
  def urlLink: Seq[nu.ndw.UrlLink]
  def groupOfLocations: nu.ndw.GroupOfLocations
  def management: Option[nu.ndw.Management]
  def situationRecordExtension: Option[nu.ndw._SituationRecordExtensionType]
  def actionOrigin: Option[nu.ndw.OperatorActionOriginEnum]
  def actionPlanIdentifier: Option[String]
  def operatorActionStatus: Option[nu.ndw.OperatorActionStatusEnum]
  def operatorActionExtension: Option[nu.ndw._ExtensionType]
  def roadworksDuration: Option[nu.ndw.RoadworksDurationEnum]
  def roadworksScale: Option[nu.ndw.RoadworksScaleEnum]
  def underTraffic: Option[Boolean]
  def urgentRoadworks: Option[Boolean]
  def mobility: Option[nu.ndw.Mobility]
  def subjects: Option[nu.ndw.Subjects]
  def maintenanceVehicles: Option[nu.ndw.MaintenanceVehicles]
  def roadworksExtension: Option[nu.ndw._ExtensionType]
  def id: String
  def version: String
}

sealed trait RoadworksDurationEnum

object RoadworksDurationEnum {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[nu.ndw.RoadworksDurationEnum]): RoadworksDurationEnum = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: RoadworksDurationEnum) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
}

case object LongTermValue extends RoadworksDurationEnum { override def toString = "longTerm" }
case object MediumTerm extends RoadworksDurationEnum { override def toString = "mediumTerm" }
case object ShortTermValue extends RoadworksDurationEnum { override def toString = "shortTerm" }

sealed trait RoadworksScaleEnum

object RoadworksScaleEnum {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[nu.ndw.RoadworksScaleEnum]): RoadworksScaleEnum = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: RoadworksScaleEnum) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
}

case object Major extends RoadworksScaleEnum { override def toString = "major" }
case object MediumValue extends RoadworksScaleEnum { override def toString = "medium" }
case object Minor extends RoadworksScaleEnum { override def toString = "minor" }



case class ServiceFacility(equipmentOrServiceFacilityIdentifier: Seq[String] = Nil,
  availability: Option[nu.ndw.AvailabilityEnum] = None,
  numberOfEquipmentOrServiceFacility: Option[Int] = None,
  additionalDescription: Option[nu.ndw.MultilingualString] = None,
  otherEquipmentOrServiceFacility: Option[nu.ndw.MultilingualString] = None,
  accessibility: Seq[nu.ndw.AccessibilityEnum] = Nil,
  nameOrBrand: Option[nu.ndw.MultilingualString] = None,
  comment: Option[nu.ndw.MultilingualString] = None,
  photoUrl: Option[java.net.URI] = None,
  applicableForUser: Seq[nu.ndw.UserTypeEnum] = Nil,
  availabilityAndOpeningTimes: Option[nu.ndw.OpeningTimes] = None,
  tariffsAndPayment: Option[nu.ndw.TariffsAndPayment] = None,
  groupOfLocations: Option[nu.ndw.GroupOfLocations] = None,
  applicableForVehicles: Seq[nu.ndw.VehicleCharacteristics] = Nil,
  parkingEquipmentOrServiceFacilityExtension: Option[nu.ndw._ExtensionType] = None,
  serviceFacilityType: nu.ndw.ServiceFacilityTypeEnum,
  numberOfSubitems: Option[Int] = None,
  distanceFromParkingSite: Option[Int] = None,
  serviceFacilityExtension: Option[nu.ndw._ExtensionType] = None) extends ParkingEquipmentOrServiceFacility
      

sealed trait ServiceFacilityTypeEnum

object ServiceFacilityTypeEnum {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[nu.ndw.ServiceFacilityTypeEnum]): ServiceFacilityTypeEnum = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: ServiceFacilityTypeEnum) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
}

case object Hotel extends ServiceFacilityTypeEnum { override def toString = "hotel" }
case object Motel extends ServiceFacilityTypeEnum { override def toString = "motel" }
case object OvernightAccommodation extends ServiceFacilityTypeEnum { override def toString = "overnightAccommodation" }
case object Shop extends ServiceFacilityTypeEnum { override def toString = "shop" }
case object Kiosk extends ServiceFacilityTypeEnum { override def toString = "kiosk" }
case object FoodShopping extends ServiceFacilityTypeEnum { override def toString = "foodShopping" }
case object Cafe extends ServiceFacilityTypeEnum { override def toString = "cafe" }
case object Restaurant extends ServiceFacilityTypeEnum { override def toString = "restaurant" }
case object RestaurantSelfService extends ServiceFacilityTypeEnum { override def toString = "restaurantSelfService" }
case object MotorwayRestaurant extends ServiceFacilityTypeEnum { override def toString = "motorwayRestaurant" }
case object MotorwayRestaurantSmall extends ServiceFacilityTypeEnum { override def toString = "motorwayRestaurantSmall" }
case object SparePartsShopping extends ServiceFacilityTypeEnum { override def toString = "sparePartsShopping" }
case object PetrolStation extends ServiceFacilityTypeEnum { override def toString = "petrolStation" }
case object VehicleMaintenance extends ServiceFacilityTypeEnum { override def toString = "vehicleMaintenance" }
case object TyreRepair extends ServiceFacilityTypeEnum { override def toString = "tyreRepair" }
case object TruckRepair extends ServiceFacilityTypeEnum { override def toString = "truckRepair" }
case object TruckWash extends ServiceFacilityTypeEnum { override def toString = "truckWash" }
case object CarWash extends ServiceFacilityTypeEnum { override def toString = "carWash" }
case object Pharmacy extends ServiceFacilityTypeEnum { override def toString = "pharmacy" }
case object MedicalFacility extends ServiceFacilityTypeEnum { override def toString = "medicalFacility" }
case object Police extends ServiceFacilityTypeEnum { override def toString = "police" }
case object TouristInformation extends ServiceFacilityTypeEnum { override def toString = "touristInformation" }
case object BikeSharing extends ServiceFacilityTypeEnum { override def toString = "bikeSharing" }
case object Docstop extends ServiceFacilityTypeEnum { override def toString = "docstop" }
case object Laundry extends ServiceFacilityTypeEnum { override def toString = "laundry" }
case object LeisureActivities extends ServiceFacilityTypeEnum { override def toString = "leisureActivities" }
case object UnknownValue44 extends ServiceFacilityTypeEnum { override def toString = "unknown" }
case object OtherValue79 extends ServiceFacilityTypeEnum { override def toString = "other" }

sealed trait SeverityEnum

object SeverityEnum {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[nu.ndw.SeverityEnum]): SeverityEnum = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: SeverityEnum) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
}

case object Highest extends SeverityEnum { override def toString = "highest" }
case object High extends SeverityEnum { override def toString = "high" }
case object Medium extends SeverityEnum { override def toString = "medium" }
case object Low extends SeverityEnum { override def toString = "low" }
case object Lowest extends SeverityEnum { override def toString = "lowest" }
case object NoneType extends SeverityEnum { override def toString = "none" }
case object UnknownValue6 extends SeverityEnum { override def toString = "unknown" }



case class SignSetting(situationRecordCreationReference: Option[String] = None,
  situationRecordCreationTime: javax.xml.datatype.XMLGregorianCalendar,
  situationRecordObservationTime: Option[javax.xml.datatype.XMLGregorianCalendar] = None,
  situationRecordVersionTime: javax.xml.datatype.XMLGregorianCalendar,
  situationRecordFirstSupplierVersionTime: Option[javax.xml.datatype.XMLGregorianCalendar] = None,
  confidentialityOverride: Option[nu.ndw.ConfidentialityValueEnum] = None,
  probabilityOfOccurrence: nu.ndw.ProbabilityOfOccurrenceEnum,
  severity: Option[nu.ndw.SeverityEnum] = None,
  source: Option[nu.ndw.Source] = None,
  validity: nu.ndw.Validity,
  impact: Option[nu.ndw.Impact] = None,
  cause: Option[nu.ndw.Cause] = None,
  generalPublicComment: Seq[nu.ndw.Comment] = Nil,
  nonGeneralPublicComment: Seq[nu.ndw.Comment] = Nil,
  urlLink: Seq[nu.ndw.UrlLink] = Nil,
  groupOfLocations: nu.ndw.GroupOfLocations,
  management: Option[nu.ndw.Management] = None,
  situationRecordExtension: Option[nu.ndw._SituationRecordExtensionType] = None,
  actionOrigin: Option[nu.ndw.OperatorActionOriginEnum] = None,
  actionPlanIdentifier: Option[String] = None,
  operatorActionStatus: Option[nu.ndw.OperatorActionStatusEnum] = None,
  operatorActionExtension: Option[nu.ndw._ExtensionType] = None,
  vmsSetting: nu.ndw.VmsSetting,
  signSettingExtension: Option[nu.ndw._ExtensionType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) extends OperatorActionable {
  @JsonIgnore lazy val id = attributes("@id").as[String]
  @JsonIgnore lazy val version = attributes("@version").as[String]
}

      



case class SiteMeasurements(measurementSiteReference: nu.ndw._MeasurementSiteRecordVersionedReference,
  measurementTimeDefault: javax.xml.datatype.XMLGregorianCalendar,
  measuredValue: Seq[nu.ndw._SiteMeasurementsIndexMeasuredValue] = Nil,
  siteMeasurementsExtension: Option[nu.ndw._ExtensionType] = None)
      



case class SituationType(overallSeverity: Option[nu.ndw.SeverityEnum] = None,
  relatedSituation: Seq[nu.ndw._SituationVersionedReference] = Nil,
  situationVersionTime: Option[javax.xml.datatype.XMLGregorianCalendar] = None,
  headerInformation: nu.ndw.HeaderInformation,
  situationRecord: Seq[nu.ndw.SituationRecord] = Nil,
  situationExtension: Option[nu.ndw._ExtensionType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  @JsonIgnore lazy val id = attributes("@id").as[String]
  @JsonIgnore lazy val version = attributes("@version").as[String]
}

      



case class SituationPublication(feedDescription: Option[nu.ndw.MultilingualString] = None,
  feedType: Option[String] = None,
  publicationTime: javax.xml.datatype.XMLGregorianCalendar,
  publicationCreator: nu.ndw.InternationalIdentifier,
  payloadPublicationExtension: Option[nu.ndw._ExtensionType] = None,
  situation: Seq[nu.ndw.SituationType] = Nil,
  situationPublicationExtension: Option[nu.ndw._ExtensionType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) extends PayloadPublication {
  @JsonIgnore lazy val lang = attributes("@lang").as[String]
}

      


sealed trait SituationRecord {
  def situationRecordCreationReference: Option[String]
  def situationRecordCreationTime: javax.xml.datatype.XMLGregorianCalendar
  def situationRecordObservationTime: Option[javax.xml.datatype.XMLGregorianCalendar]
  def situationRecordVersionTime: javax.xml.datatype.XMLGregorianCalendar
  def situationRecordFirstSupplierVersionTime: Option[javax.xml.datatype.XMLGregorianCalendar]
  def confidentialityOverride: Option[nu.ndw.ConfidentialityValueEnum]
  def probabilityOfOccurrence: nu.ndw.ProbabilityOfOccurrenceEnum
  def severity: Option[nu.ndw.SeverityEnum]
  def source: Option[nu.ndw.Source]
  def validity: nu.ndw.Validity
  def impact: Option[nu.ndw.Impact]
  def cause: Option[nu.ndw.Cause]
  def generalPublicComment: Seq[nu.ndw.Comment]
  def nonGeneralPublicComment: Seq[nu.ndw.Comment]
  def urlLink: Seq[nu.ndw.UrlLink]
  def groupOfLocations: nu.ndw.GroupOfLocations
  def management: Option[nu.ndw.Management]
  def situationRecordExtension: Option[nu.ndw._SituationRecordExtensionType]
  def id: String
  def version: String
}



case class SituationRecordExtendedApproved(safetyRelatedMessage: Option[Boolean] = None)
      



case class Source(sourceCountry: Option[nu.ndw.CountryEnum] = None,
  sourceIdentification: Option[String] = None,
  sourceName: Option[nu.ndw.MultilingualString] = None,
  sourceType: Option[nu.ndw.SourceTypeEnum] = None,
  reliable: Option[Boolean] = None,
  sourceExtension: Option[nu.ndw._ExtensionType] = None)
      

sealed trait SourceTypeEnum

object SourceTypeEnum {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[nu.ndw.SourceTypeEnum]): SourceTypeEnum = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: SourceTypeEnum) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
}

case object AutomobileClubPatrol extends SourceTypeEnum { override def toString = "automobileClubPatrol" }
case object CameraObservation extends SourceTypeEnum { override def toString = "cameraObservation" }
case object FreightVehicleOperator extends SourceTypeEnum { override def toString = "freightVehicleOperator" }
case object InductionLoopMonitoringStation extends SourceTypeEnum { override def toString = "inductionLoopMonitoringStation" }
case object InfraredMonitoringStation extends SourceTypeEnum { override def toString = "infraredMonitoringStation" }
case object MicrowaveMonitoringStation extends SourceTypeEnum { override def toString = "microwaveMonitoringStation" }
case object MobileTelephoneCaller extends SourceTypeEnum { override def toString = "mobileTelephoneCaller" }
case object NonPoliceEmergencyServicePatrol extends SourceTypeEnum { override def toString = "nonPoliceEmergencyServicePatrol" }
case object OtherInformation extends SourceTypeEnum { override def toString = "otherInformation" }
case object OtherOfficialVehicle extends SourceTypeEnum { override def toString = "otherOfficialVehicle" }
case object PolicePatrol extends SourceTypeEnum { override def toString = "policePatrol" }
case object PrivateBreakdownService extends SourceTypeEnum { override def toString = "privateBreakdownService" }
case object PublicAndPrivateUtilities extends SourceTypeEnum { override def toString = "publicAndPrivateUtilities" }
case object RegisteredMotoristObserver extends SourceTypeEnum { override def toString = "registeredMotoristObserver" }
case object RoadAuthorities extends SourceTypeEnum { override def toString = "roadAuthorities" }
case object RoadOperatorPatrol extends SourceTypeEnum { override def toString = "roadOperatorPatrol" }
case object RoadsideTelephoneCaller extends SourceTypeEnum { override def toString = "roadsideTelephoneCaller" }
case object SpotterAircraft extends SourceTypeEnum { override def toString = "spotterAircraft" }
case object TrafficMonitoringStation extends SourceTypeEnum { override def toString = "trafficMonitoringStation" }
case object TransitOperator extends SourceTypeEnum { override def toString = "transitOperator" }
case object VehicleProbeMeasurement extends SourceTypeEnum { override def toString = "vehicleProbeMeasurement" }
case object VideoProcessingMonitoringStation extends SourceTypeEnum { override def toString = "videoProcessingMonitoringStation" }



case class SpecialDay(intersectWithApplicableDays: Boolean,
  specialDayType: nu.ndw.SpecialDayTypeEnum,
  specialDayName: Option[nu.ndw.MultilingualString] = None,
  publicHoliday: Seq[nu.ndw.PublicHolidayType] = Nil,
  specialDayExtension: Option[nu.ndw._ExtensionType] = None)
      

sealed trait SpecialDayTypeEnum

object SpecialDayTypeEnum {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[nu.ndw.SpecialDayTypeEnum]): SpecialDayTypeEnum = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: SpecialDayTypeEnum) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
}

case object BicycleRaceDay extends SpecialDayTypeEnum { override def toString = "bicycleRaceDay" }
case object BullFightDay extends SpecialDayTypeEnum { override def toString = "bullFightDay" }
case object CarnivalDay extends SpecialDayTypeEnum { override def toString = "carnivalDay" }
case object ExhibitionDay extends SpecialDayTypeEnum { override def toString = "exhibitionDay" }
case object FestivalDay extends SpecialDayTypeEnum { override def toString = "festivalDay" }
case object GamesDay extends SpecialDayTypeEnum { override def toString = "gamesDay" }
case object HorseRaceMeetingDay extends SpecialDayTypeEnum { override def toString = "horseRaceMeetingDay" }
case object HuntMeetingDay extends SpecialDayTypeEnum { override def toString = "huntMeetingDay" }
case object MarathonRaceDay extends SpecialDayTypeEnum { override def toString = "marathonRaceDay" }
case object MarketDay extends SpecialDayTypeEnum { override def toString = "marketDay" }
case object MotorSportRaceMeetingDay extends SpecialDayTypeEnum { override def toString = "motorSportRaceMeetingDay" }
case object NonWorkingDay extends SpecialDayTypeEnum { override def toString = "nonWorkingDay" }
case object RaceMeetingDay extends SpecialDayTypeEnum { override def toString = "raceMeetingDay" }
case object RegattaDay extends SpecialDayTypeEnum { override def toString = "regattaDay" }
case object ShowDay extends SpecialDayTypeEnum { override def toString = "showDay" }
case object SportsMeetingDay extends SpecialDayTypeEnum { override def toString = "sportsMeetingDay" }
case object WorkingDay extends SpecialDayTypeEnum { override def toString = "workingDay" }
case object SchoolDay extends SpecialDayTypeEnum { override def toString = "schoolDay" }
case object ElectionDay extends SpecialDayTypeEnum { override def toString = "electionDay" }
case object PublicHoliday extends SpecialDayTypeEnum { override def toString = "publicHoliday" }
case object Holidays extends SpecialDayTypeEnum { override def toString = "holidays" }
case object UndefinedDayType extends SpecialDayTypeEnum { override def toString = "undefinedDayType" }
case object UnknownValue5 extends SpecialDayTypeEnum { override def toString = "unknown" }
case object OtherValue11 extends SpecialDayTypeEnum { override def toString = "other" }



case class SpecialLocationParkingSite(parkingName: Option[nu.ndw.MultilingualString] = None,
  parkingAlias: Seq[nu.ndw.MultilingualString] = Nil,
  parkingDescription: Option[nu.ndw.MultilingualString] = None,
  parkingRecordVersionTime: javax.xml.datatype.XMLGregorianCalendar,
  parkingNumberOfSpaces: Option[Int] = None,
  parkingPrincipalNumberOfSpaces: Option[Int] = None,
  maximumParkingDuration: Option[Float] = None,
  photoUrl: Option[java.net.URI] = None,
  urlLinkAddress: Option[java.net.URI] = None,
  parkingOccupanyDetectionType: Seq[nu.ndw.OccupancyDetectionTypeEnum] = Nil,
  emergencyContact: Seq[nu.ndw.Contactable] = Nil,
  owner: Seq[nu.ndw.Contactable] = Nil,
  responisbleAuthority: Seq[nu.ndw.Contactable] = Nil,
  securityService: Seq[nu.ndw.Contactable] = Nil,
  operator: Seq[nu.ndw.Contactable] = Nil,
  servicePartner: Seq[nu.ndw.Contactable] = Nil,
  parkingVMS: Seq[nu.ndw.ParkingVMS] = Nil,
  parkingLocation: nu.ndw.GroupOfLocations,
  parkingRoute: Seq[nu.ndw.ParkingRoute] = Nil,
  parkingColour: Option[nu.ndw.RGBColour] = None,
  onlyAssignedParking: Option[nu.ndw.ParkingAssignment] = None,
  assignedParkingAmongOthers: Option[nu.ndw.ParkingAssignment] = None,
  prohibitedParking: Option[nu.ndw.ParkingAssignment] = None,
  tariffsAndPayment: Option[nu.ndw.TariffsAndPayment] = None,
  parkingEquipmentOrServiceFacility: Seq[nu.ndw._ParkingRecordEquipmentOrServiceFacilityIndexParkingEquipmentOrServiceFacility] = Nil,
  parkingSpace: Seq[nu.ndw._ParkingSpace] = Nil,
  groupOfParkingSpaces: Seq[nu.ndw._GroupOfParkingSpaces] = Nil,
  parkingThresholds: Option[nu.ndw.ParkingThresholds] = None,
  permitsAndProhibitions: Seq[nu.ndw.PermitsAndProhibitions] = Nil,
  emergencyAssemblyPoint: Option[nu.ndw.GroupOfLocations] = None,
  entireArea: Option[nu.ndw.Area] = None,
  parkingRecordDimension: Option[nu.ndw.Dimension] = None,
  parkingRecordExtension: Option[nu.ndw._ExtensionType] = None,
  parkingReservation: Option[nu.ndw.ReservationTypeEnum] = None,
  parkingLayout: Seq[nu.ndw.ParkingLayoutEnum] = Nil,
  highestFloor: Option[Int] = None,
  lowestFloor: Option[Int] = None,
  temporaryParking: Option[Boolean] = None,
  parkingSiteAddress: Seq[nu.ndw.Contactable] = Nil,
  reservationService: Seq[nu.ndw.Contactable] = Nil,
  parkingUsageScenario: Seq[nu.ndw._ParkingSiteScenarioIndexParkingUsageScenario] = Nil,
  openingTimes: Option[nu.ndw.OpeningTimes] = None,
  parkingAccess: Seq[nu.ndw.ParkingAccess] = Nil,
  parkingStandardsAndSecurity: Option[nu.ndw.ParkingStandardsAndSecurity] = None,
  parkingSiteExtension: Option[nu.ndw._ExtensionType] = None,
  parkingSpecialLocation: nu.ndw.ParkingSpecialLocationEnum,
  parkingOtherSpecialLocation: Option[nu.ndw.MultilingualString] = None,
  specialLocationParkingSiteExtension: Option[nu.ndw._ExtensionType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) extends ParkingSite {
  @JsonIgnore lazy val id = attributes("@id").as[String]
  @JsonIgnore lazy val version = attributes("@version").as[String]
}

      



case class SpeedManagement(situationRecordCreationReference: Option[String] = None,
  situationRecordCreationTime: javax.xml.datatype.XMLGregorianCalendar,
  situationRecordObservationTime: Option[javax.xml.datatype.XMLGregorianCalendar] = None,
  situationRecordVersionTime: javax.xml.datatype.XMLGregorianCalendar,
  situationRecordFirstSupplierVersionTime: Option[javax.xml.datatype.XMLGregorianCalendar] = None,
  confidentialityOverride: Option[nu.ndw.ConfidentialityValueEnum] = None,
  probabilityOfOccurrence: nu.ndw.ProbabilityOfOccurrenceEnum,
  severity: Option[nu.ndw.SeverityEnum] = None,
  source: Option[nu.ndw.Source] = None,
  validity: nu.ndw.Validity,
  impact: Option[nu.ndw.Impact] = None,
  cause: Option[nu.ndw.Cause] = None,
  generalPublicComment: Seq[nu.ndw.Comment] = Nil,
  nonGeneralPublicComment: Seq[nu.ndw.Comment] = Nil,
  urlLink: Seq[nu.ndw.UrlLink] = Nil,
  groupOfLocations: nu.ndw.GroupOfLocations,
  management: Option[nu.ndw.Management] = None,
  situationRecordExtension: Option[nu.ndw._SituationRecordExtensionType] = None,
  actionOrigin: Option[nu.ndw.OperatorActionOriginEnum] = None,
  actionPlanIdentifier: Option[String] = None,
  operatorActionStatus: Option[nu.ndw.OperatorActionStatusEnum] = None,
  operatorActionExtension: Option[nu.ndw._ExtensionType] = None,
  complianceOption: nu.ndw.ComplianceOptionEnum,
  applicableForTrafficDirection: Seq[nu.ndw.DirectionEnum] = Nil,
  applicableForTrafficType: Seq[nu.ndw.TrafficTypeEnum] = Nil,
  placesAtWhichApplicable: Seq[nu.ndw.PlacesEnum] = Nil,
  automaticallyInitiated: Option[Boolean] = None,
  forVehiclesWithCharacteristicsOf: Seq[nu.ndw.VehicleCharacteristics] = Nil,
  networkManagementExtension: Option[nu.ndw._ExtensionType] = None,
  speedManagementType: Option[nu.ndw.SpeedManagementTypeEnum] = None,
  temporarySpeedLimit: Option[Float] = None,
  speedManagementExtension: Option[nu.ndw._ExtensionType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) extends NetworkManagement {
  @JsonIgnore lazy val id = attributes("@id").as[String]
  @JsonIgnore lazy val version = attributes("@version").as[String]
}

      

sealed trait SpeedManagementTypeEnum

object SpeedManagementTypeEnum {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[nu.ndw.SpeedManagementTypeEnum]): SpeedManagementTypeEnum = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: SpeedManagementTypeEnum) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
}

case object ActiveSpeedControlInOperation extends SpeedManagementTypeEnum { override def toString = "activeSpeedControlInOperation" }
case object DoNotSlowdownUnnecessarily extends SpeedManagementTypeEnum { override def toString = "doNotSlowdownUnnecessarily" }
case object ObserveSpeedLimit extends SpeedManagementTypeEnum { override def toString = "observeSpeedLimit" }
case object PoliceSpeedChecksInOperation extends SpeedManagementTypeEnum { override def toString = "policeSpeedChecksInOperation" }
case object ReduceYourSpeed extends SpeedManagementTypeEnum { override def toString = "reduceYourSpeed" }
case object SpeedRestrictionInOperation extends SpeedManagementTypeEnum { override def toString = "speedRestrictionInOperation" }
case object OtherValue80 extends SpeedManagementTypeEnum { override def toString = "other" }



case class SpeedPercentile(vehiclePercentage: nu.ndw.PercentageValue,
  speedPercentile: nu.ndw.SpeedValue,
  speedPercentileExtension: Option[nu.ndw._ExtensionType] = None)
      



case class SpeedValue(dataError: Option[Boolean] = None,
  reasonForDataError: Option[nu.ndw.MultilingualString] = None,
  dataValueExtension: Option[nu.ndw._ExtensionType] = None,
  speed: Float,
  speedValueExtension: Option[nu.ndw._ExtensionType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) extends DataValue {
  @JsonIgnore lazy val accuracy = attributes.get("@accuracy") map { _.as[Float]}
  @JsonIgnore lazy val computationalMethod = attributes.get("@computationalMethod") map { _.as[ComputationMethodEnum]}
  @JsonIgnore lazy val numberOfIncompleteInputs = attributes.get("@numberOfIncompleteInputs") map { _.as[Int]}
  @JsonIgnore lazy val numberOfInputValuesUsed = attributes.get("@numberOfInputValuesUsed") map { _.as[Int]}
  @JsonIgnore lazy val smoothingFactor = attributes.get("@smoothingFactor") map { _.as[Float]}
  @JsonIgnore lazy val standardDeviation = attributes.get("@standardDeviation") map { _.as[Float]}
  @JsonIgnore lazy val supplierCalculatedDataQuality = attributes.get("@supplierCalculatedDataQuality") map { _.as[Float]}
}

      



case class Subjects(subjectTypeOfWorks: nu.ndw.SubjectTypeOfWorksEnum,
  numberOfSubjects: Option[Int] = None,
  subjectsExtension: Option[nu.ndw._ExtensionType] = None)
      

sealed trait SubjectTypeOfWorksEnum

object SubjectTypeOfWorksEnum {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[nu.ndw.SubjectTypeOfWorksEnum]): SubjectTypeOfWorksEnum = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: SubjectTypeOfWorksEnum) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
}

case object Bridge extends SubjectTypeOfWorksEnum { override def toString = "bridge" }
case object BuriedCables extends SubjectTypeOfWorksEnum { override def toString = "buriedCables" }
case object BuriedServices extends SubjectTypeOfWorksEnum { override def toString = "buriedServices" }
case object CrashBarrier extends SubjectTypeOfWorksEnum { override def toString = "crashBarrier" }
case object Gallery extends SubjectTypeOfWorksEnum { override def toString = "gallery" }
case object Gantry extends SubjectTypeOfWorksEnum { override def toString = "gantry" }
case object GasMainWork extends SubjectTypeOfWorksEnum { override def toString = "gasMainWork" }
case object InterchangeValue extends SubjectTypeOfWorksEnum { override def toString = "interchange" }
case object JunctionValue extends SubjectTypeOfWorksEnum { override def toString = "junction" }
case object LevelCrossingValue extends SubjectTypeOfWorksEnum { override def toString = "levelCrossing" }
case object LightingSystem extends SubjectTypeOfWorksEnum { override def toString = "lightingSystem" }
case object MeasurementEquipment extends SubjectTypeOfWorksEnum { override def toString = "measurementEquipment" }
case object NoiseProtection extends SubjectTypeOfWorksEnum { override def toString = "noiseProtection" }
case object RoadValue extends SubjectTypeOfWorksEnum { override def toString = "road" }
case object RoadsideDrains extends SubjectTypeOfWorksEnum { override def toString = "roadsideDrains" }
case object RoadsideEmbankment extends SubjectTypeOfWorksEnum { override def toString = "roadsideEmbankment" }
case object RoadsideEquipment extends SubjectTypeOfWorksEnum { override def toString = "roadsideEquipment" }
case object RoadSigns extends SubjectTypeOfWorksEnum { override def toString = "roadSigns" }
case object RoundaboutValue2 extends SubjectTypeOfWorksEnum { override def toString = "roundabout" }
case object TollGate extends SubjectTypeOfWorksEnum { override def toString = "tollGate" }
case object Tunnel extends SubjectTypeOfWorksEnum { override def toString = "tunnel" }
case object WaterMain extends SubjectTypeOfWorksEnum { override def toString = "waterMain" }
case object OtherValue81 extends SubjectTypeOfWorksEnum { override def toString = "other" }



case class Subscription(deleteSubscription: Option[Boolean] = None,
  deliveryInterval: Option[Float] = None,
  operatingMode: nu.ndw.OperatingModeEnum,
  subscriptionStartTime: javax.xml.datatype.XMLGregorianCalendar,
  subscriptionState: nu.ndw.SubscriptionStateEnum,
  subscriptionStopTime: Option[javax.xml.datatype.XMLGregorianCalendar] = None,
  updateMethod: nu.ndw.UpdateMethodEnum,
  target: Seq[nu.ndw.Target] = Nil,
  filterReference: Option[nu.ndw.FilterReference] = None,
  catalogueReference: Option[nu.ndw.CatalogueReference] = None,
  subscriptionExtension: Option[nu.ndw._ExtensionType] = None)
      

sealed trait SubscriptionStateEnum

object SubscriptionStateEnum {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[nu.ndw.SubscriptionStateEnum]): SubscriptionStateEnum = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: SubscriptionStateEnum) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
}

case object ActiveValue extends SubscriptionStateEnum { override def toString = "active" }
case object SuspendedValue extends SubscriptionStateEnum { override def toString = "suspended" }



case class SupplementaryPositionalDescription(locationDescriptor: Seq[nu.ndw.LocationDescriptorEnum] = Nil,
  sequentialRampNumber: Option[Int] = None,
  affectedCarriagewayAndLanes: Seq[nu.ndw.AffectedCarriagewayAndLanes] = Nil,
  supplementaryPositionalDescriptionExtension: Option[nu.ndw._ExtensionType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  @JsonIgnore lazy val locationPrecision = attributes.get("@locationPrecision") map { _.as[Int]}
}

      



case class Target(address: String,
  protocol: String,
  targetExtension: Option[nu.ndw._ExtensionType] = None)
      



case class TariffsAndPayment(lastUpdated: Option[javax.xml.datatype.XMLGregorianCalendar] = None,
  acceptedMeansOfPayment: Seq[nu.ndw.MeansOfPaymentEnum] = Nil,
  paymentMode: Seq[nu.ndw.ParkingPaymentModeEnum] = Nil,
  paymentAdditionalDescription: Option[nu.ndw.MultilingualString] = None,
  freeOfCharge: Option[Boolean] = None,
  reservationFee: Option[BigDecimal] = None,
  urlLinkAddress: Option[java.net.URI] = None,
  chargeBand: Seq[nu.ndw.ChargeBand] = Nil,
  chargeBandByReference: Seq[nu.ndw.ChargeBandByReference] = Nil,
  acceptedPaymentCards: Option[nu.ndw.AcceptedPaymentCards] = None,
  tariffsAndPaymentExtension: Option[nu.ndw._ExtensionType] = None)
      



case class TemperatureType(airTemperature: Option[nu.ndw.TemperatureValue] = None,
  dewPointTemperature: Option[nu.ndw.TemperatureValue] = None,
  maximumTemperature: Option[nu.ndw.TemperatureValue] = None,
  minimumTemperature: Option[nu.ndw.TemperatureValue] = None,
  temperatureExtension: Option[nu.ndw._ExtensionType] = None)
      



case class TemperatureInformationType(measurementOrCalculationPeriod: Option[Float] = None,
  measurementOrCalculationTime: Option[javax.xml.datatype.XMLGregorianCalendar] = None,
  pertinentLocation: Option[nu.ndw.GroupOfLocations] = None,
  basicDataExtension: Option[nu.ndw._ExtensionType] = None,
  weatherDataExtension: Option[nu.ndw._ExtensionType] = None,
  temperature: nu.ndw.TemperatureType,
  temperatureInformationExtension: Option[nu.ndw._ExtensionType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) extends WeatherData {
  @JsonIgnore lazy val measurementOrCalculatedTimePrecision = attributes.get("@measurementOrCalculatedTimePrecision") map { _.as[TimePrecisionEnum]}
}

      



case class TemperatureValue(dataError: Option[Boolean] = None,
  reasonForDataError: Option[nu.ndw.MultilingualString] = None,
  dataValueExtension: Option[nu.ndw._ExtensionType] = None,
  temperature: Float,
  temperatureValueExtension: Option[nu.ndw._ExtensionType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) extends DataValue {
  @JsonIgnore lazy val accuracy = attributes.get("@accuracy") map { _.as[Float]}
  @JsonIgnore lazy val computationalMethod = attributes.get("@computationalMethod") map { _.as[ComputationMethodEnum]}
  @JsonIgnore lazy val numberOfIncompleteInputs = attributes.get("@numberOfIncompleteInputs") map { _.as[Int]}
  @JsonIgnore lazy val numberOfInputValuesUsed = attributes.get("@numberOfInputValuesUsed") map { _.as[Int]}
  @JsonIgnore lazy val smoothingFactor = attributes.get("@smoothingFactor") map { _.as[Float]}
  @JsonIgnore lazy val standardDeviation = attributes.get("@standardDeviation") map { _.as[Float]}
  @JsonIgnore lazy val supplierCalculatedDataQuality = attributes.get("@supplierCalculatedDataQuality") map { _.as[Float]}
}

      



case class TextDisplayAreaSettings(textLanternsOn: Option[Boolean] = None,
  textLuminanceOverride: Option[Boolean] = None,
  textLuminanceLevel: Option[Int] = None,
  textLuminanceLevelName: Option[nu.ndw.VmsLuminanceLevelEnum] = None,
  textDisplayAreaSettingsExtension: Option[nu.ndw._ExtensionType] = None)
      



case class TimePeriodByHour(timePeriodOfDayExtension: Option[nu.ndw._ExtensionType] = None,
  startTimeOfPeriod: javax.xml.datatype.XMLGregorianCalendar,
  endTimeOfPeriod: javax.xml.datatype.XMLGregorianCalendar,
  timePeriodByHourExtension: Option[nu.ndw._ExtensionType] = None) extends TimePeriodOfDay
      


sealed trait TimePeriodOfDay {
  def timePeriodOfDayExtension: Option[nu.ndw._ExtensionType]
}

sealed trait TimePrecisionEnum

object TimePrecisionEnum {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[nu.ndw.TimePrecisionEnum]): TimePrecisionEnum = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: TimePrecisionEnum) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
}

case object TenthsOfSecond extends TimePrecisionEnum { override def toString = "tenthsOfSecond" }
case object Second extends TimePrecisionEnum { override def toString = "second" }
case object Minute extends TimePrecisionEnum { override def toString = "minute" }
case object QuarterHour extends TimePrecisionEnum { override def toString = "quarterHour" }
case object HalfHour extends TimePrecisionEnum { override def toString = "halfHour" }
case object Hour extends TimePrecisionEnum { override def toString = "hour" }



case class TpegAreaDescriptor(descriptor: nu.ndw.MultilingualString,
  tpegDescriptorExtension: Option[nu.ndw._ExtensionType] = None,
  tpegAreaDescriptorType: nu.ndw.TpegLoc03AreaDescriptorSubtypeEnum,
  tpegAreaDescriptorExtension: Option[nu.ndw._ExtensionType] = None) extends TpegDescriptor
      


sealed trait TpegAreaLocation {
  def tpegAreaLocationType: nu.ndw.TpegLoc01AreaLocationSubtypeEnum
  def tpegHeight: Option[nu.ndw.TpegHeight]
  def tpegAreaLocationExtension: Option[nu.ndw._ExtensionType]
}


sealed trait TpegDescriptor {
  def descriptor: nu.ndw.MultilingualString
  def tpegDescriptorExtension: Option[nu.ndw._ExtensionType]
}



case class TpegFramedPoint(tpegDirection: nu.ndw.DirectionEnum,
  tpegPointLocationExtension: Option[nu.ndw._ExtensionType] = None,
  tpegFramedPointLocationType: nu.ndw.TpegLoc01FramedPointLocationSubtypeEnum,
  framedPoint: nu.ndw.TpegNonJunctionPoint,
  to: nu.ndw.TpegPoint,
  from: nu.ndw.TpegPoint,
  tpegFramedPointExtension: Option[nu.ndw._ExtensionType] = None) extends TpegPointLocation
      



case class TpegGeometricArea(tpegAreaLocationType: nu.ndw.TpegLoc01AreaLocationSubtypeEnum,
  tpegHeight: Option[nu.ndw.TpegHeight] = None,
  tpegAreaLocationExtension: Option[nu.ndw._ExtensionType] = None,
  radius: Int,
  centrePoint: nu.ndw.PointCoordinates,
  name: Option[nu.ndw.TpegAreaDescriptor] = None,
  tpegGeometricAreaExtension: Option[nu.ndw._ExtensionType] = None) extends TpegAreaLocation
      



case class TpegHeight(height: Option[Float] = None,
  heightType: nu.ndw.TpegLoc04HeightTypeEnum,
  tpegHeightExtension: Option[nu.ndw._ExtensionType] = None)
      



case class TpegIlcPointDescriptor(descriptor: nu.ndw.MultilingualString,
  tpegDescriptorExtension: Option[nu.ndw._ExtensionType] = None,
  tpegPointDescriptorExtension: Option[nu.ndw._ExtensionType] = None,
  tpegIlcPointDescriptorType: nu.ndw.TpegLoc03IlcPointDescriptorSubtypeEnum,
  tpegIlcPointDescriptorExtension: Option[nu.ndw._ExtensionType] = None) extends TpegPointDescriptor
      



case class TpegJunction(tpegPointExtension: Option[nu.ndw._ExtensionType] = None,
  pointCoordinates: nu.ndw.PointCoordinates,
  name: Option[nu.ndw.TpegJunctionPointDescriptor] = None,
  ilc: Seq[nu.ndw.TpegIlcPointDescriptor] = Nil,
  otherName: Seq[nu.ndw.TpegOtherPointDescriptor] = Nil,
  tpegJunctionExtension: Option[nu.ndw._ExtensionType] = None) extends TpegPoint
      



case class TpegJunctionPointDescriptor(descriptor: nu.ndw.MultilingualString,
  tpegDescriptorExtension: Option[nu.ndw._ExtensionType] = None,
  tpegPointDescriptorExtension: Option[nu.ndw._ExtensionType] = None,
  tpegJunctionPointDescriptorType: nu.ndw.TpegLoc03JunctionPointDescriptorSubtypeEnum,
  tpegJunctionPointDescriptorExtension: Option[nu.ndw._ExtensionType] = None) extends TpegPointDescriptor
      



case class TpegLinearLocation(tpegDirection: nu.ndw.DirectionEnum,
  tpegLinearLocationType: nu.ndw.TpegLoc01LinearLocationSubtypeEnum,
  to: nu.ndw.TpegPoint,
  from: nu.ndw.TpegPoint,
  tpegLinearLocationExtension: Option[nu.ndw._ExtensionType] = None)
      

sealed trait TpegLoc01AreaLocationSubtypeEnum

object TpegLoc01AreaLocationSubtypeEnum {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[nu.ndw.TpegLoc01AreaLocationSubtypeEnum]): TpegLoc01AreaLocationSubtypeEnum = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: TpegLoc01AreaLocationSubtypeEnum) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
}

case object LargeArea extends TpegLoc01AreaLocationSubtypeEnum { override def toString = "largeArea" }
case object OtherValue82 extends TpegLoc01AreaLocationSubtypeEnum { override def toString = "other" }

sealed trait TpegLoc01FramedPointLocationSubtypeEnum

object TpegLoc01FramedPointLocationSubtypeEnum {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[nu.ndw.TpegLoc01FramedPointLocationSubtypeEnum]): TpegLoc01FramedPointLocationSubtypeEnum = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: TpegLoc01FramedPointLocationSubtypeEnum) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
}

case object FramedPoint extends TpegLoc01FramedPointLocationSubtypeEnum { override def toString = "framedPoint" }

sealed trait TpegLoc01LinearLocationSubtypeEnum

object TpegLoc01LinearLocationSubtypeEnum {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[nu.ndw.TpegLoc01LinearLocationSubtypeEnum]): TpegLoc01LinearLocationSubtypeEnum = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: TpegLoc01LinearLocationSubtypeEnum) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
}

case object Segment extends TpegLoc01LinearLocationSubtypeEnum { override def toString = "segment" }

sealed trait TpegLoc01SimplePointLocationSubtypeEnum

object TpegLoc01SimplePointLocationSubtypeEnum {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[nu.ndw.TpegLoc01SimplePointLocationSubtypeEnum]): TpegLoc01SimplePointLocationSubtypeEnum = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: TpegLoc01SimplePointLocationSubtypeEnum) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
}

case object Intersection extends TpegLoc01SimplePointLocationSubtypeEnum { override def toString = "intersection" }
case object NonLinkedPoint extends TpegLoc01SimplePointLocationSubtypeEnum { override def toString = "nonLinkedPoint" }

sealed trait TpegLoc03AreaDescriptorSubtypeEnum

object TpegLoc03AreaDescriptorSubtypeEnum {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[nu.ndw.TpegLoc03AreaDescriptorSubtypeEnum]): TpegLoc03AreaDescriptorSubtypeEnum = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: TpegLoc03AreaDescriptorSubtypeEnum) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
}

case object AdministrativeAreaNameValue extends TpegLoc03AreaDescriptorSubtypeEnum { override def toString = "administrativeAreaName" }
case object AdministrativeReferenceNameValue extends TpegLoc03AreaDescriptorSubtypeEnum { override def toString = "administrativeReferenceName" }
case object AreaNameValue extends TpegLoc03AreaDescriptorSubtypeEnum { override def toString = "areaName" }
case object CountyNameValue extends TpegLoc03AreaDescriptorSubtypeEnum { override def toString = "countyName" }
case object LakeNameValue extends TpegLoc03AreaDescriptorSubtypeEnum { override def toString = "lakeName" }
case object NationNameValue extends TpegLoc03AreaDescriptorSubtypeEnum { override def toString = "nationName" }
case object PoliceForceControlAreaName extends TpegLoc03AreaDescriptorSubtypeEnum { override def toString = "policeForceControlAreaName" }
case object RegionNameValue extends TpegLoc03AreaDescriptorSubtypeEnum { override def toString = "regionName" }
case object SeaNameValue extends TpegLoc03AreaDescriptorSubtypeEnum { override def toString = "seaName" }
case object TownNameValue extends TpegLoc03AreaDescriptorSubtypeEnum { override def toString = "townName" }
case object OtherValue83 extends TpegLoc03AreaDescriptorSubtypeEnum { override def toString = "other" }

sealed trait TpegLoc03IlcPointDescriptorSubtypeEnum

object TpegLoc03IlcPointDescriptorSubtypeEnum {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[nu.ndw.TpegLoc03IlcPointDescriptorSubtypeEnum]): TpegLoc03IlcPointDescriptorSubtypeEnum = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: TpegLoc03IlcPointDescriptorSubtypeEnum) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
}

case object TpegIlcName1 extends TpegLoc03IlcPointDescriptorSubtypeEnum { override def toString = "tpegIlcName1" }
case object TpegIlcName2 extends TpegLoc03IlcPointDescriptorSubtypeEnum { override def toString = "tpegIlcName2" }
case object TpegIlcName3 extends TpegLoc03IlcPointDescriptorSubtypeEnum { override def toString = "tpegIlcName3" }

sealed trait TpegLoc03JunctionPointDescriptorSubtypeEnum

object TpegLoc03JunctionPointDescriptorSubtypeEnum {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[nu.ndw.TpegLoc03JunctionPointDescriptorSubtypeEnum]): TpegLoc03JunctionPointDescriptorSubtypeEnum = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: TpegLoc03JunctionPointDescriptorSubtypeEnum) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
}

case object JunctionName extends TpegLoc03JunctionPointDescriptorSubtypeEnum { override def toString = "junctionName" }

sealed trait TpegLoc03OtherPointDescriptorSubtypeEnum

object TpegLoc03OtherPointDescriptorSubtypeEnum {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[nu.ndw.TpegLoc03OtherPointDescriptorSubtypeEnum]): TpegLoc03OtherPointDescriptorSubtypeEnum = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: TpegLoc03OtherPointDescriptorSubtypeEnum) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
}

case object AdministrativeAreaName extends TpegLoc03OtherPointDescriptorSubtypeEnum { override def toString = "administrativeAreaName" }
case object AdministrativeReferenceName extends TpegLoc03OtherPointDescriptorSubtypeEnum { override def toString = "administrativeReferenceName" }
case object AirportName extends TpegLoc03OtherPointDescriptorSubtypeEnum { override def toString = "airportName" }
case object AreaName extends TpegLoc03OtherPointDescriptorSubtypeEnum { override def toString = "areaName" }
case object BuildingName extends TpegLoc03OtherPointDescriptorSubtypeEnum { override def toString = "buildingName" }
case object BusStopIdentifier extends TpegLoc03OtherPointDescriptorSubtypeEnum { override def toString = "busStopIdentifier" }
case object BusStopName extends TpegLoc03OtherPointDescriptorSubtypeEnum { override def toString = "busStopName" }
case object CanalName extends TpegLoc03OtherPointDescriptorSubtypeEnum { override def toString = "canalName" }
case object CountyName extends TpegLoc03OtherPointDescriptorSubtypeEnum { override def toString = "countyName" }
case object FerryPortName extends TpegLoc03OtherPointDescriptorSubtypeEnum { override def toString = "ferryPortName" }
case object IntersectionName extends TpegLoc03OtherPointDescriptorSubtypeEnum { override def toString = "intersectionName" }
case object LakeName extends TpegLoc03OtherPointDescriptorSubtypeEnum { override def toString = "lakeName" }
case object LinkName extends TpegLoc03OtherPointDescriptorSubtypeEnum { override def toString = "linkName" }
case object LocalLinkName extends TpegLoc03OtherPointDescriptorSubtypeEnum { override def toString = "localLinkName" }
case object MetroStationName extends TpegLoc03OtherPointDescriptorSubtypeEnum { override def toString = "metroStationName" }
case object NationName extends TpegLoc03OtherPointDescriptorSubtypeEnum { override def toString = "nationName" }
case object NonLinkedPointName extends TpegLoc03OtherPointDescriptorSubtypeEnum { override def toString = "nonLinkedPointName" }
case object ParkingFacilityName extends TpegLoc03OtherPointDescriptorSubtypeEnum { override def toString = "parkingFacilityName" }
case object PointName extends TpegLoc03OtherPointDescriptorSubtypeEnum { override def toString = "pointName" }
case object PointOfInterestName extends TpegLoc03OtherPointDescriptorSubtypeEnum { override def toString = "pointOfInterestName" }
case object RailwayStation extends TpegLoc03OtherPointDescriptorSubtypeEnum { override def toString = "railwayStation" }
case object RegionName extends TpegLoc03OtherPointDescriptorSubtypeEnum { override def toString = "regionName" }
case object RiverName extends TpegLoc03OtherPointDescriptorSubtypeEnum { override def toString = "riverName" }
case object SeaName extends TpegLoc03OtherPointDescriptorSubtypeEnum { override def toString = "seaName" }
case object ServiceAreaName extends TpegLoc03OtherPointDescriptorSubtypeEnum { override def toString = "serviceAreaName" }
case object TidalRiverName extends TpegLoc03OtherPointDescriptorSubtypeEnum { override def toString = "tidalRiverName" }
case object TownName extends TpegLoc03OtherPointDescriptorSubtypeEnum { override def toString = "townName" }
case object OtherValue10 extends TpegLoc03OtherPointDescriptorSubtypeEnum { override def toString = "other" }

sealed trait TpegLoc04HeightTypeEnum

object TpegLoc04HeightTypeEnum {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[nu.ndw.TpegLoc04HeightTypeEnum]): TpegLoc04HeightTypeEnum = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: TpegLoc04HeightTypeEnum) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
}

case object AboveValue extends TpegLoc04HeightTypeEnum { override def toString = "above" }
case object AboveSeaLevel extends TpegLoc04HeightTypeEnum { override def toString = "aboveSeaLevel" }
case object AboveStreetLevel extends TpegLoc04HeightTypeEnum { override def toString = "aboveStreetLevel" }
case object AtValue extends TpegLoc04HeightTypeEnum { override def toString = "at" }
case object AtSeaLevel extends TpegLoc04HeightTypeEnum { override def toString = "atSeaLevel" }
case object AtStreetLevel extends TpegLoc04HeightTypeEnum { override def toString = "atStreetLevel" }
case object BelowValue extends TpegLoc04HeightTypeEnum { override def toString = "below" }
case object BelowSeaLevel extends TpegLoc04HeightTypeEnum { override def toString = "belowSeaLevel" }
case object BelowStreetLevel extends TpegLoc04HeightTypeEnum { override def toString = "belowStreetLevel" }
case object UndefinedValue extends TpegLoc04HeightTypeEnum { override def toString = "undefined" }
case object UnknownValue45 extends TpegLoc04HeightTypeEnum { override def toString = "unknown" }
case object OtherValue84 extends TpegLoc04HeightTypeEnum { override def toString = "other" }



case class TpegNamedOnlyArea(tpegAreaLocationType: nu.ndw.TpegLoc01AreaLocationSubtypeEnum,
  tpegHeight: Option[nu.ndw.TpegHeight] = None,
  tpegAreaLocationExtension: Option[nu.ndw._ExtensionType] = None,
  name: Seq[nu.ndw.TpegAreaDescriptor] = Nil,
  tpegNamedOnlyAreaExtension: Option[nu.ndw._ExtensionType] = None) extends TpegAreaLocation
      



case class TpegNonJunctionPoint(tpegPointExtension: Option[nu.ndw._ExtensionType] = None,
  pointCoordinates: nu.ndw.PointCoordinates,
  name: Seq[nu.ndw.TpegOtherPointDescriptor] = Nil,
  tpegNonJunctionPointExtension: Option[nu.ndw._ExtensionType] = None) extends TpegPoint
      



case class TpegOtherPointDescriptor(descriptor: nu.ndw.MultilingualString,
  tpegDescriptorExtension: Option[nu.ndw._ExtensionType] = None,
  tpegPointDescriptorExtension: Option[nu.ndw._ExtensionType] = None,
  tpegOtherPointDescriptorType: nu.ndw.TpegLoc03OtherPointDescriptorSubtypeEnum,
  tpegOtherPointDescriptorExtension: Option[nu.ndw._ExtensionType] = None) extends TpegPointDescriptor
      


sealed trait TpegPoint {
  def tpegPointExtension: Option[nu.ndw._ExtensionType]
}


sealed trait TpegPointDescriptor extends TpegDescriptor {
  def descriptor: nu.ndw.MultilingualString
  def tpegDescriptorExtension: Option[nu.ndw._ExtensionType]
  def tpegPointDescriptorExtension: Option[nu.ndw._ExtensionType]
}


sealed trait TpegPointLocation {
  def tpegDirection: nu.ndw.DirectionEnum
  def tpegPointLocationExtension: Option[nu.ndw._ExtensionType]
}



case class TpegSimplePoint(tpegDirection: nu.ndw.DirectionEnum,
  tpegPointLocationExtension: Option[nu.ndw._ExtensionType] = None,
  tpegSimplePointLocationType: nu.ndw.TpegLoc01SimplePointLocationSubtypeEnum,
  point: nu.ndw.TpegPoint,
  tpegSimplePointExtension: Option[nu.ndw._ExtensionType] = None) extends TpegPointLocation
      



case class TrafficConcentrationType(measurementOrCalculationPeriod: Option[Float] = None,
  measurementOrCalculationTime: Option[javax.xml.datatype.XMLGregorianCalendar] = None,
  pertinentLocation: Option[nu.ndw.GroupOfLocations] = None,
  basicDataExtension: Option[nu.ndw._ExtensionType] = None,
  forVehiclesWithCharacteristicsOf: Option[nu.ndw.VehicleCharacteristics] = None,
  trafficDataExtension: Option[nu.ndw._ExtensionType] = None,
  concentration: Option[nu.ndw.ConcentrationOfVehiclesValue] = None,
  occupancy: Option[nu.ndw.PercentageValue] = None,
  trafficConcentrationExtension: Option[nu.ndw._ExtensionType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) extends TrafficData {
  @JsonIgnore lazy val measurementOrCalculatedTimePrecision = attributes.get("@measurementOrCalculatedTimePrecision") map { _.as[TimePrecisionEnum]}
}

      

sealed trait TrafficConstrictionTypeEnum

object TrafficConstrictionTypeEnum {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[nu.ndw.TrafficConstrictionTypeEnum]): TrafficConstrictionTypeEnum = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: TrafficConstrictionTypeEnum) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
}

case object CarriagewayBlocked extends TrafficConstrictionTypeEnum { override def toString = "carriagewayBlocked" }
case object CarriagewayPartiallyObstructed extends TrafficConstrictionTypeEnum { override def toString = "carriagewayPartiallyObstructed" }
case object LanesBlocked extends TrafficConstrictionTypeEnum { override def toString = "lanesBlocked" }
case object LanesPartiallyObstructed extends TrafficConstrictionTypeEnum { override def toString = "lanesPartiallyObstructed" }
case object RoadBlocked extends TrafficConstrictionTypeEnum { override def toString = "roadBlocked" }
case object RoadPartiallyObstructed extends TrafficConstrictionTypeEnum { override def toString = "roadPartiallyObstructed" }


sealed trait TrafficData extends BasicData {
  def measurementOrCalculationPeriod: Option[Float]
  def measurementOrCalculationTime: Option[javax.xml.datatype.XMLGregorianCalendar]
  def pertinentLocation: Option[nu.ndw.GroupOfLocations]
  def basicDataExtension: Option[nu.ndw._ExtensionType]
  def forVehiclesWithCharacteristicsOf: Option[nu.ndw.VehicleCharacteristics]
  def trafficDataExtension: Option[nu.ndw._ExtensionType]
  def measurementOrCalculatedTimePrecision: Option[nu.ndw.TimePrecisionEnum]
}


sealed trait TrafficElement extends SituationRecord {
  def situationRecordCreationReference: Option[String]
  def situationRecordCreationTime: javax.xml.datatype.XMLGregorianCalendar
  def situationRecordObservationTime: Option[javax.xml.datatype.XMLGregorianCalendar]
  def situationRecordVersionTime: javax.xml.datatype.XMLGregorianCalendar
  def situationRecordFirstSupplierVersionTime: Option[javax.xml.datatype.XMLGregorianCalendar]
  def confidentialityOverride: Option[nu.ndw.ConfidentialityValueEnum]
  def probabilityOfOccurrence: nu.ndw.ProbabilityOfOccurrenceEnum
  def severity: Option[nu.ndw.SeverityEnum]
  def source: Option[nu.ndw.Source]
  def validity: nu.ndw.Validity
  def impact: Option[nu.ndw.Impact]
  def cause: Option[nu.ndw.Cause]
  def generalPublicComment: Seq[nu.ndw.Comment]
  def nonGeneralPublicComment: Seq[nu.ndw.Comment]
  def urlLink: Seq[nu.ndw.UrlLink]
  def groupOfLocations: nu.ndw.GroupOfLocations
  def management: Option[nu.ndw.Management]
  def situationRecordExtension: Option[nu.ndw._SituationRecordExtensionType]
  def trafficElementExtension: Option[nu.ndw._ExtensionType]
  def id: String
  def version: String
}



case class TrafficFlowType(measurementOrCalculationPeriod: Option[Float] = None,
  measurementOrCalculationTime: Option[javax.xml.datatype.XMLGregorianCalendar] = None,
  pertinentLocation: Option[nu.ndw.GroupOfLocations] = None,
  basicDataExtension: Option[nu.ndw._ExtensionType] = None,
  forVehiclesWithCharacteristicsOf: Option[nu.ndw.VehicleCharacteristics] = None,
  trafficDataExtension: Option[nu.ndw._ExtensionType] = None,
  axleFlow: Option[nu.ndw.AxleFlowValue] = None,
  pcuFlow: Option[nu.ndw.PcuFlowValue] = None,
  percentageLongVehicles: Option[nu.ndw.PercentageValue] = None,
  vehicleFlow: Option[nu.ndw.VehicleFlowValue] = None,
  trafficFlowExtension: Option[nu.ndw._ExtensionType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) extends TrafficData {
  @JsonIgnore lazy val measurementOrCalculatedTimePrecision = attributes.get("@measurementOrCalculatedTimePrecision") map { _.as[TimePrecisionEnum]}
}

      

sealed trait TrafficFlowCharacteristicsEnum

object TrafficFlowCharacteristicsEnum {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[nu.ndw.TrafficFlowCharacteristicsEnum]): TrafficFlowCharacteristicsEnum = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: TrafficFlowCharacteristicsEnum) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
}

case object ErraticFlow extends TrafficFlowCharacteristicsEnum { override def toString = "erraticFlow" }
case object SmoothFlow extends TrafficFlowCharacteristicsEnum { override def toString = "smoothFlow" }
case object StopAndGo extends TrafficFlowCharacteristicsEnum { override def toString = "stopAndGo" }
case object TrafficBlocked extends TrafficFlowCharacteristicsEnum { override def toString = "trafficBlocked" }



case class TrafficHeadwayType(measurementOrCalculationPeriod: Option[Float] = None,
  measurementOrCalculationTime: Option[javax.xml.datatype.XMLGregorianCalendar] = None,
  pertinentLocation: Option[nu.ndw.GroupOfLocations] = None,
  basicDataExtension: Option[nu.ndw._ExtensionType] = None,
  forVehiclesWithCharacteristicsOf: Option[nu.ndw.VehicleCharacteristics] = None,
  trafficDataExtension: Option[nu.ndw._ExtensionType] = None,
  averageDistanceHeadway: Option[nu.ndw.FloatingPointMetreDistanceValue] = None,
  averageTimeHeadway: Option[nu.ndw.DurationValue] = None,
  trafficHeadwayExtension: Option[nu.ndw._ExtensionType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) extends TrafficData {
  @JsonIgnore lazy val measurementOrCalculatedTimePrecision = attributes.get("@measurementOrCalculatedTimePrecision") map { _.as[TimePrecisionEnum]}
}

      



case class TrafficSpeed(measurementOrCalculationPeriod: Option[Float] = None,
  measurementOrCalculationTime: Option[javax.xml.datatype.XMLGregorianCalendar] = None,
  pertinentLocation: Option[nu.ndw.GroupOfLocations] = None,
  basicDataExtension: Option[nu.ndw._ExtensionType] = None,
  forVehiclesWithCharacteristicsOf: Option[nu.ndw.VehicleCharacteristics] = None,
  trafficDataExtension: Option[nu.ndw._ExtensionType] = None,
  averageVehicleSpeed: Option[nu.ndw.SpeedValue] = None,
  speedPercentile: Option[nu.ndw.SpeedPercentile] = None,
  trafficSpeedExtension: Option[nu.ndw._ExtensionType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) extends TrafficData {
  @JsonIgnore lazy val measurementOrCalculatedTimePrecision = attributes.get("@measurementOrCalculatedTimePrecision") map { _.as[TimePrecisionEnum]}
}

      



case class TrafficStatus(measurementOrCalculationPeriod: Option[Float] = None,
  measurementOrCalculationTime: Option[javax.xml.datatype.XMLGregorianCalendar] = None,
  pertinentLocation: Option[nu.ndw.GroupOfLocations] = None,
  basicDataExtension: Option[nu.ndw._ExtensionType] = None,
  trafficTrendType: Option[nu.ndw.TrafficTrendTypeEnum] = None,
  trafficStatus: Option[nu.ndw.TrafficStatusValue] = None,
  trafficStatusExtension: Option[nu.ndw._ExtensionType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) extends BasicData {
  @JsonIgnore lazy val measurementOrCalculatedTimePrecision = attributes.get("@measurementOrCalculatedTimePrecision") map { _.as[TimePrecisionEnum]}
}

      

sealed trait TrafficStatusEnum

object TrafficStatusEnum {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[nu.ndw.TrafficStatusEnum]): TrafficStatusEnum = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: TrafficStatusEnum) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
}

case object Impossible extends TrafficStatusEnum { override def toString = "impossible" }
case object Congested extends TrafficStatusEnum { override def toString = "congested" }
case object Heavy extends TrafficStatusEnum { override def toString = "heavy" }
case object FreeFlow extends TrafficStatusEnum { override def toString = "freeFlow" }
case object UnknownValue4 extends TrafficStatusEnum { override def toString = "unknown" }



case class TrafficStatusValue(dataError: Option[Boolean] = None,
  reasonForDataError: Option[nu.ndw.MultilingualString] = None,
  dataValueExtension: Option[nu.ndw._ExtensionType] = None,
  trafficStatusValue: nu.ndw.TrafficStatusEnum,
  trafficStatusValueExtension: Option[nu.ndw._ExtensionType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) extends DataValue {
  @JsonIgnore lazy val accuracy = attributes.get("@accuracy") map { _.as[Float]}
  @JsonIgnore lazy val computationalMethod = attributes.get("@computationalMethod") map { _.as[ComputationMethodEnum]}
  @JsonIgnore lazy val numberOfIncompleteInputs = attributes.get("@numberOfIncompleteInputs") map { _.as[Int]}
  @JsonIgnore lazy val numberOfInputValuesUsed = attributes.get("@numberOfInputValuesUsed") map { _.as[Int]}
  @JsonIgnore lazy val smoothingFactor = attributes.get("@smoothingFactor") map { _.as[Float]}
  @JsonIgnore lazy val standardDeviation = attributes.get("@standardDeviation") map { _.as[Float]}
  @JsonIgnore lazy val supplierCalculatedDataQuality = attributes.get("@supplierCalculatedDataQuality") map { _.as[Float]}
}

      

sealed trait TrafficTrendTypeEnum

object TrafficTrendTypeEnum {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[nu.ndw.TrafficTrendTypeEnum]): TrafficTrendTypeEnum = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: TrafficTrendTypeEnum) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
}

case object TrafficBuildingUp extends TrafficTrendTypeEnum { override def toString = "trafficBuildingUp" }
case object TrafficEasing extends TrafficTrendTypeEnum { override def toString = "trafficEasing" }
case object TrafficStable extends TrafficTrendTypeEnum { override def toString = "trafficStable" }
case object UnknownValue3 extends TrafficTrendTypeEnum { override def toString = "unknown" }

sealed trait TrafficTypeEnum

object TrafficTypeEnum {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[nu.ndw.TrafficTypeEnum]): TrafficTypeEnum = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: TrafficTypeEnum) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
}

case object AccessOnlyTraffic extends TrafficTypeEnum { override def toString = "accessOnlyTraffic" }
case object DestinedForAirport extends TrafficTypeEnum { override def toString = "destinedForAirport" }
case object DestinedForAirportArrivals extends TrafficTypeEnum { override def toString = "destinedForAirportArrivals" }
case object DestinedForAirportDepartures extends TrafficTypeEnum { override def toString = "destinedForAirportDepartures" }
case object DestinedForFerryService extends TrafficTypeEnum { override def toString = "destinedForFerryService" }
case object DestinedForRailService extends TrafficTypeEnum { override def toString = "destinedForRailService" }
case object HolidayTrafficValue extends TrafficTypeEnum { override def toString = "holidayTraffic" }
case object LocalTraffic extends TrafficTypeEnum { override def toString = "localTraffic" }
case object LongDistanceTraffic extends TrafficTypeEnum { override def toString = "longDistanceTraffic" }
case object RegionalTraffic extends TrafficTypeEnum { override def toString = "regionalTraffic" }
case object ResidentsOnlyTraffic extends TrafficTypeEnum { override def toString = "residentsOnlyTraffic" }
case object ThroughTraffic extends TrafficTypeEnum { override def toString = "throughTraffic" }
case object VisitorTraffic extends TrafficTypeEnum { override def toString = "visitorTraffic" }



case class TrafficView(trafficViewTime: javax.xml.datatype.XMLGregorianCalendar,
  predefinedNonOrderedLocationGroupReference: nu.ndw._PredefinedNonOrderedLocationGroupVersionedReference,
  linearTrafficView: Seq[nu.ndw.LinearTrafficView] = Nil,
  trafficViewExtension: Option[nu.ndw._ExtensionType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  @JsonIgnore lazy val id = attributes("@id").as[String]
}

      



case class TrafficViewPublication(feedDescription: Option[nu.ndw.MultilingualString] = None,
  feedType: Option[String] = None,
  publicationTime: javax.xml.datatype.XMLGregorianCalendar,
  publicationCreator: nu.ndw.InternationalIdentifier,
  payloadPublicationExtension: Option[nu.ndw._ExtensionType] = None,
  headerInformation: nu.ndw.HeaderInformation,
  trafficView: Seq[nu.ndw.TrafficView] = Nil,
  trafficViewPublicationExtension: Option[nu.ndw._ExtensionType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) extends PayloadPublication {
  @JsonIgnore lazy val lang = attributes("@lang").as[String]
}

      



case class TrafficViewRecord(recordSequenceNumber: Int,
  trafficElement: Option[nu.ndw.TrafficElement] = None,
  operatorAction: Option[nu.ndw.OperatorActionable] = None,
  elaboratedData: Option[nu.ndw.ElaboratedData] = None,
  urlLink: Seq[nu.ndw.UrlLink] = Nil,
  trafficViewRecordExtension: Option[nu.ndw._ExtensionType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  @JsonIgnore lazy val id = attributes("@id").as[String]
}

      



case class TransitInformation(situationRecordCreationReference: Option[String] = None,
  situationRecordCreationTime: javax.xml.datatype.XMLGregorianCalendar,
  situationRecordObservationTime: Option[javax.xml.datatype.XMLGregorianCalendar] = None,
  situationRecordVersionTime: javax.xml.datatype.XMLGregorianCalendar,
  situationRecordFirstSupplierVersionTime: Option[javax.xml.datatype.XMLGregorianCalendar] = None,
  confidentialityOverride: Option[nu.ndw.ConfidentialityValueEnum] = None,
  probabilityOfOccurrence: nu.ndw.ProbabilityOfOccurrenceEnum,
  severity: Option[nu.ndw.SeverityEnum] = None,
  source: Option[nu.ndw.Source] = None,
  validity: nu.ndw.Validity,
  impact: Option[nu.ndw.Impact] = None,
  cause: Option[nu.ndw.Cause] = None,
  generalPublicComment: Seq[nu.ndw.Comment] = Nil,
  nonGeneralPublicComment: Seq[nu.ndw.Comment] = Nil,
  urlLink: Seq[nu.ndw.UrlLink] = Nil,
  groupOfLocations: nu.ndw.GroupOfLocations,
  management: Option[nu.ndw.Management] = None,
  situationRecordExtension: Option[nu.ndw._SituationRecordExtensionType] = None,
  nonRoadEventInformationExtension: Option[nu.ndw._ExtensionType] = None,
  journeyDestination: Option[nu.ndw.MultilingualString] = None,
  journeyOrigin: Option[nu.ndw.MultilingualString] = None,
  journeyReference: Option[String] = None,
  transitServiceInformation: nu.ndw.TransitServiceInformationEnum,
  transitServiceType: nu.ndw.TransitServiceTypeEnum,
  scheduledDepartureTime: Option[javax.xml.datatype.XMLGregorianCalendar] = None,
  transitInformationExtension: Option[nu.ndw._ExtensionType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) extends NonRoadEventInformation {
  @JsonIgnore lazy val id = attributes("@id").as[String]
  @JsonIgnore lazy val version = attributes("@version").as[String]
}

      

sealed trait TransitServiceInformationEnum

object TransitServiceInformationEnum {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[nu.ndw.TransitServiceInformationEnum]): TransitServiceInformationEnum = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: TransitServiceInformationEnum) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
}

case object Cancellations extends TransitServiceInformationEnum { override def toString = "cancellations" }
case object DelayDueToBadWeather extends TransitServiceInformationEnum { override def toString = "delayDueToBadWeather" }
case object DelayDueToRepairs extends TransitServiceInformationEnum { override def toString = "delayDueToRepairs" }
case object DelayedUntilFurtherNotice extends TransitServiceInformationEnum { override def toString = "delayedUntilFurtherNotice" }
case object DelaysDueToFlotsam extends TransitServiceInformationEnum { override def toString = "delaysDueToFlotsam" }
case object DepartureOnSchedule extends TransitServiceInformationEnum { override def toString = "departureOnSchedule" }
case object FerryReplacedByIceRoad extends TransitServiceInformationEnum { override def toString = "ferryReplacedByIceRoad" }
case object FreeShuttleServiceOperating extends TransitServiceInformationEnum { override def toString = "freeShuttleServiceOperating" }
case object InformationServiceNotAvailable extends TransitServiceInformationEnum { override def toString = "informationServiceNotAvailable" }
case object IrregularServiceDelays extends TransitServiceInformationEnum { override def toString = "irregularServiceDelays" }
case object LoadCapacityChanged extends TransitServiceInformationEnum { override def toString = "loadCapacityChanged" }
case object RestrictionsForLongerVehicles extends TransitServiceInformationEnum { override def toString = "restrictionsForLongerVehicles" }
case object ServiceDelays extends TransitServiceInformationEnum { override def toString = "serviceDelays" }
case object ServiceDelaysOfUncertainDuration extends TransitServiceInformationEnum { override def toString = "serviceDelaysOfUncertainDuration" }
case object ServiceFullyBooked extends TransitServiceInformationEnum { override def toString = "serviceFullyBooked" }
case object ServiceNotOperating extends TransitServiceInformationEnum { override def toString = "serviceNotOperating" }
case object ServiceNotOperatingSubstituteServiceAvailable extends TransitServiceInformationEnum { override def toString = "serviceNotOperatingSubstituteServiceAvailable" }
case object ServiceSuspended extends TransitServiceInformationEnum { override def toString = "serviceSuspended" }
case object ServiceWithdrawn extends TransitServiceInformationEnum { override def toString = "serviceWithdrawn" }
case object ShuttleServiceOperating extends TransitServiceInformationEnum { override def toString = "shuttleServiceOperating" }
case object TemporaryChangesToTimetables extends TransitServiceInformationEnum { override def toString = "temporaryChangesToTimetables" }
case object OtherValue9 extends TransitServiceInformationEnum { override def toString = "other" }

sealed trait TransitServiceTypeEnum

object TransitServiceTypeEnum {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[nu.ndw.TransitServiceTypeEnum]): TransitServiceTypeEnum = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: TransitServiceTypeEnum) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
}

case object Air extends TransitServiceTypeEnum { override def toString = "air" }
case object Bus extends TransitServiceTypeEnum { override def toString = "bus" }
case object Ferry extends TransitServiceTypeEnum { override def toString = "ferry" }
case object Hydrofoil extends TransitServiceTypeEnum { override def toString = "hydrofoil" }
case object Rail extends TransitServiceTypeEnum { override def toString = "rail" }
case object Tram extends TransitServiceTypeEnum { override def toString = "tram" }
case object UndergroundMetro extends TransitServiceTypeEnum { override def toString = "undergroundMetro" }



case class TravelTimeData(measurementOrCalculationPeriod: Option[Float] = None,
  measurementOrCalculationTime: Option[javax.xml.datatype.XMLGregorianCalendar] = None,
  pertinentLocation: Option[nu.ndw.GroupOfLocations] = None,
  basicDataExtension: Option[nu.ndw._ExtensionType] = None,
  travelTimeTrendType: Option[nu.ndw.TravelTimeTrendTypeEnum] = None,
  travelTimeType: Option[nu.ndw.TravelTimeTypeEnum] = None,
  vehicleType: Seq[nu.ndw.VehicleTypeEnum] = Nil,
  travelTime: Option[nu.ndw.DurationValue] = None,
  freeFlowTravelTime: Option[nu.ndw.DurationValue] = None,
  normallyExpectedTravelTime: Option[nu.ndw.DurationValue] = None,
  freeFlowSpeed: Option[nu.ndw.SpeedValue] = None,
  travelTimeDataExtension: Option[nu.ndw._ExtensionType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) extends BasicData {
  @JsonIgnore lazy val measurementOrCalculatedTimePrecision = attributes.get("@measurementOrCalculatedTimePrecision") map { _.as[TimePrecisionEnum]}
}

      

sealed trait TravelTimeTrendTypeEnum

object TravelTimeTrendTypeEnum {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[nu.ndw.TravelTimeTrendTypeEnum]): TravelTimeTrendTypeEnum = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: TravelTimeTrendTypeEnum) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
}

case object DecreasingValue extends TravelTimeTrendTypeEnum { override def toString = "decreasing" }
case object IncreasingValue extends TravelTimeTrendTypeEnum { override def toString = "increasing" }
case object StableValue extends TravelTimeTrendTypeEnum { override def toString = "stable" }

sealed trait TravelTimeTypeEnum

object TravelTimeTypeEnum {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[nu.ndw.TravelTimeTypeEnum]): TravelTimeTypeEnum = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: TravelTimeTypeEnum) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
}

case object Best extends TravelTimeTypeEnum { override def toString = "best" }
case object Estimated extends TravelTimeTypeEnum { override def toString = "estimated" }
case object Instantaneous extends TravelTimeTypeEnum { override def toString = "instantaneous" }
case object Reconstituted extends TravelTimeTypeEnum { override def toString = "reconstituted" }

sealed trait TruckParkingDynamicManagementEnum

object TruckParkingDynamicManagementEnum {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[nu.ndw.TruckParkingDynamicManagementEnum]): TruckParkingDynamicManagementEnum = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: TruckParkingDynamicManagementEnum) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
}

case object CompactParking extends TruckParkingDynamicManagementEnum { override def toString = "compactParking" }
case object QueueParking extends TruckParkingDynamicManagementEnum { override def toString = "queueParking" }
case object NoDynamicParkingManagement extends TruckParkingDynamicManagementEnum { override def toString = "noDynamicParkingManagement" }
case object OtherValue85 extends TruckParkingDynamicManagementEnum { override def toString = "other" }

sealed trait UpdateMethodEnum

object UpdateMethodEnum {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[nu.ndw.UpdateMethodEnum]): UpdateMethodEnum = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: UpdateMethodEnum) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
}

case object AllElementUpdate extends UpdateMethodEnum { override def toString = "allElementUpdate" }
case object SingleElementUpdate extends UpdateMethodEnum { override def toString = "singleElementUpdate" }
case object Snapshot extends UpdateMethodEnum { override def toString = "snapshot" }



case class UrbanParkingSite(parkingName: Option[nu.ndw.MultilingualString] = None,
  parkingAlias: Seq[nu.ndw.MultilingualString] = Nil,
  parkingDescription: Option[nu.ndw.MultilingualString] = None,
  parkingRecordVersionTime: javax.xml.datatype.XMLGregorianCalendar,
  parkingNumberOfSpaces: Option[Int] = None,
  parkingPrincipalNumberOfSpaces: Option[Int] = None,
  maximumParkingDuration: Option[Float] = None,
  photoUrl: Option[java.net.URI] = None,
  urlLinkAddress: Option[java.net.URI] = None,
  parkingOccupanyDetectionType: Seq[nu.ndw.OccupancyDetectionTypeEnum] = Nil,
  emergencyContact: Seq[nu.ndw.Contactable] = Nil,
  owner: Seq[nu.ndw.Contactable] = Nil,
  responisbleAuthority: Seq[nu.ndw.Contactable] = Nil,
  securityService: Seq[nu.ndw.Contactable] = Nil,
  operator: Seq[nu.ndw.Contactable] = Nil,
  servicePartner: Seq[nu.ndw.Contactable] = Nil,
  parkingVMS: Seq[nu.ndw.ParkingVMS] = Nil,
  parkingLocation: nu.ndw.GroupOfLocations,
  parkingRoute: Seq[nu.ndw.ParkingRoute] = Nil,
  parkingColour: Option[nu.ndw.RGBColour] = None,
  onlyAssignedParking: Option[nu.ndw.ParkingAssignment] = None,
  assignedParkingAmongOthers: Option[nu.ndw.ParkingAssignment] = None,
  prohibitedParking: Option[nu.ndw.ParkingAssignment] = None,
  tariffsAndPayment: Option[nu.ndw.TariffsAndPayment] = None,
  parkingEquipmentOrServiceFacility: Seq[nu.ndw._ParkingRecordEquipmentOrServiceFacilityIndexParkingEquipmentOrServiceFacility] = Nil,
  parkingSpace: Seq[nu.ndw._ParkingSpace] = Nil,
  groupOfParkingSpaces: Seq[nu.ndw._GroupOfParkingSpaces] = Nil,
  parkingThresholds: Option[nu.ndw.ParkingThresholds] = None,
  permitsAndProhibitions: Seq[nu.ndw.PermitsAndProhibitions] = Nil,
  emergencyAssemblyPoint: Option[nu.ndw.GroupOfLocations] = None,
  entireArea: Option[nu.ndw.Area] = None,
  parkingRecordDimension: Option[nu.ndw.Dimension] = None,
  parkingRecordExtension: Option[nu.ndw._ExtensionType] = None,
  parkingReservation: Option[nu.ndw.ReservationTypeEnum] = None,
  parkingLayout: Seq[nu.ndw.ParkingLayoutEnum] = Nil,
  highestFloor: Option[Int] = None,
  lowestFloor: Option[Int] = None,
  temporaryParking: Option[Boolean] = None,
  parkingSiteAddress: Seq[nu.ndw.Contactable] = Nil,
  reservationService: Seq[nu.ndw.Contactable] = Nil,
  parkingUsageScenario: Seq[nu.ndw._ParkingSiteScenarioIndexParkingUsageScenario] = Nil,
  openingTimes: Option[nu.ndw.OpeningTimes] = None,
  parkingAccess: Seq[nu.ndw.ParkingAccess] = Nil,
  parkingStandardsAndSecurity: Option[nu.ndw.ParkingStandardsAndSecurity] = None,
  parkingSiteExtension: Option[nu.ndw._ExtensionType] = None,
  urbanParkingSiteType: nu.ndw.UrbanParkingSiteTypeEnum,
  parkingZone: Option[nu.ndw.MultilingualString] = None,
  urbanParkingSiteExtension: Option[nu.ndw._ExtensionType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) extends ParkingSite {
  @JsonIgnore lazy val id = attributes("@id").as[String]
  @JsonIgnore lazy val version = attributes("@version").as[String]
}

      

sealed trait UrbanParkingSiteTypeEnum

object UrbanParkingSiteTypeEnum {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[nu.ndw.UrbanParkingSiteTypeEnum]): UrbanParkingSiteTypeEnum = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: UrbanParkingSiteTypeEnum) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
}

case object OnStreetParking extends UrbanParkingSiteTypeEnum { override def toString = "onStreetParking" }
case object OffStreetParking extends UrbanParkingSiteTypeEnum { override def toString = "offStreetParking" }
case object OtherValue8 extends UrbanParkingSiteTypeEnum { override def toString = "other" }

sealed trait UrgencyEnum

object UrgencyEnum {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[nu.ndw.UrgencyEnum]): UrgencyEnum = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: UrgencyEnum) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
}

case object ExtremelyUrgent extends UrgencyEnum { override def toString = "extremelyUrgent" }
case object Urgent extends UrgencyEnum { override def toString = "urgent" }
case object NormalUrgency extends UrgencyEnum { override def toString = "normalUrgency" }



case class UrlLink(urlLinkAddress: java.net.URI,
  urlLinkDescription: Option[nu.ndw.MultilingualString] = None,
  urlLinkType: Option[nu.ndw.UrlLinkTypeEnum] = None,
  urlLinkExtension: Option[nu.ndw._ExtensionType] = None)
      

sealed trait UrlLinkTypeEnum

object UrlLinkTypeEnum {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[nu.ndw.UrlLinkTypeEnum]): UrlLinkTypeEnum = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: UrlLinkTypeEnum) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
}

case object DocumentPdf extends UrlLinkTypeEnum { override def toString = "documentPdf" }
case object Html extends UrlLinkTypeEnum { override def toString = "html" }
case object Image extends UrlLinkTypeEnum { override def toString = "image" }
case object Rss extends UrlLinkTypeEnum { override def toString = "rss" }
case object VideoStream extends UrlLinkTypeEnum { override def toString = "videoStream" }
case object VoiceStream extends UrlLinkTypeEnum { override def toString = "voiceStream" }
case object OtherValue7 extends UrlLinkTypeEnum { override def toString = "other" }



case class UsedPaymentCard(paymentCard: nu.ndw.PaymentCardTypesEnum,
  otherPaymentCard: Option[String] = None,
  paymentCardBrand: Option[nu.ndw.PaymentCardBrandsEnum] = None,
  otherPaymentCardBrand: Option[String] = None,
  usedPaymentCardExtension: Option[nu.ndw._ExtensionType] = None)
      

sealed trait UserTypeEnum

object UserTypeEnum {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[nu.ndw.UserTypeEnum]): UserTypeEnum = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: UserTypeEnum) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
}

case object AllUsers extends UserTypeEnum { override def toString = "allUsers" }
case object Shoppers extends UserTypeEnum { override def toString = "shoppers" }
case object HotelGuests extends UserTypeEnum { override def toString = "hotelGuests" }
case object Subscribers extends UserTypeEnum { override def toString = "subscribers" }
case object ReservationHolders extends UserTypeEnum { override def toString = "reservationHolders" }
case object SeasonTicketHolders extends UserTypeEnum { override def toString = "seasonTicketHolders" }
case object RegisteredDisabledUsers extends UserTypeEnum { override def toString = "registeredDisabledUsers" }
case object Disabled extends UserTypeEnum { override def toString = "disabled" }
case object Handicapped extends UserTypeEnum { override def toString = "handicapped" }
case object HearingImpaired extends UserTypeEnum { override def toString = "hearingImpaired" }
case object VisuallyImpaired extends UserTypeEnum { override def toString = "visuallyImpaired" }
case object WheelchairUsers extends UserTypeEnum { override def toString = "wheelchairUsers" }
case object ElderlyUsers extends UserTypeEnum { override def toString = "elderlyUsers" }
case object Families extends UserTypeEnum { override def toString = "families" }
case object Men extends UserTypeEnum { override def toString = "men" }
case object Women extends UserTypeEnum { override def toString = "women" }
case object PregnantWomen extends UserTypeEnum { override def toString = "pregnantWomen" }
case object Pensioners extends UserTypeEnum { override def toString = "pensioners" }
case object Students extends UserTypeEnum { override def toString = "students" }
case object Staff extends UserTypeEnum { override def toString = "staff" }
case object Employees extends UserTypeEnum { override def toString = "employees" }
case object Customers extends UserTypeEnum { override def toString = "customers" }
case object Visitors extends UserTypeEnum { override def toString = "visitors" }
case object Members extends UserTypeEnum { override def toString = "members" }
case object ShortTermParker extends UserTypeEnum { override def toString = "shortTermParker" }
case object LongTermParker extends UserTypeEnum { override def toString = "longTermParker" }
case object OvernightParker extends UserTypeEnum { override def toString = "overnightParker" }
case object SportEventAwaySupporters extends UserTypeEnum { override def toString = "sportEventAwaySupporters" }
case object SportEventHomeSupporters extends UserTypeEnum { override def toString = "sportEventHomeSupporters" }
case object Residents extends UserTypeEnum { override def toString = "residents" }
case object Commuters extends UserTypeEnum { override def toString = "commuters" }
case object ParkAndRideUsers extends UserTypeEnum { override def toString = "parkAndRideUsers" }
case object ParkAndWalkUser extends UserTypeEnum { override def toString = "parkAndWalkUser" }
case object ParkAndCycleUser extends UserTypeEnum { override def toString = "parkAndCycleUser" }
case object OtherValue6 extends UserTypeEnum { override def toString = "other" }
case object UnknownValue2 extends UserTypeEnum { override def toString = "unknown" }



case class Validity(validityStatus: nu.ndw.ValidityStatusEnum,
  overrunning: Option[Boolean] = None,
  validityTimeSpecification: nu.ndw.OverallPeriod,
  validityExtension: Option[nu.ndw._ExtensionType] = None)
      

sealed trait ValidityStatusEnum

object ValidityStatusEnum {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[nu.ndw.ValidityStatusEnum]): ValidityStatusEnum = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: ValidityStatusEnum) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
}

case object Active extends ValidityStatusEnum { override def toString = "active" }
case object Suspended extends ValidityStatusEnum { override def toString = "suspended" }
case object DefinedByValidityTimeSpec extends ValidityStatusEnum { override def toString = "definedByValidityTimeSpec" }



case class Vehicle(vehicleColour: Option[nu.ndw.MultilingualString] = None,
  vehicleCountryOfOrigin: Option[nu.ndw.MultilingualString] = None,
  vehicleIdentifier: Option[String] = None,
  vehicleManufacturer: Option[String] = None,
  vehicleModel: Option[String] = None,
  vehicleRegistrationPlateIdentifier: Option[String] = None,
  vehicleStatus: Option[nu.ndw.VehicleStatusEnum] = None,
  vehicleCharacteristics: Option[nu.ndw.VehicleCharacteristics] = None,
  axleSpacingOnVehicle: Seq[nu.ndw.AxleSpacing] = Nil,
  specificAxleWeight: Seq[nu.ndw.AxleWeight] = Nil,
  hazardousGoodsAssociatedWithVehicle: Option[nu.ndw.HazardousMaterialsType] = None,
  vehicleExtension: Option[nu.ndw._ExtensionType] = None)
      



case class VehicleCharacteristics(fuelType: Option[nu.ndw.FuelTypeEnum] = None,
  loadType: Option[nu.ndw.LoadTypeEnum] = None,
  vehicleEquipment: Option[nu.ndw.VehicleEquipmentEnum] = None,
  vehicleType: Seq[nu.ndw.VehicleTypeEnum] = Nil,
  vehicleUsage: Option[nu.ndw.VehicleUsageEnum] = None,
  grossWeightCharacteristic: Seq[nu.ndw.GrossWeightCharacteristic] = Nil,
  heightCharacteristic: Seq[nu.ndw.HeightCharacteristic] = Nil,
  lengthCharacteristic: Seq[nu.ndw.LengthCharacteristic] = Nil,
  widthCharacteristic: Seq[nu.ndw.WidthCharacteristic] = Nil,
  heaviestAxleWeightCharacteristic: Seq[nu.ndw.HeaviestAxleWeightCharacteristic] = Nil,
  numberOfAxlesCharacteristic: Seq[nu.ndw.NumberOfAxlesCharacteristic] = Nil,
  vehicleCharacteristicsExtension: Option[nu.ndw._VehicleCharacteristicsExtensionType] = None)
      



case class VehicleCharacteristicsExtended(emissionClassification: Seq[String] = Nil,
  operationFreeOfEmission: Option[Boolean] = None,
  loadType2: Option[nu.ndw.LoadType2Enum] = None,
  vehicleType2: Option[nu.ndw.VehicleType2Enum] = None,
  fuelType2: Option[nu.ndw.FuelType2Enum] = None,
  vehicleUsage2: Option[nu.ndw.VehicleUsage2Enum] = None)
      



case class VehicleCountAndRate(measurementSiteReference: Option[nu.ndw._MeasurementSiteRecordVersionedReference] = None,
  measuredValueIndex: Option[Int] = None,
  dedicatedAccess: Option[nu.ndw._ParkingAccessReference] = None,
  measurementTimeDefault: Option[javax.xml.datatype.XMLGregorianCalendar] = None,
  lastCalibration: Option[javax.xml.datatype.XMLGregorianCalendar] = None,
  coveringPetrolStationArea: Option[Boolean] = None,
  vehicleCountWithinInterval: Seq[nu.ndw.VehicleCountWithinInterval] = Nil,
  vehicleRate: Seq[nu.ndw.VehicleRate] = Nil,
  vehicleCountAndRateExtension: Option[nu.ndw._ExtensionType] = None)
      



case class VehicleCountValue(dataError: Option[Boolean] = None,
  reasonForDataError: Option[nu.ndw.MultilingualString] = None,
  dataValueExtension: Option[nu.ndw._ExtensionType] = None,
  vehicleCount: Int,
  vehicleCountValueExtension: Option[nu.ndw._ExtensionType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) extends DataValue {
  @JsonIgnore lazy val accuracy = attributes.get("@accuracy") map { _.as[Float]}
  @JsonIgnore lazy val computationalMethod = attributes.get("@computationalMethod") map { _.as[ComputationMethodEnum]}
  @JsonIgnore lazy val numberOfIncompleteInputs = attributes.get("@numberOfIncompleteInputs") map { _.as[Int]}
  @JsonIgnore lazy val numberOfInputValuesUsed = attributes.get("@numberOfInputValuesUsed") map { _.as[Int]}
  @JsonIgnore lazy val smoothingFactor = attributes.get("@smoothingFactor") map { _.as[Float]}
  @JsonIgnore lazy val standardDeviation = attributes.get("@standardDeviation") map { _.as[Float]}
  @JsonIgnore lazy val supplierCalculatedDataQuality = attributes.get("@supplierCalculatedDataQuality") map { _.as[Float]}
}

      



case class VehicleCountWithinInterval(measurementOrCalcualtionTime: Option[javax.xml.datatype.XMLGregorianCalendar] = None,
  measurementInterval: Float,
  numberOfIncomingVehicles: Option[nu.ndw.VehicleCountValue] = None,
  numberOfOutgoingVehicles: Option[nu.ndw.VehicleCountValue] = None,
  changeOfOccupiedSpaces: Option[nu.ndw.OccupancyChangeValue] = None,
  countedVehicles: Option[nu.ndw.VehicleCharacteristics] = None,
  vehicleCountWithinIntervalExtension: Option[nu.ndw._ExtensionType] = None)
      

sealed trait VehicleEquipmentEnum

object VehicleEquipmentEnum {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[nu.ndw.VehicleEquipmentEnum]): VehicleEquipmentEnum = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: VehicleEquipmentEnum) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
}

case object NotUsingSnowChains extends VehicleEquipmentEnum { override def toString = "notUsingSnowChains" }
case object NotUsingSnowChainsOrTyres extends VehicleEquipmentEnum { override def toString = "notUsingSnowChainsOrTyres" }
case object SnowChainsInUse extends VehicleEquipmentEnum { override def toString = "snowChainsInUse" }
case object SnowTyresInUse extends VehicleEquipmentEnum { override def toString = "snowTyresInUse" }
case object SnowChainsOrTyresInUse extends VehicleEquipmentEnum { override def toString = "snowChainsOrTyresInUse" }
case object WithoutSnowTyresOrChainsOnBoard extends VehicleEquipmentEnum { override def toString = "withoutSnowTyresOrChainsOnBoard" }



case class VehicleFlowValue(dataError: Option[Boolean] = None,
  reasonForDataError: Option[nu.ndw.MultilingualString] = None,
  dataValueExtension: Option[nu.ndw._ExtensionType] = None,
  vehicleFlowRate: Int,
  vehicleFlowValueExtension: Option[nu.ndw._ExtensionType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) extends DataValue {
  @JsonIgnore lazy val accuracy = attributes.get("@accuracy") map { _.as[Float]}
  @JsonIgnore lazy val computationalMethod = attributes.get("@computationalMethod") map { _.as[ComputationMethodEnum]}
  @JsonIgnore lazy val numberOfIncompleteInputs = attributes.get("@numberOfIncompleteInputs") map { _.as[Int]}
  @JsonIgnore lazy val numberOfInputValuesUsed = attributes.get("@numberOfInputValuesUsed") map { _.as[Int]}
  @JsonIgnore lazy val smoothingFactor = attributes.get("@smoothingFactor") map { _.as[Float]}
  @JsonIgnore lazy val standardDeviation = attributes.get("@standardDeviation") map { _.as[Float]}
  @JsonIgnore lazy val supplierCalculatedDataQuality = attributes.get("@supplierCalculatedDataQuality") map { _.as[Float]}
}

      



case class VehicleObstruction(situationRecordCreationReference: Option[String] = None,
  situationRecordCreationTime: javax.xml.datatype.XMLGregorianCalendar,
  situationRecordObservationTime: Option[javax.xml.datatype.XMLGregorianCalendar] = None,
  situationRecordVersionTime: javax.xml.datatype.XMLGregorianCalendar,
  situationRecordFirstSupplierVersionTime: Option[javax.xml.datatype.XMLGregorianCalendar] = None,
  confidentialityOverride: Option[nu.ndw.ConfidentialityValueEnum] = None,
  probabilityOfOccurrence: nu.ndw.ProbabilityOfOccurrenceEnum,
  severity: Option[nu.ndw.SeverityEnum] = None,
  source: Option[nu.ndw.Source] = None,
  validity: nu.ndw.Validity,
  impact: Option[nu.ndw.Impact] = None,
  cause: Option[nu.ndw.Cause] = None,
  generalPublicComment: Seq[nu.ndw.Comment] = Nil,
  nonGeneralPublicComment: Seq[nu.ndw.Comment] = Nil,
  urlLink: Seq[nu.ndw.UrlLink] = Nil,
  groupOfLocations: nu.ndw.GroupOfLocations,
  management: Option[nu.ndw.Management] = None,
  situationRecordExtension: Option[nu.ndw._SituationRecordExtensionType] = None,
  trafficElementExtension: Option[nu.ndw._ExtensionType] = None,
  numberOfObstructions: Option[Int] = None,
  mobilityOfObstruction: Option[nu.ndw.Mobility] = None,
  obstructionExtension: Option[nu.ndw._ExtensionType] = None,
  vehicleObstructionType: nu.ndw.VehicleObstructionTypeEnum,
  obstructingVehicle: Seq[nu.ndw.Vehicle] = Nil,
  vehicleObstructionExtension: Option[nu.ndw._ExtensionType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) extends ObstructionType {
  @JsonIgnore lazy val id = attributes("@id").as[String]
  @JsonIgnore lazy val version = attributes("@version").as[String]
}

      

sealed trait VehicleObstructionTypeEnum

object VehicleObstructionTypeEnum {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[nu.ndw.VehicleObstructionTypeEnum]): VehicleObstructionTypeEnum = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: VehicleObstructionTypeEnum) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
}

case object AbandonedVehicle extends VehicleObstructionTypeEnum { override def toString = "abandonedVehicle" }
case object AbnormalLoad extends VehicleObstructionTypeEnum { override def toString = "abnormalLoad" }
case object BrokenDownBus extends VehicleObstructionTypeEnum { override def toString = "brokenDownBus" }
case object BrokenDownHeavyLorry extends VehicleObstructionTypeEnum { override def toString = "brokenDownHeavyLorry" }
case object BrokenDownVehicle extends VehicleObstructionTypeEnum { override def toString = "brokenDownVehicle" }
case object Convoy extends VehicleObstructionTypeEnum { override def toString = "convoy" }
case object DamagedVehicle extends VehicleObstructionTypeEnum { override def toString = "damagedVehicle" }
case object DangerousSlowMovingVehicle extends VehicleObstructionTypeEnum { override def toString = "dangerousSlowMovingVehicle" }
case object EmergencyVehicle extends VehicleObstructionTypeEnum { override def toString = "emergencyVehicle" }
case object HighSpeedEmergencyVehicle extends VehicleObstructionTypeEnum { override def toString = "highSpeedEmergencyVehicle" }
case object LongLoad extends VehicleObstructionTypeEnum { override def toString = "longLoad" }
case object MilitaryConvoy extends VehicleObstructionTypeEnum { override def toString = "militaryConvoy" }
case object OverheightVehicle extends VehicleObstructionTypeEnum { override def toString = "overheightVehicle" }
case object ProhibitedVehicleOnTheRoadway extends VehicleObstructionTypeEnum { override def toString = "prohibitedVehicleOnTheRoadway" }
case object SaltingOrGrittingVehicleInUse extends VehicleObstructionTypeEnum { override def toString = "saltingOrGrittingVehicleInUse" }
case object SlowMovingMaintenanceVehicle extends VehicleObstructionTypeEnum { override def toString = "slowMovingMaintenanceVehicle" }
case object SlowVehicle extends VehicleObstructionTypeEnum { override def toString = "slowVehicle" }
case object Snowplough extends VehicleObstructionTypeEnum { override def toString = "snowplough" }
case object TrackLayingVehicle extends VehicleObstructionTypeEnum { override def toString = "trackLayingVehicle" }
case object UnlitVehicleOnTheRoad extends VehicleObstructionTypeEnum { override def toString = "unlitVehicleOnTheRoad" }
case object VehicleOnFire extends VehicleObstructionTypeEnum { override def toString = "vehicleOnFire" }
case object VehicleCarryingHazardousMaterials extends VehicleObstructionTypeEnum { override def toString = "vehicleCarryingHazardousMaterials" }
case object VehicleInDifficulty extends VehicleObstructionTypeEnum { override def toString = "vehicleInDifficulty" }
case object VehicleOnWrongCarriageway extends VehicleObstructionTypeEnum { override def toString = "vehicleOnWrongCarriageway" }
case object VehicleStuck extends VehicleObstructionTypeEnum { override def toString = "vehicleStuck" }
case object VehicleStuckUnderBridge extends VehicleObstructionTypeEnum { override def toString = "vehicleStuckUnderBridge" }
case object VehicleWithOverheightLoad extends VehicleObstructionTypeEnum { override def toString = "vehicleWithOverheightLoad" }
case object VehicleWithOverwideLoad extends VehicleObstructionTypeEnum { override def toString = "vehicleWithOverwideLoad" }
case object OtherValue5 extends VehicleObstructionTypeEnum { override def toString = "other" }



case class VehicleRate(measurementOrCalculationTime: Option[javax.xml.datatype.XMLGregorianCalendar] = None,
  fillRate: Option[nu.ndw.VehicleFlowValue] = None,
  exitRate: Option[nu.ndw.VehicleFlowValue] = None,
  vehicleFlowRate: Option[nu.ndw.VehicleFlowValue] = None,
  measuredVehicles: Option[nu.ndw.VehicleCharacteristics] = None,
  vehicleRateExtension: Option[nu.ndw._ExtensionType] = None)
      

sealed trait VehicleStatusEnum

object VehicleStatusEnum {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[nu.ndw.VehicleStatusEnum]): VehicleStatusEnum = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: VehicleStatusEnum) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
}

case object Abandoned extends VehicleStatusEnum { override def toString = "abandoned" }
case object BrokenDown extends VehicleStatusEnum { override def toString = "brokenDown" }
case object BurntOut extends VehicleStatusEnum { override def toString = "burntOut" }
case object Damaged extends VehicleStatusEnum { override def toString = "damaged" }
case object DamagedAndImmobilized extends VehicleStatusEnum { override def toString = "damagedAndImmobilized" }
case object OnFire extends VehicleStatusEnum { override def toString = "onFire" }

sealed trait VehicleType2Enum

object VehicleType2Enum {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[nu.ndw.VehicleType2Enum]): VehicleType2Enum = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: VehicleType2Enum) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
}

case object Motorhome extends VehicleType2Enum { override def toString = "motorhome" }
case object LightGoodsVehicle extends VehicleType2Enum { override def toString = "lightGoodsVehicle" }
case object HeavyGoodsVehicle extends VehicleType2Enum { override def toString = "heavyGoodsVehicle" }
case object Minibus extends VehicleType2Enum { override def toString = "minibus" }
case object SmallCar extends VehicleType2Enum { override def toString = "smallCar" }
case object LargeCar extends VehicleType2Enum { override def toString = "largeCar" }
case object LightGoodsVehicleWithTrailer extends VehicleType2Enum { override def toString = "lightGoodsVehicleWithTrailer" }
case object HeavyGoodsVehicleWithTrailer extends VehicleType2Enum { override def toString = "heavyGoodsVehicleWithTrailer" }
case object HeavyHaulageVehicle extends VehicleType2Enum { override def toString = "heavyHaulageVehicle" }
case object PassengerCar extends VehicleType2Enum { override def toString = "passengerCar" }
case object UnknownValue extends VehicleType2Enum { override def toString = "unknown" }

sealed trait VehicleTypeEnum

object VehicleTypeEnum {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[nu.ndw.VehicleTypeEnum]): VehicleTypeEnum = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: VehicleTypeEnum) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
}

case object AgriculturalVehicle extends VehicleTypeEnum { override def toString = "agriculturalVehicle" }
case object AnyVehicle extends VehicleTypeEnum { override def toString = "anyVehicle" }
case object ArticulatedVehicle extends VehicleTypeEnum { override def toString = "articulatedVehicle" }
case object BicycleValue extends VehicleTypeEnum { override def toString = "bicycle" }
case object BusValue extends VehicleTypeEnum { override def toString = "bus" }
case object Car extends VehicleTypeEnum { override def toString = "car" }
case object Caravan extends VehicleTypeEnum { override def toString = "caravan" }
case object CarOrLightVehicle extends VehicleTypeEnum { override def toString = "carOrLightVehicle" }
case object CarWithCaravan extends VehicleTypeEnum { override def toString = "carWithCaravan" }
case object CarWithTrailer extends VehicleTypeEnum { override def toString = "carWithTrailer" }
case object ConstructionOrMaintenanceVehicle extends VehicleTypeEnum { override def toString = "constructionOrMaintenanceVehicle" }
case object FourWheelDrive extends VehicleTypeEnum { override def toString = "fourWheelDrive" }
case object HighSidedVehicle extends VehicleTypeEnum { override def toString = "highSidedVehicle" }
case object LorryValue extends VehicleTypeEnum { override def toString = "lorry" }
case object Moped extends VehicleTypeEnum { override def toString = "moped" }
case object Motorcycle extends VehicleTypeEnum { override def toString = "motorcycle" }
case object MotorcycleWithSideCar extends VehicleTypeEnum { override def toString = "motorcycleWithSideCar" }
case object Motorscooter extends VehicleTypeEnum { override def toString = "motorscooter" }
case object Tanker extends VehicleTypeEnum { override def toString = "tanker" }
case object ThreeWheeledVehicle extends VehicleTypeEnum { override def toString = "threeWheeledVehicle" }
case object Trailer extends VehicleTypeEnum { override def toString = "trailer" }
case object TramValue extends VehicleTypeEnum { override def toString = "tram" }
case object TwoWheeledVehicle extends VehicleTypeEnum { override def toString = "twoWheeledVehicle" }
case object Van extends VehicleTypeEnum { override def toString = "van" }
case object VehicleWithCatalyticConverter extends VehicleTypeEnum { override def toString = "vehicleWithCatalyticConverter" }
case object VehicleWithoutCatalyticConverter extends VehicleTypeEnum { override def toString = "vehicleWithoutCatalyticConverter" }
case object VehicleWithCaravan extends VehicleTypeEnum { override def toString = "vehicleWithCaravan" }
case object VehicleWithTrailer extends VehicleTypeEnum { override def toString = "vehicleWithTrailer" }
case object WithEvenNumberedRegistrationPlates extends VehicleTypeEnum { override def toString = "withEvenNumberedRegistrationPlates" }
case object WithOddNumberedRegistrationPlates extends VehicleTypeEnum { override def toString = "withOddNumberedRegistrationPlates" }
case object OtherValue86 extends VehicleTypeEnum { override def toString = "other" }

sealed trait VehicleUsage2Enum

object VehicleUsage2Enum {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[nu.ndw.VehicleUsage2Enum]): VehicleUsage2Enum = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: VehicleUsage2Enum) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
}

case object CityLogistics extends VehicleUsage2Enum { override def toString = "cityLogistics" }
case object CarSharing extends VehicleUsage2Enum { override def toString = "carSharing" }

sealed trait VehicleUsageEnum

object VehicleUsageEnum {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[nu.ndw.VehicleUsageEnum]): VehicleUsageEnum = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: VehicleUsageEnum) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
}

case object Agricultural extends VehicleUsageEnum { override def toString = "agricultural" }
case object Commercial extends VehicleUsageEnum { override def toString = "commercial" }
case object EmergencyServicesValue extends VehicleUsageEnum { override def toString = "emergencyServices" }
case object Military extends VehicleUsageEnum { override def toString = "military" }
case object NonCommercial extends VehicleUsageEnum { override def toString = "nonCommercial" }
case object PatrolValue extends VehicleUsageEnum { override def toString = "patrol" }
case object RecoveryServices extends VehicleUsageEnum { override def toString = "recoveryServices" }
case object RoadMaintenanceOrConstruction extends VehicleUsageEnum { override def toString = "roadMaintenanceOrConstruction" }
case object RoadOperator extends VehicleUsageEnum { override def toString = "roadOperator" }
case object Taxi extends VehicleUsageEnum { override def toString = "taxi" }


sealed trait VersionedReferencable {
  def id: String
  def version: String
}



case class VersionedReference(attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) extends VersionedReferencable {
  @JsonIgnore lazy val id = attributes("@id").as[String]
  @JsonIgnore lazy val version = attributes("@version").as[String]
}

      



case class Visibility(minimumVisibilityDistance: nu.ndw.IntegerMetreDistanceValue,
  visibilityExtension: Option[nu.ndw._ExtensionType] = None)
      



case class VisibilityInformation(measurementOrCalculationPeriod: Option[Float] = None,
  measurementOrCalculationTime: Option[javax.xml.datatype.XMLGregorianCalendar] = None,
  pertinentLocation: Option[nu.ndw.GroupOfLocations] = None,
  basicDataExtension: Option[nu.ndw._ExtensionType] = None,
  weatherDataExtension: Option[nu.ndw._ExtensionType] = None,
  visibility: nu.ndw.Visibility,
  visibilityInformationExtension: Option[nu.ndw._ExtensionType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) extends WeatherData {
  @JsonIgnore lazy val measurementOrCalculatedTimePrecision = attributes.get("@measurementOrCalculatedTimePrecision") map { _.as[TimePrecisionEnum]}
}

      



case class Vms(vmsWorking: Boolean,
  vmsMessageSequencingInterval: Option[Float] = None,
  vmsMessage: Seq[nu.ndw._VmsMessageIndexVmsMessage] = Nil,
  textDisplayAreaSettings: Option[nu.ndw.TextDisplayAreaSettings] = None,
  pictogramDisplayAreaSettings: Seq[nu.ndw._VmsPictogramDisplayAreaIndexPictogramDisplayAreaSettings] = Nil,
  vmsLocationOverride: Option[nu.ndw.Location] = None,
  managedLogicalLocationOverride: Option[nu.ndw.VmsManagedLogicalLocation] = None,
  vmsDynamicCharacteristics: Option[nu.ndw.VmsDynamicCharacteristics] = None,
  vmsFault: Seq[nu.ndw.VmsFault] = Nil,
  vmsExtension: Option[nu.ndw._ExtensionType] = None)
      

sealed trait VmsDatexPictogramEnum

object VmsDatexPictogramEnum {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[nu.ndw.VmsDatexPictogramEnum]): VmsDatexPictogramEnum = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: VmsDatexPictogramEnum) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
}

case object Accident extends VmsDatexPictogramEnum { override def toString = "accident" }
case object AdvisorySpeed extends VmsDatexPictogramEnum { override def toString = "advisorySpeed" }
case object AnimalsOnRoad extends VmsDatexPictogramEnum { override def toString = "animalsOnRoad" }
case object BlankVoid extends VmsDatexPictogramEnum { override def toString = "blankVoid" }
case object BridgeClosed extends VmsDatexPictogramEnum { override def toString = "bridgeClosed" }
case object BridgeSwingInOperation extends VmsDatexPictogramEnum { override def toString = "bridgeSwingInOperation" }
case object CarParkFull extends VmsDatexPictogramEnum { override def toString = "carParkFull" }
case object CarParkSpacesAvailable extends VmsDatexPictogramEnum { override def toString = "carParkSpacesAvailable" }
case object CarriagewayNarrows extends VmsDatexPictogramEnum { override def toString = "carriagewayNarrows" }
case object CarriagewayNarrowsOnTheLeft extends VmsDatexPictogramEnum { override def toString = "carriagewayNarrowsOnTheLeft" }
case object CarriagewayNarrowsOnTheRight extends VmsDatexPictogramEnum { override def toString = "carriagewayNarrowsOnTheRight" }
case object CarriagewayReducedToOneLane extends VmsDatexPictogramEnum { override def toString = "carriagewayReducedToOneLane" }
case object CarriagewayReducedToTwoLanes extends VmsDatexPictogramEnum { override def toString = "carriagewayReducedToTwoLanes" }
case object CarriagewayReducedToThreeLanes extends VmsDatexPictogramEnum { override def toString = "carriagewayReducedToThreeLanes" }
case object ChainsOrSnowTyresRecommended extends VmsDatexPictogramEnum { override def toString = "chainsOrSnowTyresRecommended" }
case object CompulsoryMinimumSpeed extends VmsDatexPictogramEnum { override def toString = "compulsoryMinimumSpeed" }
case object CrossWind extends VmsDatexPictogramEnum { override def toString = "crossWind" }
case object DangerOfFire extends VmsDatexPictogramEnum { override def toString = "dangerOfFire" }
case object DrivingOfVehiclesLessThanXMetresApartProhibited extends VmsDatexPictogramEnum { override def toString = "drivingOfVehiclesLessThanXMetresApartProhibited" }
case object EndOfAdvisorySpeed extends VmsDatexPictogramEnum { override def toString = "endOfAdvisorySpeed" }
case object EndOfCompulsoryMinimumSpeed extends VmsDatexPictogramEnum { override def toString = "endOfCompulsoryMinimumSpeed" }
case object EndOfProhibitionOfOvertaking extends VmsDatexPictogramEnum { override def toString = "endOfProhibitionOfOvertaking" }
case object EndOfProhibitionOfOvertakingForGoodsVehicles extends VmsDatexPictogramEnum { override def toString = "endOfProhibitionOfOvertakingForGoodsVehicles" }
case object EndOfSpeedLimit extends VmsDatexPictogramEnum { override def toString = "endOfSpeedLimit" }
case object ExitClosed extends VmsDatexPictogramEnum { override def toString = "exitClosed" }
case object FallingRocks extends VmsDatexPictogramEnum { override def toString = "fallingRocks" }
case object FastenChildrensSeatBelts extends VmsDatexPictogramEnum { override def toString = "fastenChildrensSeatBelts" }
case object FastenYourSeatBelt extends VmsDatexPictogramEnum { override def toString = "fastenYourSeatBelt" }
case object Fire extends VmsDatexPictogramEnum { override def toString = "fire" }
case object FloodingOrFlashFloods extends VmsDatexPictogramEnum { override def toString = "floodingOrFlashFloods" }
case object Fog extends VmsDatexPictogramEnum { override def toString = "fog" }
case object FootballMatch extends VmsDatexPictogramEnum { override def toString = "footballMatch" }
case object HardShoulderNotRunning extends VmsDatexPictogramEnum { override def toString = "hardShoulderNotRunning" }
case object HardShoulderRunning extends VmsDatexPictogramEnum { override def toString = "hardShoulderRunning" }
case object KeepASafeDistance extends VmsDatexPictogramEnum { override def toString = "keepASafeDistance" }
case object KeepLeft extends VmsDatexPictogramEnum { override def toString = "keepLeft" }
case object KeepRight extends VmsDatexPictogramEnum { override def toString = "keepRight" }
case object Lane1ClosedOf2 extends VmsDatexPictogramEnum { override def toString = "lane1ClosedOf2" }
case object Lane2ClosedOf2 extends VmsDatexPictogramEnum { override def toString = "lane2ClosedOf2" }
case object Lane1ClosedOf3 extends VmsDatexPictogramEnum { override def toString = "lane1ClosedOf3" }
case object Lane3ClosedOf3 extends VmsDatexPictogramEnum { override def toString = "lane3ClosedOf3" }
case object Lanes1And2ClosedOf3 extends VmsDatexPictogramEnum { override def toString = "lanes1And2ClosedOf3" }
case object Lanes2And3ClosedOf3 extends VmsDatexPictogramEnum { override def toString = "lanes2And3ClosedOf3" }
case object Lane1ClosedOf4 extends VmsDatexPictogramEnum { override def toString = "lane1ClosedOf4" }
case object Lane4ClosedOf4 extends VmsDatexPictogramEnum { override def toString = "lane4ClosedOf4" }
case object Lanes1And2ClosedOf4 extends VmsDatexPictogramEnum { override def toString = "lanes1And2ClosedOf4" }
case object Lanes3And4ClosedOf4 extends VmsDatexPictogramEnum { override def toString = "lanes3And4ClosedOf4" }
case object Lanes1And2And3ClosedOf4 extends VmsDatexPictogramEnum { override def toString = "lanes1And2And3ClosedOf4" }
case object Lanes2And3And4ClosedOf4 extends VmsDatexPictogramEnum { override def toString = "lanes2And3And4ClosedOf4" }
case object LaneClosed extends VmsDatexPictogramEnum { override def toString = "laneClosed" }
case object LaneDeviationToLeft extends VmsDatexPictogramEnum { override def toString = "laneDeviationToLeft" }
case object LaneDeviationToRight extends VmsDatexPictogramEnum { override def toString = "laneDeviationToRight" }
case object LaneOpen extends VmsDatexPictogramEnum { override def toString = "laneOpen" }
case object LeftHandLaneClosed extends VmsDatexPictogramEnum { override def toString = "leftHandLaneClosed" }
case object LightSignals extends VmsDatexPictogramEnum { override def toString = "lightSignals" }
case object LooseGravel extends VmsDatexPictogramEnum { override def toString = "looseGravel" }
case object MaintenanceVehicleInAction extends VmsDatexPictogramEnum { override def toString = "maintenanceVehicleInAction" }
case object MaximumSpeedLimitedToTheFigureIndicated extends VmsDatexPictogramEnum { override def toString = "maximumSpeedLimitedToTheFigureIndicated" }
case object NarrowLanesAead extends VmsDatexPictogramEnum { override def toString = "narrowLanesAead" }
case object NoEntry extends VmsDatexPictogramEnum { override def toString = "noEntry" }
case object NoEntryForAnyPowerDrivenVehicleDrawingATrailer extends VmsDatexPictogramEnum { override def toString = "noEntryForAnyPowerDrivenVehicleDrawingATrailer" }
case object LongName extends VmsDatexPictogramEnum { override def toString = "noEntryForAnyPowerDrivenVehicleDrawingATrailerOtherThanASemiTrailerOrASingleAxleTrailer" }
case object NoEntryForGoodsVehicles extends VmsDatexPictogramEnum { override def toString = "noEntryForGoodsVehicles" }
case object NoEntryForVehiclesExceedingXTonnesLadenMass extends VmsDatexPictogramEnum { override def toString = "noEntryForVehiclesExceedingXTonnesLadenMass" }
case object LongNameValue extends VmsDatexPictogramEnum { override def toString = "noEntryForVehiclesHavingAMassExceedingXTonnesOnOneAxle" }
case object LongNameValue2 extends VmsDatexPictogramEnum { override def toString = "noEntryForVehiclesHavingAnOverallHeightExceedingXMetres" }
case object LongNameValue3 extends VmsDatexPictogramEnum { override def toString = "noEntryForVehiclesHavingAnOverallLengthExceedingXMetres" }
case object LongNameValue4 extends VmsDatexPictogramEnum { override def toString = "noEntryForVehiclesHavingAnOverallWidthExceedingXMetres" }
case object NoEntryForVehiclesCarryingDangerousGoods extends VmsDatexPictogramEnum { override def toString = "noEntryForVehiclesCarryingDangerousGoods" }
case object OtherDangers extends VmsDatexPictogramEnum { override def toString = "otherDangers" }
case object OvertakingByGoodsVehiclesProhibited extends VmsDatexPictogramEnum { override def toString = "overtakingByGoodsVehiclesProhibited" }
case object OvertakingProhibited extends VmsDatexPictogramEnum { override def toString = "overtakingProhibited" }
case object PollutionOrSmogAlert extends VmsDatexPictogramEnum { override def toString = "pollutionOrSmogAlert" }
case object QueueType extends VmsDatexPictogramEnum { override def toString = "queue" }
case object Rain extends VmsDatexPictogramEnum { override def toString = "rain" }
case object RightHandLaneClosed extends VmsDatexPictogramEnum { override def toString = "rightHandLaneClosed" }
case object RoadClosedAhead extends VmsDatexPictogramEnum { override def toString = "roadClosedAhead" }
case object Roadworks extends VmsDatexPictogramEnum { override def toString = "roadworks" }
case object SlipperyRoadValue extends VmsDatexPictogramEnum { override def toString = "slipperyRoad" }
case object Smoke extends VmsDatexPictogramEnum { override def toString = "smoke" }
case object Snow extends VmsDatexPictogramEnum { override def toString = "snow" }
case object SnowChainsCompulsory extends VmsDatexPictogramEnum { override def toString = "snowChainsCompulsory" }
case object SnowTyresCompulsory extends VmsDatexPictogramEnum { override def toString = "snowTyresCompulsory" }
case object SnowPloughInAction extends VmsDatexPictogramEnum { override def toString = "snowPloughInAction" }
case object SpeedCamerasInAction extends VmsDatexPictogramEnum { override def toString = "speedCamerasInAction" }
case object TrafficCongestion extends VmsDatexPictogramEnum { override def toString = "trafficCongestion" }
case object TrafficDeviatedToOppositeCarriagewayAhead extends VmsDatexPictogramEnum { override def toString = "trafficDeviatedToOppositeCarriagewayAhead" }
case object TrafficPartiallyDeviatedToOppositeCarriagewayAhead extends VmsDatexPictogramEnum { override def toString = "trafficPartiallyDeviatedToOppositeCarriagewayAhead" }
case object TunnelClosed extends VmsDatexPictogramEnum { override def toString = "tunnelClosed" }
case object TurnLeft extends VmsDatexPictogramEnum { override def toString = "turnLeft" }
case object TurnRight extends VmsDatexPictogramEnum { override def toString = "turnRight" }
case object TwoWayTraffic extends VmsDatexPictogramEnum { override def toString = "twoWayTraffic" }
case object UnevenRoad extends VmsDatexPictogramEnum { override def toString = "unevenRoad" }
case object VehicleFire extends VmsDatexPictogramEnum { override def toString = "vehicleFire" }
case object OtherValue4 extends VmsDatexPictogramEnum { override def toString = "other" }

sealed trait VmsDatexSupplementalPictogramEnum

object VmsDatexSupplementalPictogramEnum {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[nu.ndw.VmsDatexSupplementalPictogramEnum]): VmsDatexSupplementalPictogramEnum = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: VmsDatexSupplementalPictogramEnum) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
}

case object DistanceToTheBeginningofTheApplicationZone extends VmsDatexSupplementalPictogramEnum { override def toString = "distanceToTheBeginningofTheApplicationZone" }
case object ExceptAnyPowerDrivenVehicleDrawingTrailer extends VmsDatexSupplementalPictogramEnum { override def toString = "exceptAnyPowerDrivenVehicleDrawingTrailer" }
case object ExceptBus extends VmsDatexSupplementalPictogramEnum { override def toString = "exceptBus" }
case object ExceptGoodsVehicles extends VmsDatexSupplementalPictogramEnum { override def toString = "exceptGoodsVehicles" }
case object ExceptSemiTrailer extends VmsDatexSupplementalPictogramEnum { override def toString = "exceptSemiTrailer" }
case object ExceptVehiclesCarryingDangerousGoods extends VmsDatexSupplementalPictogramEnum { override def toString = "exceptVehiclesCarryingDangerousGoods" }
case object InCaseOfIceOrSnow extends VmsDatexSupplementalPictogramEnum { override def toString = "inCaseOfIceOrSnow" }
case object LengthOfTheApplicationZone extends VmsDatexSupplementalPictogramEnum { override def toString = "lengthOfTheApplicationZone" }
case object RestrictedToAnyPowerDrivenVehicleDrawingTrailer extends VmsDatexSupplementalPictogramEnum { override def toString = "restrictedToAnyPowerDrivenVehicleDrawingTrailer" }
case object RestricetdToBus extends VmsDatexSupplementalPictogramEnum { override def toString = "restricetdToBus" }
case object RestrictedToGoodsVehicles extends VmsDatexSupplementalPictogramEnum { override def toString = "restrictedToGoodsVehicles" }
case object RestrictedToSemiTrailer extends VmsDatexSupplementalPictogramEnum { override def toString = "restrictedToSemiTrailer" }
case object RestrictedToVehiclesCarryingDangerousGoods extends VmsDatexSupplementalPictogramEnum { override def toString = "restrictedToVehiclesCarryingDangerousGoods" }
case object MaintenanceVehiclesValue extends VmsDatexSupplementalPictogramEnum { override def toString = "maintenanceVehicles" }
case object SnowPloughs extends VmsDatexSupplementalPictogramEnum { override def toString = "snowPloughs" }
case object OtherValue87 extends VmsDatexSupplementalPictogramEnum { override def toString = "other" }



case class VmsDynamicCharacteristics(numberOfPictogramDisplayAreas: Option[Int] = None,
  vmsTextDisplayCharacteristics: Option[nu.ndw.VmsTextDisplayCharacteristics] = None,
  vmsPictogramDisplayCharacteristics: Seq[nu.ndw._VmsDynamicCharacteristicsPictogramDisplayAreaIndexVmsPictogramDisplayCharacteristics] = Nil,
  vmsDynamicCharacteristicsExtension: Option[nu.ndw._ExtensionType] = None)
      



case class VmsFault(faultIdentifier: Option[String] = None,
  faultDescription: Option[String] = None,
  faultCreationTime: Option[javax.xml.datatype.XMLGregorianCalendar] = None,
  faultLastUpdateTime: javax.xml.datatype.XMLGregorianCalendar,
  faultSeverity: Option[nu.ndw.FaultSeverityEnum] = None,
  faultExtension: Option[nu.ndw._ExtensionType] = None,
  vmsFault: nu.ndw.VmsFaultEnum,
  vmsFaultExtension: Option[nu.ndw._ExtensionType] = None) extends Faultable
      

sealed trait VmsFaultEnum

object VmsFaultEnum {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[nu.ndw.VmsFaultEnum]): VmsFaultEnum = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: VmsFaultEnum) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
}

case object CommunicationsFailure extends VmsFaultEnum { override def toString = "communicationsFailure" }
case object IncorrectMessageDisplayed extends VmsFaultEnum { override def toString = "incorrectMessageDisplayed" }
case object IncorrectPictogramDisplayed extends VmsFaultEnum { override def toString = "incorrectPictogramDisplayed" }
case object OutOfService extends VmsFaultEnum { override def toString = "outOfService" }
case object PowerFailure extends VmsFaultEnum { override def toString = "powerFailure" }
case object UnableToClearDown extends VmsFaultEnum { override def toString = "unableToClearDown" }
case object Unknown extends VmsFaultEnum { override def toString = "unknown" }
case object OtherValue3 extends VmsFaultEnum { override def toString = "other" }

sealed trait VmsLuminanceLevelEnum

object VmsLuminanceLevelEnum {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[nu.ndw.VmsLuminanceLevelEnum]): VmsLuminanceLevelEnum = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: VmsLuminanceLevelEnum) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
}

case object SwitchedOff extends VmsLuminanceLevelEnum { override def toString = "switchedOff" }
case object Testing extends VmsLuminanceLevelEnum { override def toString = "testing" }
case object Night extends VmsLuminanceLevelEnum { override def toString = "night" }
case object Overcast extends VmsLuminanceLevelEnum { override def toString = "overcast" }
case object BroadDaylight extends VmsLuminanceLevelEnum { override def toString = "broadDaylight" }
case object SunInEyes extends VmsLuminanceLevelEnum { override def toString = "sunInEyes" }
case object SunOnBack extends VmsLuminanceLevelEnum { override def toString = "sunOnBack" }
case object FoggyDay extends VmsLuminanceLevelEnum { override def toString = "foggyDay" }
case object FoggyNight extends VmsLuminanceLevelEnum { override def toString = "foggyNight" }



case class VmsManagedLogicalLocation(managedLogicalLocation: Option[nu.ndw.MultilingualString] = None,
  distanceFromLogicalLocation: Option[Int] = None,
  managedLocation: Option[nu.ndw.Location] = None,
  vmsManagedLogicalLocationExtension: Option[nu.ndw._ExtensionType] = None)
      



case class VmsMessage(associatedManagementOrDiversionPlan: Option[String] = None,
  messageSetBy: Option[nu.ndw.MultilingualString] = None,
  setBySystem: Option[Boolean] = None,
  reasonForSetting: Option[nu.ndw.MultilingualString] = None,
  codedReasonForSetting: Option[nu.ndw.CodedReasonForSettingMessageEnum] = None,
  vmsMessageInformationType: Seq[nu.ndw.VmsMessageInformationTypeEnum] = Nil,
  primarySetting: Option[Boolean] = None,
  mareNostrumCompliant: Option[Boolean] = None,
  timeLastSet: javax.xml.datatype.XMLGregorianCalendar,
  requestedBy: Option[nu.ndw.MultilingualString] = None,
  situationToWhichMessageIsRelated: Option[nu.ndw.VersionedReferencable] = None,
  situationRecordToWhichMessageIsRelated: Option[nu.ndw.VersionedReferencable] = None,
  distanceFromSituationRecord: Option[Float] = None,
  textPictogramSequencingInterval: Option[Float] = None,
  textPage: Seq[nu.ndw._TextPage] = Nil,
  vmsPictogramDisplayArea: Seq[nu.ndw._VmsMessagePictogramDisplayAreaIndexVmsPictogramDisplayArea] = Nil,
  vmsMessageExtension: Option[nu.ndw._ExtensionType] = None)
      

sealed trait VmsMessageInformationTypeEnum

object VmsMessageInformationTypeEnum {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[nu.ndw.VmsMessageInformationTypeEnum]): VmsMessageInformationTypeEnum = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: VmsMessageInformationTypeEnum) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
}

case object CampaignMessage extends VmsMessageInformationTypeEnum { override def toString = "campaignMessage" }
case object DateTime extends VmsMessageInformationTypeEnum { override def toString = "dateTime" }
case object FutureInformation extends VmsMessageInformationTypeEnum { override def toString = "futureInformation" }
case object InstructionOrMessage extends VmsMessageInformationTypeEnum { override def toString = "instructionOrMessage" }
case object SituationWarning extends VmsMessageInformationTypeEnum { override def toString = "situationWarning" }
case object Temperature extends VmsMessageInformationTypeEnum { override def toString = "temperature" }
case object TrafficManagement extends VmsMessageInformationTypeEnum { override def toString = "trafficManagement" }
case object TravelTime extends VmsMessageInformationTypeEnum { override def toString = "travelTime" }



case class VmsPictogram(pictogramDescription: Seq[nu.ndw.VmsDatexPictogramEnum] = Nil,
  pictogramCode: Option[String] = None,
  pictogramUrl: Option[java.net.URI] = None,
  additionalPictogramDescription: Option[nu.ndw.MultilingualString] = None,
  pictogramFlashing: Option[Boolean] = None,
  pictogramInInverseColour: Option[Boolean] = None,
  presenceOfRedTriangle: Boolean,
  viennaConventionCompliant: Option[Boolean] = None,
  distanceAttribute: Option[Int] = None,
  heightAttribute: Option[Float] = None,
  lengthAttribute: Option[Float] = None,
  speedAttribute: Option[Float] = None,
  weightAttribute: Option[Float] = None,
  weightPerAxleAttribute: Option[Float] = None,
  widthAttribute: Option[Float] = None,
  vmsSupplementaryPanel: Option[nu.ndw.VmsSupplementaryPanel] = None,
  vmsPictogramExtension: Option[nu.ndw._ExtensionType] = None)
      



case class VmsPictogramDisplayArea(synchronizedSequencingWithTextPages: Option[Boolean] = None,
  vmsPictogram: Seq[nu.ndw._VmsPictogramDisplayAreaPictogramSequencingIndexVmsPictogram] = Nil,
  vmsPictogramDisplayAreaExtension: Option[nu.ndw._ExtensionType] = None)
      



case class VmsPictogramDisplayCharacteristics(pictogramLanternsPresent: Option[Boolean] = None,
  pictogramSequencingCapable: Option[Boolean] = None,
  pictogramPixelsAcross: Option[Int] = None,
  pictogramPixelsDown: Option[Int] = None,
  pictogramDisplayHeight: Option[Float] = None,
  pictogramDisplayWidth: Option[Float] = None,
  pictogramCodeListIdentifier: Option[String] = None,
  maxPictogramLuminanceLevel: Option[Int] = None,
  pictogramNumberOfColours: Option[Int] = None,
  maxNumberOfSequentialPictograms: Option[Int] = None,
  pictogramPositionAbsolute: Option[nu.ndw.PositionAbsoluteEnum] = None,
  pictogramPositionX: Option[Float] = None,
  pictogramPositionY: Option[Float] = None,
  pictogramPositionRelativeToText: Option[nu.ndw.PositionRelativeEnum] = None,
  vmsSupplementaryPanelCharacteristics: Option[nu.ndw.VmsSupplementaryPanelCharacteristics] = None,
  vmsPictogramDisplayCharacteristicsExtension: Option[nu.ndw._ExtensionType] = None)
      



case class VmsPublication(feedDescription: Option[nu.ndw.MultilingualString] = None,
  feedType: Option[String] = None,
  publicationTime: javax.xml.datatype.XMLGregorianCalendar,
  publicationCreator: nu.ndw.InternationalIdentifier,
  payloadPublicationExtension: Option[nu.ndw._ExtensionType] = None,
  headerInformation: nu.ndw.HeaderInformation,
  vmsUnit: Seq[nu.ndw.VmsUnit] = Nil,
  vmsPublicationExtension: Option[nu.ndw._ExtensionType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) extends PayloadPublication {
  @JsonIgnore lazy val lang = attributes("@lang").as[String]
}

      



case class VmsRecord(vmsDescription: Option[nu.ndw.MultilingualString] = None,
  vmsOwner: Option[nu.ndw.MultilingualString] = None,
  vmsPhysicalMounting: Option[nu.ndw.PhysicalMountingEnum] = None,
  vmsType: Option[nu.ndw.VmsTypeEnum] = None,
  vmsTypeCode: Option[String] = None,
  numberOfPictogramDisplayAreas: Option[Int] = None,
  dynamicallyConfigurableDisplayAreas: Option[Boolean] = None,
  vmsDisplayHeight: Option[Float] = None,
  vmsDisplayWidth: Option[Float] = None,
  vmsHeightAboveRoadway: Option[Float] = None,
  vmsTextDisplayCharacteristics: Option[nu.ndw.VmsTextDisplayCharacteristics] = None,
  vmsPictogramDisplayCharacteristics: Seq[nu.ndw._VmsRecordPictogramDisplayAreaIndexVmsPictogramDisplayCharacteristics] = Nil,
  vmsLocation: Option[nu.ndw.Location] = None,
  vmsManagedLogicalLocation: Option[nu.ndw.VmsManagedLogicalLocation] = None,
  backgroundImageUrl: Option[nu.ndw.UrlLink] = None,
  vmsRecordExtension: Option[nu.ndw._ExtensionType] = None)
      


sealed trait VmsSetting {
  def vmsSettingExtension: Option[nu.ndw._ExtensionType]
}



case class VmsSupplementaryPanel(supplementaryMessageDescription: Option[nu.ndw.MultilingualString] = None,
  vmsSupplementaryPictogram: Option[nu.ndw.VmsSupplementaryPictogram] = None,
  vmsSupplementaryText: Option[nu.ndw.VmsTextLine] = None,
  vmsSupplementaryPanelExtension: Option[nu.ndw._ExtensionType] = None)
      



case class VmsSupplementaryPanelCharacteristics(supplementaryPictogramCodeListIdentifier: Option[String] = None,
  supplementaryPanelPixelsAcross: Option[Int] = None,
  supplementaryPanelPixelsDown: Option[Int] = None,
  supplementaryPanelDisplayHeight: Option[Float] = None,
  supplementaryPanelDisplayWidth: Option[Float] = None,
  supplementaryPanelPositionX: Option[Float] = None,
  supplementaryPanelPositionY: Option[Float] = None,
  relativePositionToPictogramArea: Option[nu.ndw.PositionRelativeEnum] = None,
  vmsSupplementaryPanelCharacteristicsExtension: Option[nu.ndw._ExtensionType] = None)
      



case class VmsSupplementaryPictogram(supplementaryPictogramDescription: Option[nu.ndw.VmsDatexSupplementalPictogramEnum] = None,
  supplementaryPictogramCode: Option[String] = None,
  supplementaryPictogramUrl: Option[java.net.URI] = None,
  additionalSupplementaryPictogramDescription: Option[nu.ndw.MultilingualString] = None,
  pictogramFlashing: Option[Boolean] = None,
  vmsSupplementaryPictogramExtension: Option[nu.ndw._ExtensionType] = None)
      



case class VmsTablePublication(feedDescription: Option[nu.ndw.MultilingualString] = None,
  feedType: Option[String] = None,
  publicationTime: javax.xml.datatype.XMLGregorianCalendar,
  publicationCreator: nu.ndw.InternationalIdentifier,
  payloadPublicationExtension: Option[nu.ndw._ExtensionType] = None,
  headerInformation: nu.ndw.HeaderInformation,
  vmsUnitTable: Seq[nu.ndw.VmsUnitTable] = Nil,
  vmsTablePublicationExtension: Option[nu.ndw._ExtensionType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) extends PayloadPublication {
  @JsonIgnore lazy val lang = attributes("@lang").as[String]
}

      



case class VmsText(vmsLegendCode: Option[String] = None,
  vmsTextImageUrl: Option[java.net.URI] = None,
  vmsTextLine: Seq[nu.ndw._VmsTextLineIndexVmsTextLine] = Nil,
  vmsTextExtension: Option[nu.ndw._ExtensionType] = None)
      



case class VmsTextDisplayCharacteristics(textLanternsPresent: Option[Boolean] = None,
  textPageSequencingCapable: Option[Boolean] = None,
  textPixelsAcross: Option[Int] = None,
  textPixelsDown: Option[Int] = None,
  textDisplayHeight: Option[Float] = None,
  textDisplayWidth: Option[Float] = None,
  maxNumberOfCharacters: Option[Int] = None,
  maxNumberOfRows: Option[Int] = None,
  legendCodeListIdentifier: Option[String] = None,
  maxFontHeight: Option[Int] = None,
  minFontHeight: Option[Int] = None,
  maxFontWidth: Option[Int] = None,
  minFontWidth: Option[Int] = None,
  maxFontSpacing: Option[Int] = None,
  minFontSpacing: Option[Int] = None,
  maxTextLuminanceLevel: Option[Int] = None,
  maxNumberOfSequentialPages: Option[Int] = None,
  textPositionAbsolute: Option[nu.ndw.PositionAbsoluteEnum] = None,
  textPositionX: Option[Float] = None,
  textPositionY: Option[Float] = None,
  vmsTextDisplayCharacteristicsExtension: Option[nu.ndw._ExtensionType] = None)
      



case class VmsTextLine(vmsTextLine: String,
  vmsTextLineLanguage: Option[String] = None,
  vmsTextLineColour: Option[nu.ndw.ColourEnum] = None,
  vmsTextLineFlashing: Option[Boolean] = None,
  vmsTextLineHtml: Option[String] = None,
  vmsTextLineExtension: Option[nu.ndw._ExtensionType] = None)
      

sealed trait VmsTypeEnum

object VmsTypeEnum {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[nu.ndw.VmsTypeEnum]): VmsTypeEnum = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: VmsTypeEnum) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
}

case object ColourGraphic extends VmsTypeEnum { override def toString = "colourGraphic" }
case object ContinuousSign extends VmsTypeEnum { override def toString = "continuousSign" }
case object MonochromeGraphic extends VmsTypeEnum { override def toString = "monochromeGraphic" }
case object MatrixSign extends VmsTypeEnum { override def toString = "matrixSign" }
case object OtherValue2 extends VmsTypeEnum { override def toString = "other" }



case class VmsUnit(vmsSettingExtension: Option[nu.ndw._ExtensionType] = None,
  vmsUnitTableReference: nu.ndw._VmsUnitTableVersionedReference,
  vmsUnitReference: nu.ndw._VmsUnitRecordVersionedReference,
  vms: Seq[nu.ndw._VmsUnitVmsIndexVms] = Nil,
  vmsUnitFault: Seq[nu.ndw.VmsUnitFault] = Nil,
  vmsUnitExtension: Option[nu.ndw._ExtensionType] = None) extends VmsSetting
      



case class VmsUnitFault(faultIdentifier: Option[String] = None,
  faultDescription: Option[String] = None,
  faultCreationTime: Option[javax.xml.datatype.XMLGregorianCalendar] = None,
  faultLastUpdateTime: javax.xml.datatype.XMLGregorianCalendar,
  faultSeverity: Option[nu.ndw.FaultSeverityEnum] = None,
  faultExtension: Option[nu.ndw._ExtensionType] = None,
  vmsUnitFault: nu.ndw.VmsFaultEnum,
  vmsUnitFaultExtension: Option[nu.ndw._ExtensionType] = None) extends Faultable
      



case class VmsUnitRecord(numberOfVms: Option[Int] = None,
  vmsUnitIdentifier: Option[String] = None,
  vmsUnitIPAddress: Option[String] = None,
  vmsUnitElectronicAddress: Option[String] = None,
  vmsRecord: Seq[nu.ndw._VmsUnitRecordVmsIndexVmsRecord] = Nil,
  vmsUnitRecordExtension: Option[nu.ndw._ExtensionType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  @JsonIgnore lazy val id = attributes("@id").as[String]
  @JsonIgnore lazy val version = attributes("@version").as[String]
}

      



case class VmsUnitTable(vmsUnitTableIdentification: Option[String] = None,
  vmsUnitRecord: Seq[nu.ndw.VmsUnitRecord] = Nil,
  vmsUnitTableExtension: Option[nu.ndw._ExtensionType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  @JsonIgnore lazy val id = attributes("@id").as[String]
  @JsonIgnore lazy val version = attributes("@version").as[String]
}

      


sealed trait WeatherData extends BasicData {
  def measurementOrCalculationPeriod: Option[Float]
  def measurementOrCalculationTime: Option[javax.xml.datatype.XMLGregorianCalendar]
  def pertinentLocation: Option[nu.ndw.GroupOfLocations]
  def basicDataExtension: Option[nu.ndw._ExtensionType]
  def weatherDataExtension: Option[nu.ndw._ExtensionType]
  def measurementOrCalculatedTimePrecision: Option[nu.ndw.TimePrecisionEnum]
}



case class WeatherRelatedRoadConditions(situationRecordCreationReference: Option[String] = None,
  situationRecordCreationTime: javax.xml.datatype.XMLGregorianCalendar,
  situationRecordObservationTime: Option[javax.xml.datatype.XMLGregorianCalendar] = None,
  situationRecordVersionTime: javax.xml.datatype.XMLGregorianCalendar,
  situationRecordFirstSupplierVersionTime: Option[javax.xml.datatype.XMLGregorianCalendar] = None,
  confidentialityOverride: Option[nu.ndw.ConfidentialityValueEnum] = None,
  probabilityOfOccurrence: nu.ndw.ProbabilityOfOccurrenceEnum,
  severity: Option[nu.ndw.SeverityEnum] = None,
  source: Option[nu.ndw.Source] = None,
  validity: nu.ndw.Validity,
  impact: Option[nu.ndw.Impact] = None,
  cause: Option[nu.ndw.Cause] = None,
  generalPublicComment: Seq[nu.ndw.Comment] = Nil,
  nonGeneralPublicComment: Seq[nu.ndw.Comment] = Nil,
  urlLink: Seq[nu.ndw.UrlLink] = Nil,
  groupOfLocations: nu.ndw.GroupOfLocations,
  management: Option[nu.ndw.Management] = None,
  situationRecordExtension: Option[nu.ndw._SituationRecordExtensionType] = None,
  trafficElementExtension: Option[nu.ndw._ExtensionType] = None,
  drivingConditionType: Option[nu.ndw.DrivingConditionTypeEnum] = None,
  conditionsExtension: Option[nu.ndw._ExtensionType] = None,
  roadConditionsExtension: Option[nu.ndw._ExtensionType] = None,
  weatherRelatedRoadConditionType: Seq[nu.ndw.WeatherRelatedRoadConditionTypeEnum] = Nil,
  roadSurfaceConditionMeasurements: Option[nu.ndw.RoadSurfaceConditionMeasurements] = None,
  weatherRelatedRoadConditionsExtension: Option[nu.ndw._ExtensionType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) extends RoadConditions {
  @JsonIgnore lazy val id = attributes("@id").as[String]
  @JsonIgnore lazy val version = attributes("@version").as[String]
}

      

sealed trait WeatherRelatedRoadConditionTypeEnum

object WeatherRelatedRoadConditionTypeEnum {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[nu.ndw.WeatherRelatedRoadConditionTypeEnum]): WeatherRelatedRoadConditionTypeEnum = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: WeatherRelatedRoadConditionTypeEnum) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
}

case object BlackIce extends WeatherRelatedRoadConditionTypeEnum { override def toString = "blackIce" }
case object DeepSnow extends WeatherRelatedRoadConditionTypeEnum { override def toString = "deepSnow" }
case object Dry extends WeatherRelatedRoadConditionTypeEnum { override def toString = "dry" }
case object FreezingOfWetRoads extends WeatherRelatedRoadConditionTypeEnum { override def toString = "freezingOfWetRoads" }
case object FreezingPavements extends WeatherRelatedRoadConditionTypeEnum { override def toString = "freezingPavements" }
case object FreezingRain extends WeatherRelatedRoadConditionTypeEnum { override def toString = "freezingRain" }
case object FreshSnow extends WeatherRelatedRoadConditionTypeEnum { override def toString = "freshSnow" }
case object Ice extends WeatherRelatedRoadConditionTypeEnum { override def toString = "ice" }
case object IceBuildUp extends WeatherRelatedRoadConditionTypeEnum { override def toString = "iceBuildUp" }
case object IceWithWheelBarTracks extends WeatherRelatedRoadConditionTypeEnum { override def toString = "iceWithWheelBarTracks" }
case object IcyPatches extends WeatherRelatedRoadConditionTypeEnum { override def toString = "icyPatches" }
case object LooseSnow extends WeatherRelatedRoadConditionTypeEnum { override def toString = "looseSnow" }
case object NormalWinterConditionsForPedestrians extends WeatherRelatedRoadConditionTypeEnum { override def toString = "normalWinterConditionsForPedestrians" }
case object PackedSnow extends WeatherRelatedRoadConditionTypeEnum { override def toString = "packedSnow" }
case object RoadSurfaceMelting extends WeatherRelatedRoadConditionTypeEnum { override def toString = "roadSurfaceMelting" }
case object SlipperyRoad extends WeatherRelatedRoadConditionTypeEnum { override def toString = "slipperyRoad" }
case object SlushOnRoad extends WeatherRelatedRoadConditionTypeEnum { override def toString = "slushOnRoad" }
case object SlushStrings extends WeatherRelatedRoadConditionTypeEnum { override def toString = "slushStrings" }
case object SnowDrifts extends WeatherRelatedRoadConditionTypeEnum { override def toString = "snowDrifts" }
case object SnowOnPavement extends WeatherRelatedRoadConditionTypeEnum { override def toString = "snowOnPavement" }
case object SnowOnTheRoad extends WeatherRelatedRoadConditionTypeEnum { override def toString = "snowOnTheRoad" }
case object SurfaceWater extends WeatherRelatedRoadConditionTypeEnum { override def toString = "surfaceWater" }
case object Wet extends WeatherRelatedRoadConditionTypeEnum { override def toString = "wet" }
case object WetAndIcyRoad extends WeatherRelatedRoadConditionTypeEnum { override def toString = "wetAndIcyRoad" }
case object WetIcyPavement extends WeatherRelatedRoadConditionTypeEnum { override def toString = "wetIcyPavement" }
case object OtherValue extends WeatherRelatedRoadConditionTypeEnum { override def toString = "other" }

sealed trait WeekOfMonthEnum

object WeekOfMonthEnum {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[nu.ndw.WeekOfMonthEnum]): WeekOfMonthEnum = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: WeekOfMonthEnum) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
}

case object FirstWeekOfMonth extends WeekOfMonthEnum { override def toString = "firstWeekOfMonth" }
case object SecondWeekOfMonth extends WeekOfMonthEnum { override def toString = "secondWeekOfMonth" }
case object ThirdWeekOfMonth extends WeekOfMonthEnum { override def toString = "thirdWeekOfMonth" }
case object FourthWeekOfMonth extends WeekOfMonthEnum { override def toString = "fourthWeekOfMonth" }
case object FifthWeekOfMonth extends WeekOfMonthEnum { override def toString = "fifthWeekOfMonth" }



case class WidthCharacteristic(comparisonOperator: nu.ndw.ComparisonOperatorEnum,
  vehicleWidth: Float,
  widthCharacteristicExtension: Option[nu.ndw._ExtensionType] = None)
      



case class Wind(windMeasurementHeight: Option[Int] = None,
  windSpeed: Option[nu.ndw.SpeedValue] = None,
  maximumWindSpeed: Option[nu.ndw.SpeedValue] = None,
  windDirectionBearing: Option[nu.ndw.DirectionBearingValue] = None,
  windDirectionCompass: Option[nu.ndw.DirectionCompassValue] = None,
  windExtension: Option[nu.ndw._ExtensionType] = None)
      



case class WindInformation(measurementOrCalculationPeriod: Option[Float] = None,
  measurementOrCalculationTime: Option[javax.xml.datatype.XMLGregorianCalendar] = None,
  pertinentLocation: Option[nu.ndw.GroupOfLocations] = None,
  basicDataExtension: Option[nu.ndw._ExtensionType] = None,
  weatherDataExtension: Option[nu.ndw._ExtensionType] = None,
  wind: nu.ndw.Wind,
  windInformationExtension: Option[nu.ndw._ExtensionType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) extends WeatherData {
  @JsonIgnore lazy val measurementOrCalculatedTimePrecision = attributes.get("@measurementOrCalculatedTimePrecision") map { _.as[TimePrecisionEnum]}
}

      



case class WinterDrivingManagement(situationRecordCreationReference: Option[String] = None,
  situationRecordCreationTime: javax.xml.datatype.XMLGregorianCalendar,
  situationRecordObservationTime: Option[javax.xml.datatype.XMLGregorianCalendar] = None,
  situationRecordVersionTime: javax.xml.datatype.XMLGregorianCalendar,
  situationRecordFirstSupplierVersionTime: Option[javax.xml.datatype.XMLGregorianCalendar] = None,
  confidentialityOverride: Option[nu.ndw.ConfidentialityValueEnum] = None,
  probabilityOfOccurrence: nu.ndw.ProbabilityOfOccurrenceEnum,
  severity: Option[nu.ndw.SeverityEnum] = None,
  source: Option[nu.ndw.Source] = None,
  validity: nu.ndw.Validity,
  impact: Option[nu.ndw.Impact] = None,
  cause: Option[nu.ndw.Cause] = None,
  generalPublicComment: Seq[nu.ndw.Comment] = Nil,
  nonGeneralPublicComment: Seq[nu.ndw.Comment] = Nil,
  urlLink: Seq[nu.ndw.UrlLink] = Nil,
  groupOfLocations: nu.ndw.GroupOfLocations,
  management: Option[nu.ndw.Management] = None,
  situationRecordExtension: Option[nu.ndw._SituationRecordExtensionType] = None,
  actionOrigin: Option[nu.ndw.OperatorActionOriginEnum] = None,
  actionPlanIdentifier: Option[String] = None,
  operatorActionStatus: Option[nu.ndw.OperatorActionStatusEnum] = None,
  operatorActionExtension: Option[nu.ndw._ExtensionType] = None,
  complianceOption: nu.ndw.ComplianceOptionEnum,
  applicableForTrafficDirection: Seq[nu.ndw.DirectionEnum] = Nil,
  applicableForTrafficType: Seq[nu.ndw.TrafficTypeEnum] = Nil,
  placesAtWhichApplicable: Seq[nu.ndw.PlacesEnum] = Nil,
  automaticallyInitiated: Option[Boolean] = None,
  forVehiclesWithCharacteristicsOf: Seq[nu.ndw.VehicleCharacteristics] = Nil,
  networkManagementExtension: Option[nu.ndw._ExtensionType] = None,
  winterEquipmentManagementType: nu.ndw.WinterEquipmentManagementTypeEnum,
  winterDrivingManagementExtension: Option[nu.ndw._ExtensionType] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) extends NetworkManagement {
  @JsonIgnore lazy val id = attributes("@id").as[String]
  @JsonIgnore lazy val version = attributes("@version").as[String]
}

      

sealed trait WinterEquipmentManagementTypeEnum

object WinterEquipmentManagementTypeEnum {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[nu.ndw.WinterEquipmentManagementTypeEnum]): WinterEquipmentManagementTypeEnum = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: WinterEquipmentManagementTypeEnum) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
}

case object DoNoUseStudTyres extends WinterEquipmentManagementTypeEnum { override def toString = "doNoUseStudTyres" }
case object UseSnowChains extends WinterEquipmentManagementTypeEnum { override def toString = "useSnowChains" }
case object UseSnowChainsOrTyres extends WinterEquipmentManagementTypeEnum { override def toString = "useSnowChainsOrTyres" }
case object UseSnowTyres extends WinterEquipmentManagementTypeEnum { override def toString = "useSnowTyres" }
case object WinterEquipmentOnBoardRequired extends WinterEquipmentManagementTypeEnum { override def toString = "winterEquipmentOnBoardRequired" }
case object Other extends WinterEquipmentManagementTypeEnum { override def toString = "other" }

